
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Login
 * 
 */
export type Login = $Result.DefaultSelection<Prisma.$LoginPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerAlias
 * 
 */
export type CustomerAlias = $Result.DefaultSelection<Prisma.$CustomerAliasPayload>
/**
 * Model DebtStatus
 * 
 */
export type DebtStatus = $Result.DefaultSelection<Prisma.$DebtStatusPayload>
/**
 * Model Dept
 * 
 */
export type Dept = $Result.DefaultSelection<Prisma.$DeptPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model UserShop
 * 
 */
export type UserShop = $Result.DefaultSelection<Prisma.$UserShopPayload>
/**
 * Model WalletBase
 * 
 */
export type WalletBase = $Result.DefaultSelection<Prisma.$WalletBasePayload>
/**
 * Model WalletStatus
 * 
 */
export type WalletStatus = $Result.DefaultSelection<Prisma.$WalletStatusPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model CardAllocation
 * 
 */
export type CardAllocation = $Result.DefaultSelection<Prisma.$CardAllocationPayload>
/**
 * Model CardRequest
 * 
 */
export type CardRequest = $Result.DefaultSelection<Prisma.$CardRequestPayload>
/**
 * Model CardRequestStatus
 * 
 */
export type CardRequestStatus = $Result.DefaultSelection<Prisma.$CardRequestStatusPayload>
/**
 * Model CardAllocationDetail
 * 
 */
export type CardAllocationDetail = $Result.DefaultSelection<Prisma.$CardAllocationDetailPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserShopRoleEnum: {
  ADMIN: 'ADMIN',
  OWNER: 'OWNER',
  READ: 'READ'
};

export type UserShopRoleEnum = (typeof UserShopRoleEnum)[keyof typeof UserShopRoleEnum]


export const PermissionActionEnum: {
  MANAGER: 'MANAGER',
  CREATE: 'CREATE',
  READ: 'READ',
  UPDATE: 'UPDATE',
  DETAILS: 'DETAILS',
  SELF: 'SELF'
};

export type PermissionActionEnum = (typeof PermissionActionEnum)[keyof typeof PermissionActionEnum]


export const EntityEnum: {
  Company: 'Company',
  Customer: 'Customer',
  Gym: 'Gym'
};

export type EntityEnum = (typeof EntityEnum)[keyof typeof EntityEnum]


export const CardRequestEnum: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REFUSED: 'REFUSED'
};

export type CardRequestEnum = (typeof CardRequestEnum)[keyof typeof CardRequestEnum]


export const LoginEnum: {
  CUSTOMER: 'CUSTOMER',
  USER: 'USER'
};

export type LoginEnum = (typeof LoginEnum)[keyof typeof LoginEnum]


export const TransactionTypeEnum: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type TransactionTypeEnum = (typeof TransactionTypeEnum)[keyof typeof TransactionTypeEnum]


export const OptViaEnum: {
  MAIL: 'MAIL',
  SMS: 'SMS',
  PUSH: 'PUSH'
};

export type OptViaEnum = (typeof OptViaEnum)[keyof typeof OptViaEnum]


export const OptDurationEnum: {
  MIN_15: 'MIN_15',
  MIN_30: 'MIN_30',
  HOUR_1: 'HOUR_1',
  HOUR_4: 'HOUR_4',
  HOUR_12: 'HOUR_12',
  DAY_1: 'DAY_1',
  DAY_15: 'DAY_15',
  INFINITY: 'INFINITY'
};

export type OptDurationEnum = (typeof OptDurationEnum)[keyof typeof OptDurationEnum]

}

export type UserShopRoleEnum = $Enums.UserShopRoleEnum

export const UserShopRoleEnum: typeof $Enums.UserShopRoleEnum

export type PermissionActionEnum = $Enums.PermissionActionEnum

export const PermissionActionEnum: typeof $Enums.PermissionActionEnum

export type EntityEnum = $Enums.EntityEnum

export const EntityEnum: typeof $Enums.EntityEnum

export type CardRequestEnum = $Enums.CardRequestEnum

export const CardRequestEnum: typeof $Enums.CardRequestEnum

export type LoginEnum = $Enums.LoginEnum

export const LoginEnum: typeof $Enums.LoginEnum

export type TransactionTypeEnum = $Enums.TransactionTypeEnum

export const TransactionTypeEnum: typeof $Enums.TransactionTypeEnum

export type OptViaEnum = $Enums.OptViaEnum

export const OptViaEnum: typeof $Enums.OptViaEnum

export type OptDurationEnum = $Enums.OptDurationEnum

export const OptDurationEnum: typeof $Enums.OptDurationEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Logins
 * const logins = await prisma.login.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Logins
   * const logins = await prisma.login.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.login`: Exposes CRUD operations for the **Login** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logins
    * const logins = await prisma.login.findMany()
    * ```
    */
  get login(): Prisma.LoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAlias`: Exposes CRUD operations for the **CustomerAlias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAliases
    * const customerAliases = await prisma.customerAlias.findMany()
    * ```
    */
  get customerAlias(): Prisma.CustomerAliasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtStatus`: Exposes CRUD operations for the **DebtStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtStatuses
    * const debtStatuses = await prisma.debtStatus.findMany()
    * ```
    */
  get debtStatus(): Prisma.DebtStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dept`: Exposes CRUD operations for the **Dept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depts
    * const depts = await prisma.dept.findMany()
    * ```
    */
  get dept(): Prisma.DeptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userShop`: Exposes CRUD operations for the **UserShop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserShops
    * const userShops = await prisma.userShop.findMany()
    * ```
    */
  get userShop(): Prisma.UserShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletBase`: Exposes CRUD operations for the **WalletBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletBases
    * const walletBases = await prisma.walletBase.findMany()
    * ```
    */
  get walletBase(): Prisma.WalletBaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletStatus`: Exposes CRUD operations for the **WalletStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletStatuses
    * const walletStatuses = await prisma.walletStatus.findMany()
    * ```
    */
  get walletStatus(): Prisma.WalletStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardAllocation`: Exposes CRUD operations for the **CardAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardAllocations
    * const cardAllocations = await prisma.cardAllocation.findMany()
    * ```
    */
  get cardAllocation(): Prisma.CardAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardRequest`: Exposes CRUD operations for the **CardRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardRequests
    * const cardRequests = await prisma.cardRequest.findMany()
    * ```
    */
  get cardRequest(): Prisma.CardRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardRequestStatus`: Exposes CRUD operations for the **CardRequestStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardRequestStatuses
    * const cardRequestStatuses = await prisma.cardRequestStatus.findMany()
    * ```
    */
  get cardRequestStatus(): Prisma.CardRequestStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardAllocationDetail`: Exposes CRUD operations for the **CardAllocationDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardAllocationDetails
    * const cardAllocationDetails = await prisma.cardAllocationDetail.findMany()
    * ```
    */
  get cardAllocationDetail(): Prisma.CardAllocationDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Login: 'Login',
    Otp: 'Otp',
    User: 'User',
    Customer: 'Customer',
    CustomerAlias: 'CustomerAlias',
    DebtStatus: 'DebtStatus',
    Dept: 'Dept',
    Shop: 'Shop',
    UserShop: 'UserShop',
    WalletBase: 'WalletBase',
    WalletStatus: 'WalletStatus',
    Transaction: 'Transaction',
    Card: 'Card',
    CardAllocation: 'CardAllocation',
    CardRequest: 'CardRequest',
    CardRequestStatus: 'CardRequestStatus',
    CardAllocationDetail: 'CardAllocationDetail',
    Assignment: 'Assignment',
    Module: 'Module',
    Role: 'Role',
    RolePermission: 'RolePermission',
    Permission: 'Permission',
    Offer: 'Offer',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "login" | "otp" | "user" | "customer" | "customerAlias" | "debtStatus" | "dept" | "shop" | "userShop" | "walletBase" | "walletStatus" | "transaction" | "card" | "cardAllocation" | "cardRequest" | "cardRequestStatus" | "cardAllocationDetail" | "assignment" | "module" | "role" | "rolePermission" | "permission" | "offer" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Login: {
        payload: Prisma.$LoginPayload<ExtArgs>
        fields: Prisma.LoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          findFirst: {
            args: Prisma.LoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          findMany: {
            args: Prisma.LoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>[]
          }
          create: {
            args: Prisma.LoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          createMany: {
            args: Prisma.LoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          update: {
            args: Prisma.LoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          deleteMany: {
            args: Prisma.LoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          aggregate: {
            args: Prisma.LoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogin>
          }
          groupBy: {
            args: Prisma.LoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginCountArgs<ExtArgs>
            result: $Utils.Optional<LoginCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerAlias: {
        payload: Prisma.$CustomerAliasPayload<ExtArgs>
        fields: Prisma.CustomerAliasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAliasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAliasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          findFirst: {
            args: Prisma.CustomerAliasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAliasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          findMany: {
            args: Prisma.CustomerAliasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>[]
          }
          create: {
            args: Prisma.CustomerAliasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          createMany: {
            args: Prisma.CustomerAliasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerAliasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          update: {
            args: Prisma.CustomerAliasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAliasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAliasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerAliasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAliasPayload>
          }
          aggregate: {
            args: Prisma.CustomerAliasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAlias>
          }
          groupBy: {
            args: Prisma.CustomerAliasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAliasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAliasCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAliasCountAggregateOutputType> | number
          }
        }
      }
      DebtStatus: {
        payload: Prisma.$DebtStatusPayload<ExtArgs>
        fields: Prisma.DebtStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          findFirst: {
            args: Prisma.DebtStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          findMany: {
            args: Prisma.DebtStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>[]
          }
          create: {
            args: Prisma.DebtStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          createMany: {
            args: Prisma.DebtStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DebtStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          update: {
            args: Prisma.DebtStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          deleteMany: {
            args: Prisma.DebtStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DebtStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtStatusPayload>
          }
          aggregate: {
            args: Prisma.DebtStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtStatus>
          }
          groupBy: {
            args: Prisma.DebtStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtStatusCountArgs<ExtArgs>
            result: $Utils.Optional<DebtStatusCountAggregateOutputType> | number
          }
        }
      }
      Dept: {
        payload: Prisma.$DeptPayload<ExtArgs>
        fields: Prisma.DeptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          findFirst: {
            args: Prisma.DeptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          findMany: {
            args: Prisma.DeptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>[]
          }
          create: {
            args: Prisma.DeptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          createMany: {
            args: Prisma.DeptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          update: {
            args: Prisma.DeptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          deleteMany: {
            args: Prisma.DeptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeptPayload>
          }
          aggregate: {
            args: Prisma.DeptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDept>
          }
          groupBy: {
            args: Prisma.DeptGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeptGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeptCountArgs<ExtArgs>
            result: $Utils.Optional<DeptCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      UserShop: {
        payload: Prisma.$UserShopPayload<ExtArgs>
        fields: Prisma.UserShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          findFirst: {
            args: Prisma.UserShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          findMany: {
            args: Prisma.UserShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>[]
          }
          create: {
            args: Prisma.UserShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          createMany: {
            args: Prisma.UserShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          update: {
            args: Prisma.UserShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          deleteMany: {
            args: Prisma.UserShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserShopPayload>
          }
          aggregate: {
            args: Prisma.UserShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserShop>
          }
          groupBy: {
            args: Prisma.UserShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserShopCountArgs<ExtArgs>
            result: $Utils.Optional<UserShopCountAggregateOutputType> | number
          }
        }
      }
      WalletBase: {
        payload: Prisma.$WalletBasePayload<ExtArgs>
        fields: Prisma.WalletBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletBaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletBaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          findFirst: {
            args: Prisma.WalletBaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletBaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          findMany: {
            args: Prisma.WalletBaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>[]
          }
          create: {
            args: Prisma.WalletBaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          createMany: {
            args: Prisma.WalletBaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletBaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          update: {
            args: Prisma.WalletBaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          deleteMany: {
            args: Prisma.WalletBaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletBaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletBaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletBasePayload>
          }
          aggregate: {
            args: Prisma.WalletBaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletBase>
          }
          groupBy: {
            args: Prisma.WalletBaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletBaseCountArgs<ExtArgs>
            result: $Utils.Optional<WalletBaseCountAggregateOutputType> | number
          }
        }
      }
      WalletStatus: {
        payload: Prisma.$WalletStatusPayload<ExtArgs>
        fields: Prisma.WalletStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          findFirst: {
            args: Prisma.WalletStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          findMany: {
            args: Prisma.WalletStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>[]
          }
          create: {
            args: Prisma.WalletStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          createMany: {
            args: Prisma.WalletStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          update: {
            args: Prisma.WalletStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          deleteMany: {
            args: Prisma.WalletStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletStatusPayload>
          }
          aggregate: {
            args: Prisma.WalletStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletStatus>
          }
          groupBy: {
            args: Prisma.WalletStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletStatusCountArgs<ExtArgs>
            result: $Utils.Optional<WalletStatusCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      CardAllocation: {
        payload: Prisma.$CardAllocationPayload<ExtArgs>
        fields: Prisma.CardAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          findFirst: {
            args: Prisma.CardAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          findMany: {
            args: Prisma.CardAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>[]
          }
          create: {
            args: Prisma.CardAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          createMany: {
            args: Prisma.CardAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          update: {
            args: Prisma.CardAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          deleteMany: {
            args: Prisma.CardAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationPayload>
          }
          aggregate: {
            args: Prisma.CardAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardAllocation>
          }
          groupBy: {
            args: Prisma.CardAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<CardAllocationCountAggregateOutputType> | number
          }
        }
      }
      CardRequest: {
        payload: Prisma.$CardRequestPayload<ExtArgs>
        fields: Prisma.CardRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          findFirst: {
            args: Prisma.CardRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          findMany: {
            args: Prisma.CardRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>[]
          }
          create: {
            args: Prisma.CardRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          createMany: {
            args: Prisma.CardRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          update: {
            args: Prisma.CardRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          deleteMany: {
            args: Prisma.CardRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          aggregate: {
            args: Prisma.CardRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardRequest>
          }
          groupBy: {
            args: Prisma.CardRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CardRequestCountAggregateOutputType> | number
          }
        }
      }
      CardRequestStatus: {
        payload: Prisma.$CardRequestStatusPayload<ExtArgs>
        fields: Prisma.CardRequestStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardRequestStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardRequestStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          findFirst: {
            args: Prisma.CardRequestStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardRequestStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          findMany: {
            args: Prisma.CardRequestStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>[]
          }
          create: {
            args: Prisma.CardRequestStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          createMany: {
            args: Prisma.CardRequestStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardRequestStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          update: {
            args: Prisma.CardRequestStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          deleteMany: {
            args: Prisma.CardRequestStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardRequestStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardRequestStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestStatusPayload>
          }
          aggregate: {
            args: Prisma.CardRequestStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardRequestStatus>
          }
          groupBy: {
            args: Prisma.CardRequestStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardRequestStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardRequestStatusCountArgs<ExtArgs>
            result: $Utils.Optional<CardRequestStatusCountAggregateOutputType> | number
          }
        }
      }
      CardAllocationDetail: {
        payload: Prisma.$CardAllocationDetailPayload<ExtArgs>
        fields: Prisma.CardAllocationDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardAllocationDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardAllocationDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          findFirst: {
            args: Prisma.CardAllocationDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardAllocationDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          findMany: {
            args: Prisma.CardAllocationDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>[]
          }
          create: {
            args: Prisma.CardAllocationDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          createMany: {
            args: Prisma.CardAllocationDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardAllocationDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          update: {
            args: Prisma.CardAllocationDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          deleteMany: {
            args: Prisma.CardAllocationDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardAllocationDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardAllocationDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardAllocationDetailPayload>
          }
          aggregate: {
            args: Prisma.CardAllocationDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardAllocationDetail>
          }
          groupBy: {
            args: Prisma.CardAllocationDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardAllocationDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardAllocationDetailCountArgs<ExtArgs>
            result: $Utils.Optional<CardAllocationDetailCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    login?: LoginOmit
    otp?: OtpOmit
    user?: UserOmit
    customer?: CustomerOmit
    customerAlias?: CustomerAliasOmit
    debtStatus?: DebtStatusOmit
    dept?: DeptOmit
    shop?: ShopOmit
    userShop?: UserShopOmit
    walletBase?: WalletBaseOmit
    walletStatus?: WalletStatusOmit
    transaction?: TransactionOmit
    card?: CardOmit
    cardAllocation?: CardAllocationOmit
    cardRequest?: CardRequestOmit
    cardRequestStatus?: CardRequestStatusOmit
    cardAllocationDetail?: CardAllocationDetailOmit
    assignment?: AssignmentOmit
    module?: ModuleOmit
    role?: RoleOmit
    rolePermission?: RolePermissionOmit
    permission?: PermissionOmit
    offer?: OfferOmit
    payment?: PaymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LoginCountOutputType
   */

  export type LoginCountOutputType = {
    Otp: number
  }

  export type LoginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Otp?: boolean | LoginCountOutputTypeCountOtpArgs
  }

  // Custom InputTypes
  /**
   * LoginCountOutputType without action
   */
  export type LoginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCountOutputType
     */
    select?: LoginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoginCountOutputType without action
   */
  export type LoginCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userShop: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userShop?: boolean | UserCountOutputTypeCountUserShopArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserShopWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    customerAlias: number
    assignment: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAlias?: boolean | CustomerCountOutputTypeCountCustomerAliasArgs
    assignment?: boolean | CustomerCountOutputTypeCountAssignmentArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAliasWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }


  /**
   * Count Type CustomerAliasCountOutputType
   */

  export type CustomerAliasCountOutputType = {
    dept: number
    debtStatus: number
  }

  export type CustomerAliasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dept?: boolean | CustomerAliasCountOutputTypeCountDeptArgs
    debtStatus?: boolean | CustomerAliasCountOutputTypeCountDebtStatusArgs
  }

  // Custom InputTypes
  /**
   * CustomerAliasCountOutputType without action
   */
  export type CustomerAliasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAliasCountOutputType
     */
    select?: CustomerAliasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerAliasCountOutputType without action
   */
  export type CustomerAliasCountOutputTypeCountDeptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeptWhereInput
  }

  /**
   * CustomerAliasCountOutputType without action
   */
  export type CustomerAliasCountOutputTypeCountDebtStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtStatusWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    cardAllocation: number
    userShop: number
    customerAlias: number
    payment: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardAllocation?: boolean | ShopCountOutputTypeCountCardAllocationArgs
    userShop?: boolean | ShopCountOutputTypeCountUserShopArgs
    customerAlias?: boolean | ShopCountOutputTypeCountCustomerAliasArgs
    payment?: boolean | ShopCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountCardAllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAllocationWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountUserShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserShopWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountCustomerAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAliasWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type WalletBaseCountOutputType
   */

  export type WalletBaseCountOutputType = {
    fromTransaction: number
    toTransaction: number
    walletStatus: number
  }

  export type WalletBaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromTransaction?: boolean | WalletBaseCountOutputTypeCountFromTransactionArgs
    toTransaction?: boolean | WalletBaseCountOutputTypeCountToTransactionArgs
    walletStatus?: boolean | WalletBaseCountOutputTypeCountWalletStatusArgs
  }

  // Custom InputTypes
  /**
   * WalletBaseCountOutputType without action
   */
  export type WalletBaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBaseCountOutputType
     */
    select?: WalletBaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletBaseCountOutputType without action
   */
  export type WalletBaseCountOutputTypeCountFromTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * WalletBaseCountOutputType without action
   */
  export type WalletBaseCountOutputTypeCountToTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * WalletBaseCountOutputType without action
   */
  export type WalletBaseCountOutputTypeCountWalletStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletStatusWhereInput
  }


  /**
   * Count Type CardCountOutputType
   */

  export type CardCountOutputType = {
    assignment: number
    cardAllocationDetail: number
  }

  export type CardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | CardCountOutputTypeCountAssignmentArgs
    cardAllocationDetail?: boolean | CardCountOutputTypeCountCardAllocationDetailArgs
  }

  // Custom InputTypes
  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     */
    select?: CardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountCardAllocationDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAllocationDetailWhereInput
  }


  /**
   * Count Type CardAllocationCountOutputType
   */

  export type CardAllocationCountOutputType = {
    cardAllocationDetail: number
  }

  export type CardAllocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardAllocationDetail?: boolean | CardAllocationCountOutputTypeCountCardAllocationDetailArgs
  }

  // Custom InputTypes
  /**
   * CardAllocationCountOutputType without action
   */
  export type CardAllocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationCountOutputType
     */
    select?: CardAllocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardAllocationCountOutputType without action
   */
  export type CardAllocationCountOutputTypeCountCardAllocationDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAllocationDetailWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    permission: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | ModuleCountOutputTypeCountPermissionArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolePermission: number
    login: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | RoleCountOutputTypeCountRolePermissionArgs
    login?: boolean | RoleCountOutputTypeCountLoginArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermission: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | PermissionCountOutputTypeCountRolePermissionArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    payment: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | OfferCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Login
   */

  export type AggregateLogin = {
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  export type LoginAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type LoginSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type LoginMinAggregateOutputType = {
    id: number | null
    type: $Enums.LoginEnum | null
    username: string | null
    password: string | null
    isActive: boolean | null
    isBlocked: boolean | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoginMaxAggregateOutputType = {
    id: number | null
    type: $Enums.LoginEnum | null
    username: string | null
    password: string | null
    isActive: boolean | null
    isBlocked: boolean | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoginCountAggregateOutputType = {
    id: number
    type: number
    username: number
    password: number
    isActive: number
    isBlocked: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoginAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type LoginSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type LoginMinAggregateInputType = {
    id?: true
    type?: true
    username?: true
    password?: true
    isActive?: true
    isBlocked?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoginMaxAggregateInputType = {
    id?: true
    type?: true
    username?: true
    password?: true
    isActive?: true
    isBlocked?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoginCountAggregateInputType = {
    id?: true
    type?: true
    username?: true
    password?: true
    isActive?: true
    isBlocked?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Login to aggregate.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logins
    **/
    _count?: true | LoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginMaxAggregateInputType
  }

  export type GetLoginAggregateType<T extends LoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin[P]>
      : GetScalarType<T[P], AggregateLogin[P]>
  }




  export type LoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginWhereInput
    orderBy?: LoginOrderByWithAggregationInput | LoginOrderByWithAggregationInput[]
    by: LoginScalarFieldEnum[] | LoginScalarFieldEnum
    having?: LoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginCountAggregateInputType | true
    _avg?: LoginAvgAggregateInputType
    _sum?: LoginSumAggregateInputType
    _min?: LoginMinAggregateInputType
    _max?: LoginMaxAggregateInputType
  }

  export type LoginGroupByOutputType = {
    id: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive: boolean
    isBlocked: boolean
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  type GetLoginGroupByPayload<T extends LoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginGroupByOutputType[P]>
            : GetScalarType<T[P], LoginGroupByOutputType[P]>
        }
      >
    >


  export type LoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    isBlocked?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Login$customerArgs<ExtArgs>
    role?: boolean | Login$roleArgs<ExtArgs>
    user?: boolean | Login$userArgs<ExtArgs>
    Otp?: boolean | Login$OtpArgs<ExtArgs>
    _count?: boolean | LoginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["login"]>



  export type LoginSelectScalar = {
    id?: boolean
    type?: boolean
    username?: boolean
    password?: boolean
    isActive?: boolean
    isBlocked?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "username" | "password" | "isActive" | "isBlocked" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["login"]>
  export type LoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Login$customerArgs<ExtArgs>
    role?: boolean | Login$roleArgs<ExtArgs>
    user?: boolean | Login$userArgs<ExtArgs>
    Otp?: boolean | Login$OtpArgs<ExtArgs>
    _count?: boolean | LoginCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Login"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      role: Prisma.$RolePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      Otp: Prisma.$OtpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.LoginEnum
      username: string
      password: string
      isActive: boolean
      isBlocked: boolean
      roleId: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["login"]>
    composites: {}
  }

  type LoginGetPayload<S extends boolean | null | undefined | LoginDefaultArgs> = $Result.GetResult<Prisma.$LoginPayload, S>

  type LoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginCountAggregateInputType | true
    }

  export interface LoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Login'], meta: { name: 'Login' } }
    /**
     * Find zero or one Login that matches the filter.
     * @param {LoginFindUniqueArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginFindUniqueArgs>(args: SelectSubset<T, LoginFindUniqueArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Login that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginFindUniqueOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Login that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindFirstArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginFindFirstArgs>(args?: SelectSubset<T, LoginFindFirstArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Login that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindFirstOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logins
     * const logins = await prisma.login.findMany()
     * 
     * // Get first 10 Logins
     * const logins = await prisma.login.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginWithIdOnly = await prisma.login.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginFindManyArgs>(args?: SelectSubset<T, LoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Login.
     * @param {LoginCreateArgs} args - Arguments to create a Login.
     * @example
     * // Create one Login
     * const Login = await prisma.login.create({
     *   data: {
     *     // ... data to create a Login
     *   }
     * })
     * 
     */
    create<T extends LoginCreateArgs>(args: SelectSubset<T, LoginCreateArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logins.
     * @param {LoginCreateManyArgs} args - Arguments to create many Logins.
     * @example
     * // Create many Logins
     * const login = await prisma.login.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginCreateManyArgs>(args?: SelectSubset<T, LoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Login.
     * @param {LoginDeleteArgs} args - Arguments to delete one Login.
     * @example
     * // Delete one Login
     * const Login = await prisma.login.delete({
     *   where: {
     *     // ... filter to delete one Login
     *   }
     * })
     * 
     */
    delete<T extends LoginDeleteArgs>(args: SelectSubset<T, LoginDeleteArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Login.
     * @param {LoginUpdateArgs} args - Arguments to update one Login.
     * @example
     * // Update one Login
     * const login = await prisma.login.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginUpdateArgs>(args: SelectSubset<T, LoginUpdateArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logins.
     * @param {LoginDeleteManyArgs} args - Arguments to filter Logins to delete.
     * @example
     * // Delete a few Logins
     * const { count } = await prisma.login.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginDeleteManyArgs>(args?: SelectSubset<T, LoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logins
     * const login = await prisma.login.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginUpdateManyArgs>(args: SelectSubset<T, LoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login.
     * @param {LoginUpsertArgs} args - Arguments to update or create a Login.
     * @example
     * // Update or create a Login
     * const login = await prisma.login.upsert({
     *   create: {
     *     // ... data to create a Login
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login we want to update
     *   }
     * })
     */
    upsert<T extends LoginUpsertArgs>(args: SelectSubset<T, LoginUpsertArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCountArgs} args - Arguments to filter Logins to count.
     * @example
     * // Count the number of Logins
     * const count = await prisma.login.count({
     *   where: {
     *     // ... the filter for the Logins we want to count
     *   }
     * })
    **/
    count<T extends LoginCountArgs>(
      args?: Subset<T, LoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAggregateArgs>(args: Subset<T, LoginAggregateArgs>): Prisma.PrismaPromise<GetLoginAggregateType<T>>

    /**
     * Group by Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginGroupByArgs['orderBy'] }
        : { orderBy?: LoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Login model
   */
  readonly fields: LoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Login.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Login$customerArgs<ExtArgs> = {}>(args?: Subset<T, Login$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends Login$roleArgs<ExtArgs> = {}>(args?: Subset<T, Login$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Login$userArgs<ExtArgs> = {}>(args?: Subset<T, Login$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Otp<T extends Login$OtpArgs<ExtArgs> = {}>(args?: Subset<T, Login$OtpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Login model
   */ 
  interface LoginFieldRefs {
    readonly id: FieldRef<"Login", 'Int'>
    readonly type: FieldRef<"Login", 'LoginEnum'>
    readonly username: FieldRef<"Login", 'String'>
    readonly password: FieldRef<"Login", 'String'>
    readonly isActive: FieldRef<"Login", 'Boolean'>
    readonly isBlocked: FieldRef<"Login", 'Boolean'>
    readonly roleId: FieldRef<"Login", 'Int'>
    readonly createdAt: FieldRef<"Login", 'DateTime'>
    readonly updatedAt: FieldRef<"Login", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Login findUnique
   */
  export type LoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where: LoginWhereUniqueInput
  }

  /**
   * Login findUniqueOrThrow
   */
  export type LoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where: LoginWhereUniqueInput
  }

  /**
   * Login findFirst
   */
  export type LoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * Login findFirstOrThrow
   */
  export type LoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * Login findMany
   */
  export type LoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Logins to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * Login create
   */
  export type LoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The data needed to create a Login.
     */
    data: XOR<LoginCreateInput, LoginUncheckedCreateInput>
  }

  /**
   * Login createMany
   */
  export type LoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logins.
     */
    data: LoginCreateManyInput | LoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Login update
   */
  export type LoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The data needed to update a Login.
     */
    data: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
    /**
     * Choose, which Login to update.
     */
    where: LoginWhereUniqueInput
  }

  /**
   * Login updateMany
   */
  export type LoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logins.
     */
    data: XOR<LoginUpdateManyMutationInput, LoginUncheckedUpdateManyInput>
    /**
     * Filter which Logins to update
     */
    where?: LoginWhereInput
    /**
     * Limit how many Logins to update.
     */
    limit?: number
  }

  /**
   * Login upsert
   */
  export type LoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The filter to search for the Login to update in case it exists.
     */
    where: LoginWhereUniqueInput
    /**
     * In case the Login found by the `where` argument doesn't exist, create a new Login with this data.
     */
    create: XOR<LoginCreateInput, LoginUncheckedCreateInput>
    /**
     * In case the Login was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
  }

  /**
   * Login delete
   */
  export type LoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter which Login to delete.
     */
    where: LoginWhereUniqueInput
  }

  /**
   * Login deleteMany
   */
  export type LoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logins to delete
     */
    where?: LoginWhereInput
    /**
     * Limit how many Logins to delete.
     */
    limit?: number
  }

  /**
   * Login.customer
   */
  export type Login$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Login.role
   */
  export type Login$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * Login.user
   */
  export type Login$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Login.Otp
   */
  export type Login$OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Login without action
   */
  export type LoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
    loginId: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
    loginId: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    to: string | null
    code: string | null
    duration: $Enums.OptDurationEnum | null
    via: $Enums.OptViaEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    loginId: number | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    to: string | null
    code: string | null
    duration: $Enums.OptDurationEnum | null
    via: $Enums.OptViaEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    loginId: number | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    to: number
    code: number
    duration: number
    via: number
    createdAt: number
    updatedAt: number
    loginId: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
    loginId?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
    loginId?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    to?: true
    code?: true
    duration?: true
    via?: true
    createdAt?: true
    updatedAt?: true
    loginId?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    to?: true
    code?: true
    duration?: true
    via?: true
    createdAt?: true
    updatedAt?: true
    loginId?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    to?: true
    code?: true
    duration?: true
    via?: true
    createdAt?: true
    updatedAt?: true
    loginId?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: number
    to: string | null
    code: string
    duration: $Enums.OptDurationEnum
    via: $Enums.OptViaEnum
    createdAt: Date | null
    updatedAt: Date | null
    loginId: number | null
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    to?: boolean
    code?: boolean
    duration?: boolean
    via?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loginId?: boolean
    login?: boolean | Otp$loginArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    to?: boolean
    code?: boolean
    duration?: boolean
    via?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loginId?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "to" | "code" | "duration" | "via" | "createdAt" | "updatedAt" | "loginId", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login?: boolean | Otp$loginArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      login: Prisma.$LoginPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      to: string | null
      code: string
      duration: $Enums.OptDurationEnum
      via: $Enums.OptViaEnum
      createdAt: Date | null
      updatedAt: Date | null
      loginId: number | null
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    login<T extends Otp$loginArgs<ExtArgs> = {}>(args?: Subset<T, Otp$loginArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */ 
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'Int'>
    readonly to: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly duration: FieldRef<"Otp", 'OptDurationEnum'>
    readonly via: FieldRef<"Otp", 'OptViaEnum'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly updatedAt: FieldRef<"Otp", 'DateTime'>
    readonly loginId: FieldRef<"Otp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp.login
   */
  export type Otp$loginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    where?: LoginWhereInput
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    loginId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    loginId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    loginId: number | null
    displayname: string | null
    email: string | null
    address: string | null
    phone: string | null
    dateOfBirth: Date | null
    laltitude: Decimal | null
    longitude: Decimal | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    loginId: number | null
    displayname: string | null
    email: string | null
    address: string | null
    phone: string | null
    dateOfBirth: Date | null
    laltitude: Decimal | null
    longitude: Decimal | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    loginId: number
    displayname: number
    email: number
    address: number
    phone: number
    dateOfBirth: number
    laltitude: number
    longitude: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    loginId?: true
    laltitude?: true
    longitude?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    loginId?: true
    laltitude?: true
    longitude?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    loginId?: true
    displayname?: true
    email?: true
    address?: true
    phone?: true
    dateOfBirth?: true
    laltitude?: true
    longitude?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    loginId?: true
    displayname?: true
    email?: true
    address?: true
    phone?: true
    dateOfBirth?: true
    laltitude?: true
    longitude?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    loginId?: true
    displayname?: true
    email?: true
    address?: true
    phone?: true
    dateOfBirth?: true
    laltitude?: true
    longitude?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    loginId: number | null
    displayname: string
    email: string | null
    address: string
    phone: string
    dateOfBirth: Date | null
    laltitude: Decimal | null
    longitude: Decimal | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginId?: boolean
    displayname?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    laltitude?: boolean
    longitude?: boolean
    login?: boolean | User$loginArgs<ExtArgs>
    userShop?: boolean | User$userShopArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    loginId?: boolean
    displayname?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    laltitude?: boolean
    longitude?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loginId" | "displayname" | "email" | "address" | "phone" | "dateOfBirth" | "laltitude" | "longitude", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login?: boolean | User$loginArgs<ExtArgs>
    userShop?: boolean | User$userShopArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      login: Prisma.$LoginPayload<ExtArgs> | null
      userShop: Prisma.$UserShopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loginId: number | null
      displayname: string
      email: string | null
      address: string
      phone: string
      dateOfBirth: Date | null
      laltitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    login<T extends User$loginArgs<ExtArgs> = {}>(args?: Subset<T, User$loginArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userShop<T extends User$userShopArgs<ExtArgs> = {}>(args?: Subset<T, User$userShopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly loginId: FieldRef<"User", 'Int'>
    readonly displayname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly laltitude: FieldRef<"User", 'Decimal'>
    readonly longitude: FieldRef<"User", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.login
   */
  export type User$loginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    where?: LoginWhereInput
  }

  /**
   * User.userShop
   */
  export type User$userShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    where?: UserShopWhereInput
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    cursor?: UserShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserShopScalarFieldEnum | UserShopScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    loginId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    entityBaseId: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    loginId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    entityBaseId: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    loginId: number | null
    address: string | null
    phone: string | null
    laltitude: Decimal | null
    longitude: Decimal | null
    dateOfBirth: Date | null
    entityBaseId: number | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    loginId: number | null
    address: string | null
    phone: string | null
    laltitude: Decimal | null
    longitude: Decimal | null
    dateOfBirth: Date | null
    entityBaseId: number | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    loginId: number
    address: number
    phone: number
    laltitude: number
    longitude: number
    dateOfBirth: number
    entityBaseId: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    loginId?: true
    laltitude?: true
    longitude?: true
    entityBaseId?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    loginId?: true
    laltitude?: true
    longitude?: true
    entityBaseId?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    loginId?: true
    address?: true
    phone?: true
    laltitude?: true
    longitude?: true
    dateOfBirth?: true
    entityBaseId?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    loginId?: true
    address?: true
    phone?: true
    laltitude?: true
    longitude?: true
    dateOfBirth?: true
    entityBaseId?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    loginId?: true
    address?: true
    phone?: true
    laltitude?: true
    longitude?: true
    dateOfBirth?: true
    entityBaseId?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    loginId: number | null
    address: string | null
    phone: string
    laltitude: Decimal | null
    longitude: Decimal | null
    dateOfBirth: Date | null
    entityBaseId: number
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginId?: boolean
    address?: boolean
    phone?: boolean
    laltitude?: boolean
    longitude?: boolean
    dateOfBirth?: boolean
    entityBaseId?: boolean
    Login?: boolean | Customer$LoginArgs<ExtArgs>
    customerAlias?: boolean | Customer$customerAliasArgs<ExtArgs>
    WalletBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
    assignment?: boolean | Customer$assignmentArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    loginId?: boolean
    address?: boolean
    phone?: boolean
    laltitude?: boolean
    longitude?: boolean
    dateOfBirth?: boolean
    entityBaseId?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loginId" | "address" | "phone" | "laltitude" | "longitude" | "dateOfBirth" | "entityBaseId", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Login?: boolean | Customer$LoginArgs<ExtArgs>
    customerAlias?: boolean | Customer$customerAliasArgs<ExtArgs>
    WalletBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
    assignment?: boolean | Customer$assignmentArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      Login: Prisma.$LoginPayload<ExtArgs> | null
      customerAlias: Prisma.$CustomerAliasPayload<ExtArgs>[]
      WalletBase: Prisma.$WalletBasePayload<ExtArgs>
      assignment: Prisma.$AssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loginId: number | null
      address: string | null
      phone: string
      laltitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      dateOfBirth: Date | null
      entityBaseId: number
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Login<T extends Customer$LoginArgs<ExtArgs> = {}>(args?: Subset<T, Customer$LoginArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customerAlias<T extends Customer$customerAliasArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerAliasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WalletBase<T extends WalletBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletBaseDefaultArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignment<T extends Customer$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, Customer$assignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly loginId: FieldRef<"Customer", 'Int'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly laltitude: FieldRef<"Customer", 'Decimal'>
    readonly longitude: FieldRef<"Customer", 'Decimal'>
    readonly dateOfBirth: FieldRef<"Customer", 'DateTime'>
    readonly entityBaseId: FieldRef<"Customer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.Login
   */
  export type Customer$LoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    where?: LoginWhereInput
  }

  /**
   * Customer.customerAlias
   */
  export type Customer$customerAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    where?: CustomerAliasWhereInput
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    cursor?: CustomerAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAliasScalarFieldEnum | CustomerAliasScalarFieldEnum[]
  }

  /**
   * Customer.assignment
   */
  export type Customer$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAlias
   */

  export type AggregateCustomerAlias = {
    _count: CustomerAliasCountAggregateOutputType | null
    _avg: CustomerAliasAvgAggregateOutputType | null
    _sum: CustomerAliasSumAggregateOutputType | null
    _min: CustomerAliasMinAggregateOutputType | null
    _max: CustomerAliasMaxAggregateOutputType | null
  }

  export type CustomerAliasAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    byId: number | null
    shopId: number | null
  }

  export type CustomerAliasSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    byId: number | null
    shopId: number | null
  }

  export type CustomerAliasMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    shopId: number | null
    isActive: boolean | null
  }

  export type CustomerAliasMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    shopId: number | null
    isActive: boolean | null
  }

  export type CustomerAliasCountAggregateOutputType = {
    id: number
    customerId: number
    createdAt: number
    updatedAt: number
    byId: number
    shopId: number
    isActive: number
    _all: number
  }


  export type CustomerAliasAvgAggregateInputType = {
    id?: true
    customerId?: true
    byId?: true
    shopId?: true
  }

  export type CustomerAliasSumAggregateInputType = {
    id?: true
    customerId?: true
    byId?: true
    shopId?: true
  }

  export type CustomerAliasMinAggregateInputType = {
    id?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    shopId?: true
    isActive?: true
  }

  export type CustomerAliasMaxAggregateInputType = {
    id?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    shopId?: true
    isActive?: true
  }

  export type CustomerAliasCountAggregateInputType = {
    id?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    shopId?: true
    isActive?: true
    _all?: true
  }

  export type CustomerAliasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAlias to aggregate.
     */
    where?: CustomerAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAliases to fetch.
     */
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAliases
    **/
    _count?: true | CustomerAliasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAliasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerAliasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAliasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAliasMaxAggregateInputType
  }

  export type GetCustomerAliasAggregateType<T extends CustomerAliasAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAlias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAlias[P]>
      : GetScalarType<T[P], AggregateCustomerAlias[P]>
  }




  export type CustomerAliasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAliasWhereInput
    orderBy?: CustomerAliasOrderByWithAggregationInput | CustomerAliasOrderByWithAggregationInput[]
    by: CustomerAliasScalarFieldEnum[] | CustomerAliasScalarFieldEnum
    having?: CustomerAliasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAliasCountAggregateInputType | true
    _avg?: CustomerAliasAvgAggregateInputType
    _sum?: CustomerAliasSumAggregateInputType
    _min?: CustomerAliasMinAggregateInputType
    _max?: CustomerAliasMaxAggregateInputType
  }

  export type CustomerAliasGroupByOutputType = {
    id: number
    customerId: number
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    shopId: number
    isActive: boolean
    _count: CustomerAliasCountAggregateOutputType | null
    _avg: CustomerAliasAvgAggregateOutputType | null
    _sum: CustomerAliasSumAggregateOutputType | null
    _min: CustomerAliasMinAggregateOutputType | null
    _max: CustomerAliasMaxAggregateOutputType | null
  }

  type GetCustomerAliasGroupByPayload<T extends CustomerAliasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAliasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAliasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAliasGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAliasGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAliasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    shopId?: boolean
    isActive?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    dept?: boolean | CustomerAlias$deptArgs<ExtArgs>
    debtStatus?: boolean | CustomerAlias$debtStatusArgs<ExtArgs>
    _count?: boolean | CustomerAliasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAlias"]>



  export type CustomerAliasSelectScalar = {
    id?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    shopId?: boolean
    isActive?: boolean
  }

  export type CustomerAliasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "createdAt" | "updatedAt" | "byId" | "shopId" | "isActive", ExtArgs["result"]["customerAlias"]>
  export type CustomerAliasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    dept?: boolean | CustomerAlias$deptArgs<ExtArgs>
    debtStatus?: boolean | CustomerAlias$debtStatusArgs<ExtArgs>
    _count?: boolean | CustomerAliasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerAliasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAlias"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      dept: Prisma.$DeptPayload<ExtArgs>[]
      debtStatus: Prisma.$DebtStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
      shopId: number
      isActive: boolean
    }, ExtArgs["result"]["customerAlias"]>
    composites: {}
  }

  type CustomerAliasGetPayload<S extends boolean | null | undefined | CustomerAliasDefaultArgs> = $Result.GetResult<Prisma.$CustomerAliasPayload, S>

  type CustomerAliasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAliasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAliasCountAggregateInputType | true
    }

  export interface CustomerAliasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAlias'], meta: { name: 'CustomerAlias' } }
    /**
     * Find zero or one CustomerAlias that matches the filter.
     * @param {CustomerAliasFindUniqueArgs} args - Arguments to find a CustomerAlias
     * @example
     * // Get one CustomerAlias
     * const customerAlias = await prisma.customerAlias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAliasFindUniqueArgs>(args: SelectSubset<T, CustomerAliasFindUniqueArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAlias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAliasFindUniqueOrThrowArgs} args - Arguments to find a CustomerAlias
     * @example
     * // Get one CustomerAlias
     * const customerAlias = await prisma.customerAlias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAliasFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAliasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAlias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasFindFirstArgs} args - Arguments to find a CustomerAlias
     * @example
     * // Get one CustomerAlias
     * const customerAlias = await prisma.customerAlias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAliasFindFirstArgs>(args?: SelectSubset<T, CustomerAliasFindFirstArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAlias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasFindFirstOrThrowArgs} args - Arguments to find a CustomerAlias
     * @example
     * // Get one CustomerAlias
     * const customerAlias = await prisma.customerAlias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAliasFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAliasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAliases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAliases
     * const customerAliases = await prisma.customerAlias.findMany()
     * 
     * // Get first 10 CustomerAliases
     * const customerAliases = await prisma.customerAlias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAliasWithIdOnly = await prisma.customerAlias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAliasFindManyArgs>(args?: SelectSubset<T, CustomerAliasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAlias.
     * @param {CustomerAliasCreateArgs} args - Arguments to create a CustomerAlias.
     * @example
     * // Create one CustomerAlias
     * const CustomerAlias = await prisma.customerAlias.create({
     *   data: {
     *     // ... data to create a CustomerAlias
     *   }
     * })
     * 
     */
    create<T extends CustomerAliasCreateArgs>(args: SelectSubset<T, CustomerAliasCreateArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAliases.
     * @param {CustomerAliasCreateManyArgs} args - Arguments to create many CustomerAliases.
     * @example
     * // Create many CustomerAliases
     * const customerAlias = await prisma.customerAlias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAliasCreateManyArgs>(args?: SelectSubset<T, CustomerAliasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerAlias.
     * @param {CustomerAliasDeleteArgs} args - Arguments to delete one CustomerAlias.
     * @example
     * // Delete one CustomerAlias
     * const CustomerAlias = await prisma.customerAlias.delete({
     *   where: {
     *     // ... filter to delete one CustomerAlias
     *   }
     * })
     * 
     */
    delete<T extends CustomerAliasDeleteArgs>(args: SelectSubset<T, CustomerAliasDeleteArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAlias.
     * @param {CustomerAliasUpdateArgs} args - Arguments to update one CustomerAlias.
     * @example
     * // Update one CustomerAlias
     * const customerAlias = await prisma.customerAlias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAliasUpdateArgs>(args: SelectSubset<T, CustomerAliasUpdateArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAliases.
     * @param {CustomerAliasDeleteManyArgs} args - Arguments to filter CustomerAliases to delete.
     * @example
     * // Delete a few CustomerAliases
     * const { count } = await prisma.customerAlias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAliasDeleteManyArgs>(args?: SelectSubset<T, CustomerAliasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAliases
     * const customerAlias = await prisma.customerAlias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAliasUpdateManyArgs>(args: SelectSubset<T, CustomerAliasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerAlias.
     * @param {CustomerAliasUpsertArgs} args - Arguments to update or create a CustomerAlias.
     * @example
     * // Update or create a CustomerAlias
     * const customerAlias = await prisma.customerAlias.upsert({
     *   create: {
     *     // ... data to create a CustomerAlias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAlias we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAliasUpsertArgs>(args: SelectSubset<T, CustomerAliasUpsertArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasCountArgs} args - Arguments to filter CustomerAliases to count.
     * @example
     * // Count the number of CustomerAliases
     * const count = await prisma.customerAlias.count({
     *   where: {
     *     // ... the filter for the CustomerAliases we want to count
     *   }
     * })
    **/
    count<T extends CustomerAliasCountArgs>(
      args?: Subset<T, CustomerAliasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAliasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAliasAggregateArgs>(args: Subset<T, CustomerAliasAggregateArgs>): Prisma.PrismaPromise<GetCustomerAliasAggregateType<T>>

    /**
     * Group by CustomerAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAliasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAliasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAliasGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAliasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAliasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAliasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAlias model
   */
  readonly fields: CustomerAliasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAlias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAliasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dept<T extends CustomerAlias$deptArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAlias$deptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtStatus<T extends CustomerAlias$debtStatusArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAlias$debtStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAlias model
   */ 
  interface CustomerAliasFieldRefs {
    readonly id: FieldRef<"CustomerAlias", 'Int'>
    readonly customerId: FieldRef<"CustomerAlias", 'Int'>
    readonly createdAt: FieldRef<"CustomerAlias", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAlias", 'DateTime'>
    readonly byId: FieldRef<"CustomerAlias", 'Int'>
    readonly shopId: FieldRef<"CustomerAlias", 'Int'>
    readonly isActive: FieldRef<"CustomerAlias", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAlias findUnique
   */
  export type CustomerAliasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAlias to fetch.
     */
    where: CustomerAliasWhereUniqueInput
  }

  /**
   * CustomerAlias findUniqueOrThrow
   */
  export type CustomerAliasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAlias to fetch.
     */
    where: CustomerAliasWhereUniqueInput
  }

  /**
   * CustomerAlias findFirst
   */
  export type CustomerAliasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAlias to fetch.
     */
    where?: CustomerAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAliases to fetch.
     */
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAliases.
     */
    cursor?: CustomerAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAliases.
     */
    distinct?: CustomerAliasScalarFieldEnum | CustomerAliasScalarFieldEnum[]
  }

  /**
   * CustomerAlias findFirstOrThrow
   */
  export type CustomerAliasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAlias to fetch.
     */
    where?: CustomerAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAliases to fetch.
     */
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAliases.
     */
    cursor?: CustomerAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAliases.
     */
    distinct?: CustomerAliasScalarFieldEnum | CustomerAliasScalarFieldEnum[]
  }

  /**
   * CustomerAlias findMany
   */
  export type CustomerAliasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAliases to fetch.
     */
    where?: CustomerAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAliases to fetch.
     */
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAliases.
     */
    cursor?: CustomerAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAliases.
     */
    skip?: number
    distinct?: CustomerAliasScalarFieldEnum | CustomerAliasScalarFieldEnum[]
  }

  /**
   * CustomerAlias create
   */
  export type CustomerAliasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAlias.
     */
    data: XOR<CustomerAliasCreateInput, CustomerAliasUncheckedCreateInput>
  }

  /**
   * CustomerAlias createMany
   */
  export type CustomerAliasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAliases.
     */
    data: CustomerAliasCreateManyInput | CustomerAliasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAlias update
   */
  export type CustomerAliasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAlias.
     */
    data: XOR<CustomerAliasUpdateInput, CustomerAliasUncheckedUpdateInput>
    /**
     * Choose, which CustomerAlias to update.
     */
    where: CustomerAliasWhereUniqueInput
  }

  /**
   * CustomerAlias updateMany
   */
  export type CustomerAliasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAliases.
     */
    data: XOR<CustomerAliasUpdateManyMutationInput, CustomerAliasUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAliases to update
     */
    where?: CustomerAliasWhereInput
    /**
     * Limit how many CustomerAliases to update.
     */
    limit?: number
  }

  /**
   * CustomerAlias upsert
   */
  export type CustomerAliasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAlias to update in case it exists.
     */
    where: CustomerAliasWhereUniqueInput
    /**
     * In case the CustomerAlias found by the `where` argument doesn't exist, create a new CustomerAlias with this data.
     */
    create: XOR<CustomerAliasCreateInput, CustomerAliasUncheckedCreateInput>
    /**
     * In case the CustomerAlias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAliasUpdateInput, CustomerAliasUncheckedUpdateInput>
  }

  /**
   * CustomerAlias delete
   */
  export type CustomerAliasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    /**
     * Filter which CustomerAlias to delete.
     */
    where: CustomerAliasWhereUniqueInput
  }

  /**
   * CustomerAlias deleteMany
   */
  export type CustomerAliasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAliases to delete
     */
    where?: CustomerAliasWhereInput
    /**
     * Limit how many CustomerAliases to delete.
     */
    limit?: number
  }

  /**
   * CustomerAlias.dept
   */
  export type CustomerAlias$deptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    where?: DeptWhereInput
    orderBy?: DeptOrderByWithRelationInput | DeptOrderByWithRelationInput[]
    cursor?: DeptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeptScalarFieldEnum | DeptScalarFieldEnum[]
  }

  /**
   * CustomerAlias.debtStatus
   */
  export type CustomerAlias$debtStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    where?: DebtStatusWhereInput
    orderBy?: DebtStatusOrderByWithRelationInput | DebtStatusOrderByWithRelationInput[]
    cursor?: DebtStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtStatusScalarFieldEnum | DebtStatusScalarFieldEnum[]
  }

  /**
   * CustomerAlias without action
   */
  export type CustomerAliasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
  }


  /**
   * Model DebtStatus
   */

  export type AggregateDebtStatus = {
    _count: DebtStatusCountAggregateOutputType | null
    _avg: DebtStatusAvgAggregateOutputType | null
    _sum: DebtStatusSumAggregateOutputType | null
    _min: DebtStatusMinAggregateOutputType | null
    _max: DebtStatusMaxAggregateOutputType | null
  }

  export type DebtStatusAvgAggregateOutputType = {
    id: number | null
    totalCredit: Decimal | null
    totalDebut: Decimal | null
    customerAliasId: number | null
  }

  export type DebtStatusSumAggregateOutputType = {
    id: number | null
    totalCredit: Decimal | null
    totalDebut: Decimal | null
    customerAliasId: number | null
  }

  export type DebtStatusMinAggregateOutputType = {
    id: number | null
    totalCredit: Decimal | null
    totalDebut: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    customerAliasId: number | null
  }

  export type DebtStatusMaxAggregateOutputType = {
    id: number | null
    totalCredit: Decimal | null
    totalDebut: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    customerAliasId: number | null
  }

  export type DebtStatusCountAggregateOutputType = {
    id: number
    totalCredit: number
    totalDebut: number
    createdAt: number
    updatedAt: number
    customerAliasId: number
    _all: number
  }


  export type DebtStatusAvgAggregateInputType = {
    id?: true
    totalCredit?: true
    totalDebut?: true
    customerAliasId?: true
  }

  export type DebtStatusSumAggregateInputType = {
    id?: true
    totalCredit?: true
    totalDebut?: true
    customerAliasId?: true
  }

  export type DebtStatusMinAggregateInputType = {
    id?: true
    totalCredit?: true
    totalDebut?: true
    createdAt?: true
    updatedAt?: true
    customerAliasId?: true
  }

  export type DebtStatusMaxAggregateInputType = {
    id?: true
    totalCredit?: true
    totalDebut?: true
    createdAt?: true
    updatedAt?: true
    customerAliasId?: true
  }

  export type DebtStatusCountAggregateInputType = {
    id?: true
    totalCredit?: true
    totalDebut?: true
    createdAt?: true
    updatedAt?: true
    customerAliasId?: true
    _all?: true
  }

  export type DebtStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtStatus to aggregate.
     */
    where?: DebtStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtStatuses to fetch.
     */
    orderBy?: DebtStatusOrderByWithRelationInput | DebtStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtStatuses
    **/
    _count?: true | DebtStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtStatusMaxAggregateInputType
  }

  export type GetDebtStatusAggregateType<T extends DebtStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtStatus[P]>
      : GetScalarType<T[P], AggregateDebtStatus[P]>
  }




  export type DebtStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtStatusWhereInput
    orderBy?: DebtStatusOrderByWithAggregationInput | DebtStatusOrderByWithAggregationInput[]
    by: DebtStatusScalarFieldEnum[] | DebtStatusScalarFieldEnum
    having?: DebtStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtStatusCountAggregateInputType | true
    _avg?: DebtStatusAvgAggregateInputType
    _sum?: DebtStatusSumAggregateInputType
    _min?: DebtStatusMinAggregateInputType
    _max?: DebtStatusMaxAggregateInputType
  }

  export type DebtStatusGroupByOutputType = {
    id: number
    totalCredit: Decimal
    totalDebut: Decimal
    createdAt: Date | null
    updatedAt: Date | null
    customerAliasId: number
    _count: DebtStatusCountAggregateOutputType | null
    _avg: DebtStatusAvgAggregateOutputType | null
    _sum: DebtStatusSumAggregateOutputType | null
    _min: DebtStatusMinAggregateOutputType | null
    _max: DebtStatusMaxAggregateOutputType | null
  }

  type GetDebtStatusGroupByPayload<T extends DebtStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtStatusGroupByOutputType[P]>
            : GetScalarType<T[P], DebtStatusGroupByOutputType[P]>
        }
      >
    >


  export type DebtStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalCredit?: boolean
    totalDebut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerAliasId?: boolean
    customerAlias?: boolean | CustomerAliasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtStatus"]>



  export type DebtStatusSelectScalar = {
    id?: boolean
    totalCredit?: boolean
    totalDebut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerAliasId?: boolean
  }

  export type DebtStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalCredit" | "totalDebut" | "createdAt" | "updatedAt" | "customerAliasId", ExtArgs["result"]["debtStatus"]>
  export type DebtStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAlias?: boolean | CustomerAliasDefaultArgs<ExtArgs>
  }

  export type $DebtStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtStatus"
    objects: {
      customerAlias: Prisma.$CustomerAliasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalCredit: Prisma.Decimal
      totalDebut: Prisma.Decimal
      createdAt: Date | null
      updatedAt: Date | null
      customerAliasId: number
    }, ExtArgs["result"]["debtStatus"]>
    composites: {}
  }

  type DebtStatusGetPayload<S extends boolean | null | undefined | DebtStatusDefaultArgs> = $Result.GetResult<Prisma.$DebtStatusPayload, S>

  type DebtStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtStatusCountAggregateInputType | true
    }

  export interface DebtStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtStatus'], meta: { name: 'DebtStatus' } }
    /**
     * Find zero or one DebtStatus that matches the filter.
     * @param {DebtStatusFindUniqueArgs} args - Arguments to find a DebtStatus
     * @example
     * // Get one DebtStatus
     * const debtStatus = await prisma.debtStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtStatusFindUniqueArgs>(args: SelectSubset<T, DebtStatusFindUniqueArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DebtStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtStatusFindUniqueOrThrowArgs} args - Arguments to find a DebtStatus
     * @example
     * // Get one DebtStatus
     * const debtStatus = await prisma.debtStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusFindFirstArgs} args - Arguments to find a DebtStatus
     * @example
     * // Get one DebtStatus
     * const debtStatus = await prisma.debtStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtStatusFindFirstArgs>(args?: SelectSubset<T, DebtStatusFindFirstArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusFindFirstOrThrowArgs} args - Arguments to find a DebtStatus
     * @example
     * // Get one DebtStatus
     * const debtStatus = await prisma.debtStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DebtStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtStatuses
     * const debtStatuses = await prisma.debtStatus.findMany()
     * 
     * // Get first 10 DebtStatuses
     * const debtStatuses = await prisma.debtStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtStatusWithIdOnly = await prisma.debtStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtStatusFindManyArgs>(args?: SelectSubset<T, DebtStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DebtStatus.
     * @param {DebtStatusCreateArgs} args - Arguments to create a DebtStatus.
     * @example
     * // Create one DebtStatus
     * const DebtStatus = await prisma.debtStatus.create({
     *   data: {
     *     // ... data to create a DebtStatus
     *   }
     * })
     * 
     */
    create<T extends DebtStatusCreateArgs>(args: SelectSubset<T, DebtStatusCreateArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DebtStatuses.
     * @param {DebtStatusCreateManyArgs} args - Arguments to create many DebtStatuses.
     * @example
     * // Create many DebtStatuses
     * const debtStatus = await prisma.debtStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtStatusCreateManyArgs>(args?: SelectSubset<T, DebtStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DebtStatus.
     * @param {DebtStatusDeleteArgs} args - Arguments to delete one DebtStatus.
     * @example
     * // Delete one DebtStatus
     * const DebtStatus = await prisma.debtStatus.delete({
     *   where: {
     *     // ... filter to delete one DebtStatus
     *   }
     * })
     * 
     */
    delete<T extends DebtStatusDeleteArgs>(args: SelectSubset<T, DebtStatusDeleteArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DebtStatus.
     * @param {DebtStatusUpdateArgs} args - Arguments to update one DebtStatus.
     * @example
     * // Update one DebtStatus
     * const debtStatus = await prisma.debtStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtStatusUpdateArgs>(args: SelectSubset<T, DebtStatusUpdateArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DebtStatuses.
     * @param {DebtStatusDeleteManyArgs} args - Arguments to filter DebtStatuses to delete.
     * @example
     * // Delete a few DebtStatuses
     * const { count } = await prisma.debtStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtStatusDeleteManyArgs>(args?: SelectSubset<T, DebtStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtStatuses
     * const debtStatus = await prisma.debtStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtStatusUpdateManyArgs>(args: SelectSubset<T, DebtStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DebtStatus.
     * @param {DebtStatusUpsertArgs} args - Arguments to update or create a DebtStatus.
     * @example
     * // Update or create a DebtStatus
     * const debtStatus = await prisma.debtStatus.upsert({
     *   create: {
     *     // ... data to create a DebtStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtStatus we want to update
     *   }
     * })
     */
    upsert<T extends DebtStatusUpsertArgs>(args: SelectSubset<T, DebtStatusUpsertArgs<ExtArgs>>): Prisma__DebtStatusClient<$Result.GetResult<Prisma.$DebtStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DebtStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusCountArgs} args - Arguments to filter DebtStatuses to count.
     * @example
     * // Count the number of DebtStatuses
     * const count = await prisma.debtStatus.count({
     *   where: {
     *     // ... the filter for the DebtStatuses we want to count
     *   }
     * })
    **/
    count<T extends DebtStatusCountArgs>(
      args?: Subset<T, DebtStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtStatusAggregateArgs>(args: Subset<T, DebtStatusAggregateArgs>): Prisma.PrismaPromise<GetDebtStatusAggregateType<T>>

    /**
     * Group by DebtStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtStatusGroupByArgs['orderBy'] }
        : { orderBy?: DebtStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtStatus model
   */
  readonly fields: DebtStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerAlias<T extends CustomerAliasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAliasDefaultArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtStatus model
   */ 
  interface DebtStatusFieldRefs {
    readonly id: FieldRef<"DebtStatus", 'Int'>
    readonly totalCredit: FieldRef<"DebtStatus", 'Decimal'>
    readonly totalDebut: FieldRef<"DebtStatus", 'Decimal'>
    readonly createdAt: FieldRef<"DebtStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"DebtStatus", 'DateTime'>
    readonly customerAliasId: FieldRef<"DebtStatus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DebtStatus findUnique
   */
  export type DebtStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter, which DebtStatus to fetch.
     */
    where: DebtStatusWhereUniqueInput
  }

  /**
   * DebtStatus findUniqueOrThrow
   */
  export type DebtStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter, which DebtStatus to fetch.
     */
    where: DebtStatusWhereUniqueInput
  }

  /**
   * DebtStatus findFirst
   */
  export type DebtStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter, which DebtStatus to fetch.
     */
    where?: DebtStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtStatuses to fetch.
     */
    orderBy?: DebtStatusOrderByWithRelationInput | DebtStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtStatuses.
     */
    cursor?: DebtStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtStatuses.
     */
    distinct?: DebtStatusScalarFieldEnum | DebtStatusScalarFieldEnum[]
  }

  /**
   * DebtStatus findFirstOrThrow
   */
  export type DebtStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter, which DebtStatus to fetch.
     */
    where?: DebtStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtStatuses to fetch.
     */
    orderBy?: DebtStatusOrderByWithRelationInput | DebtStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtStatuses.
     */
    cursor?: DebtStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtStatuses.
     */
    distinct?: DebtStatusScalarFieldEnum | DebtStatusScalarFieldEnum[]
  }

  /**
   * DebtStatus findMany
   */
  export type DebtStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter, which DebtStatuses to fetch.
     */
    where?: DebtStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtStatuses to fetch.
     */
    orderBy?: DebtStatusOrderByWithRelationInput | DebtStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtStatuses.
     */
    cursor?: DebtStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtStatuses.
     */
    skip?: number
    distinct?: DebtStatusScalarFieldEnum | DebtStatusScalarFieldEnum[]
  }

  /**
   * DebtStatus create
   */
  export type DebtStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtStatus.
     */
    data: XOR<DebtStatusCreateInput, DebtStatusUncheckedCreateInput>
  }

  /**
   * DebtStatus createMany
   */
  export type DebtStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtStatuses.
     */
    data: DebtStatusCreateManyInput | DebtStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DebtStatus update
   */
  export type DebtStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtStatus.
     */
    data: XOR<DebtStatusUpdateInput, DebtStatusUncheckedUpdateInput>
    /**
     * Choose, which DebtStatus to update.
     */
    where: DebtStatusWhereUniqueInput
  }

  /**
   * DebtStatus updateMany
   */
  export type DebtStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtStatuses.
     */
    data: XOR<DebtStatusUpdateManyMutationInput, DebtStatusUncheckedUpdateManyInput>
    /**
     * Filter which DebtStatuses to update
     */
    where?: DebtStatusWhereInput
    /**
     * Limit how many DebtStatuses to update.
     */
    limit?: number
  }

  /**
   * DebtStatus upsert
   */
  export type DebtStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtStatus to update in case it exists.
     */
    where: DebtStatusWhereUniqueInput
    /**
     * In case the DebtStatus found by the `where` argument doesn't exist, create a new DebtStatus with this data.
     */
    create: XOR<DebtStatusCreateInput, DebtStatusUncheckedCreateInput>
    /**
     * In case the DebtStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtStatusUpdateInput, DebtStatusUncheckedUpdateInput>
  }

  /**
   * DebtStatus delete
   */
  export type DebtStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
    /**
     * Filter which DebtStatus to delete.
     */
    where: DebtStatusWhereUniqueInput
  }

  /**
   * DebtStatus deleteMany
   */
  export type DebtStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtStatuses to delete
     */
    where?: DebtStatusWhereInput
    /**
     * Limit how many DebtStatuses to delete.
     */
    limit?: number
  }

  /**
   * DebtStatus without action
   */
  export type DebtStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtStatus
     */
    select?: DebtStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtStatus
     */
    omit?: DebtStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtStatusInclude<ExtArgs> | null
  }


  /**
   * Model Dept
   */

  export type AggregateDept = {
    _count: DeptCountAggregateOutputType | null
    _avg: DeptAvgAggregateOutputType | null
    _sum: DeptSumAggregateOutputType | null
    _min: DeptMinAggregateOutputType | null
    _max: DeptMaxAggregateOutputType | null
  }

  export type DeptAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    customerAliasId: number | null
  }

  export type DeptSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    customerAliasId: number | null
  }

  export type DeptMinAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    comment: string | null
    type: $Enums.TransactionTypeEnum | null
    customerAliasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeptMaxAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    comment: string | null
    type: $Enums.TransactionTypeEnum | null
    customerAliasId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeptCountAggregateOutputType = {
    id: number
    amount: number
    comment: number
    type: number
    customerAliasId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeptAvgAggregateInputType = {
    id?: true
    amount?: true
    customerAliasId?: true
  }

  export type DeptSumAggregateInputType = {
    id?: true
    amount?: true
    customerAliasId?: true
  }

  export type DeptMinAggregateInputType = {
    id?: true
    amount?: true
    comment?: true
    type?: true
    customerAliasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeptMaxAggregateInputType = {
    id?: true
    amount?: true
    comment?: true
    type?: true
    customerAliasId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeptCountAggregateInputType = {
    id?: true
    amount?: true
    comment?: true
    type?: true
    customerAliasId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dept to aggregate.
     */
    where?: DeptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depts to fetch.
     */
    orderBy?: DeptOrderByWithRelationInput | DeptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Depts
    **/
    _count?: true | DeptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeptMaxAggregateInputType
  }

  export type GetDeptAggregateType<T extends DeptAggregateArgs> = {
        [P in keyof T & keyof AggregateDept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDept[P]>
      : GetScalarType<T[P], AggregateDept[P]>
  }




  export type DeptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeptWhereInput
    orderBy?: DeptOrderByWithAggregationInput | DeptOrderByWithAggregationInput[]
    by: DeptScalarFieldEnum[] | DeptScalarFieldEnum
    having?: DeptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeptCountAggregateInputType | true
    _avg?: DeptAvgAggregateInputType
    _sum?: DeptSumAggregateInputType
    _min?: DeptMinAggregateInputType
    _max?: DeptMaxAggregateInputType
  }

  export type DeptGroupByOutputType = {
    id: number
    amount: Decimal
    comment: string | null
    type: $Enums.TransactionTypeEnum
    customerAliasId: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: DeptCountAggregateOutputType | null
    _avg: DeptAvgAggregateOutputType | null
    _sum: DeptSumAggregateOutputType | null
    _min: DeptMinAggregateOutputType | null
    _max: DeptMaxAggregateOutputType | null
  }

  type GetDeptGroupByPayload<T extends DeptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeptGroupByOutputType[P]>
            : GetScalarType<T[P], DeptGroupByOutputType[P]>
        }
      >
    >


  export type DeptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    comment?: boolean
    type?: boolean
    customerAliasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerAlias?: boolean | CustomerAliasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dept"]>



  export type DeptSelectScalar = {
    id?: boolean
    amount?: boolean
    comment?: boolean
    type?: boolean
    customerAliasId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "comment" | "type" | "customerAliasId" | "createdAt" | "updatedAt", ExtArgs["result"]["dept"]>
  export type DeptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAlias?: boolean | CustomerAliasDefaultArgs<ExtArgs>
  }

  export type $DeptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dept"
    objects: {
      customerAlias: Prisma.$CustomerAliasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: Prisma.Decimal
      comment: string | null
      type: $Enums.TransactionTypeEnum
      customerAliasId: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["dept"]>
    composites: {}
  }

  type DeptGetPayload<S extends boolean | null | undefined | DeptDefaultArgs> = $Result.GetResult<Prisma.$DeptPayload, S>

  type DeptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeptCountAggregateInputType | true
    }

  export interface DeptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dept'], meta: { name: 'Dept' } }
    /**
     * Find zero or one Dept that matches the filter.
     * @param {DeptFindUniqueArgs} args - Arguments to find a Dept
     * @example
     * // Get one Dept
     * const dept = await prisma.dept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeptFindUniqueArgs>(args: SelectSubset<T, DeptFindUniqueArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dept that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeptFindUniqueOrThrowArgs} args - Arguments to find a Dept
     * @example
     * // Get one Dept
     * const dept = await prisma.dept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeptFindUniqueOrThrowArgs>(args: SelectSubset<T, DeptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptFindFirstArgs} args - Arguments to find a Dept
     * @example
     * // Get one Dept
     * const dept = await prisma.dept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeptFindFirstArgs>(args?: SelectSubset<T, DeptFindFirstArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptFindFirstOrThrowArgs} args - Arguments to find a Dept
     * @example
     * // Get one Dept
     * const dept = await prisma.dept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeptFindFirstOrThrowArgs>(args?: SelectSubset<T, DeptFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Depts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depts
     * const depts = await prisma.dept.findMany()
     * 
     * // Get first 10 Depts
     * const depts = await prisma.dept.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deptWithIdOnly = await prisma.dept.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeptFindManyArgs>(args?: SelectSubset<T, DeptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dept.
     * @param {DeptCreateArgs} args - Arguments to create a Dept.
     * @example
     * // Create one Dept
     * const Dept = await prisma.dept.create({
     *   data: {
     *     // ... data to create a Dept
     *   }
     * })
     * 
     */
    create<T extends DeptCreateArgs>(args: SelectSubset<T, DeptCreateArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Depts.
     * @param {DeptCreateManyArgs} args - Arguments to create many Depts.
     * @example
     * // Create many Depts
     * const dept = await prisma.dept.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeptCreateManyArgs>(args?: SelectSubset<T, DeptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dept.
     * @param {DeptDeleteArgs} args - Arguments to delete one Dept.
     * @example
     * // Delete one Dept
     * const Dept = await prisma.dept.delete({
     *   where: {
     *     // ... filter to delete one Dept
     *   }
     * })
     * 
     */
    delete<T extends DeptDeleteArgs>(args: SelectSubset<T, DeptDeleteArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dept.
     * @param {DeptUpdateArgs} args - Arguments to update one Dept.
     * @example
     * // Update one Dept
     * const dept = await prisma.dept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeptUpdateArgs>(args: SelectSubset<T, DeptUpdateArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Depts.
     * @param {DeptDeleteManyArgs} args - Arguments to filter Depts to delete.
     * @example
     * // Delete a few Depts
     * const { count } = await prisma.dept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeptDeleteManyArgs>(args?: SelectSubset<T, DeptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depts
     * const dept = await prisma.dept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeptUpdateManyArgs>(args: SelectSubset<T, DeptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dept.
     * @param {DeptUpsertArgs} args - Arguments to update or create a Dept.
     * @example
     * // Update or create a Dept
     * const dept = await prisma.dept.upsert({
     *   create: {
     *     // ... data to create a Dept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dept we want to update
     *   }
     * })
     */
    upsert<T extends DeptUpsertArgs>(args: SelectSubset<T, DeptUpsertArgs<ExtArgs>>): Prisma__DeptClient<$Result.GetResult<Prisma.$DeptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Depts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptCountArgs} args - Arguments to filter Depts to count.
     * @example
     * // Count the number of Depts
     * const count = await prisma.dept.count({
     *   where: {
     *     // ... the filter for the Depts we want to count
     *   }
     * })
    **/
    count<T extends DeptCountArgs>(
      args?: Subset<T, DeptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeptAggregateArgs>(args: Subset<T, DeptAggregateArgs>): Prisma.PrismaPromise<GetDeptAggregateType<T>>

    /**
     * Group by Dept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeptGroupByArgs['orderBy'] }
        : { orderBy?: DeptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dept model
   */
  readonly fields: DeptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerAlias<T extends CustomerAliasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerAliasDefaultArgs<ExtArgs>>): Prisma__CustomerAliasClient<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dept model
   */ 
  interface DeptFieldRefs {
    readonly id: FieldRef<"Dept", 'Int'>
    readonly amount: FieldRef<"Dept", 'Decimal'>
    readonly comment: FieldRef<"Dept", 'String'>
    readonly type: FieldRef<"Dept", 'TransactionTypeEnum'>
    readonly customerAliasId: FieldRef<"Dept", 'Int'>
    readonly createdAt: FieldRef<"Dept", 'DateTime'>
    readonly updatedAt: FieldRef<"Dept", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dept findUnique
   */
  export type DeptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter, which Dept to fetch.
     */
    where: DeptWhereUniqueInput
  }

  /**
   * Dept findUniqueOrThrow
   */
  export type DeptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter, which Dept to fetch.
     */
    where: DeptWhereUniqueInput
  }

  /**
   * Dept findFirst
   */
  export type DeptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter, which Dept to fetch.
     */
    where?: DeptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depts to fetch.
     */
    orderBy?: DeptOrderByWithRelationInput | DeptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depts.
     */
    cursor?: DeptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depts.
     */
    distinct?: DeptScalarFieldEnum | DeptScalarFieldEnum[]
  }

  /**
   * Dept findFirstOrThrow
   */
  export type DeptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter, which Dept to fetch.
     */
    where?: DeptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depts to fetch.
     */
    orderBy?: DeptOrderByWithRelationInput | DeptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depts.
     */
    cursor?: DeptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depts.
     */
    distinct?: DeptScalarFieldEnum | DeptScalarFieldEnum[]
  }

  /**
   * Dept findMany
   */
  export type DeptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter, which Depts to fetch.
     */
    where?: DeptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depts to fetch.
     */
    orderBy?: DeptOrderByWithRelationInput | DeptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Depts.
     */
    cursor?: DeptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depts.
     */
    skip?: number
    distinct?: DeptScalarFieldEnum | DeptScalarFieldEnum[]
  }

  /**
   * Dept create
   */
  export type DeptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * The data needed to create a Dept.
     */
    data: XOR<DeptCreateInput, DeptUncheckedCreateInput>
  }

  /**
   * Dept createMany
   */
  export type DeptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Depts.
     */
    data: DeptCreateManyInput | DeptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dept update
   */
  export type DeptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * The data needed to update a Dept.
     */
    data: XOR<DeptUpdateInput, DeptUncheckedUpdateInput>
    /**
     * Choose, which Dept to update.
     */
    where: DeptWhereUniqueInput
  }

  /**
   * Dept updateMany
   */
  export type DeptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Depts.
     */
    data: XOR<DeptUpdateManyMutationInput, DeptUncheckedUpdateManyInput>
    /**
     * Filter which Depts to update
     */
    where?: DeptWhereInput
    /**
     * Limit how many Depts to update.
     */
    limit?: number
  }

  /**
   * Dept upsert
   */
  export type DeptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * The filter to search for the Dept to update in case it exists.
     */
    where: DeptWhereUniqueInput
    /**
     * In case the Dept found by the `where` argument doesn't exist, create a new Dept with this data.
     */
    create: XOR<DeptCreateInput, DeptUncheckedCreateInput>
    /**
     * In case the Dept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeptUpdateInput, DeptUncheckedUpdateInput>
  }

  /**
   * Dept delete
   */
  export type DeptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
    /**
     * Filter which Dept to delete.
     */
    where: DeptWhereUniqueInput
  }

  /**
   * Dept deleteMany
   */
  export type DeptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depts to delete
     */
    where?: DeptWhereInput
    /**
     * Limit how many Depts to delete.
     */
    limit?: number
  }

  /**
   * Dept without action
   */
  export type DeptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dept
     */
    select?: DeptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dept
     */
    omit?: DeptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeptInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    id: number | null
    entityBaseId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    byId: number | null
  }

  export type ShopSumAggregateOutputType = {
    id: number | null
    entityBaseId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    byId: number | null
  }

  export type ShopMinAggregateOutputType = {
    id: number | null
    entityBaseId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type ShopMaxAggregateOutputType = {
    id: number | null
    entityBaseId: number | null
    laltitude: Decimal | null
    longitude: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    entityBaseId: number
    laltitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    byId: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    id?: true
    entityBaseId?: true
    laltitude?: true
    longitude?: true
    byId?: true
  }

  export type ShopSumAggregateInputType = {
    id?: true
    entityBaseId?: true
    laltitude?: true
    longitude?: true
    byId?: true
  }

  export type ShopMinAggregateInputType = {
    id?: true
    entityBaseId?: true
    laltitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    entityBaseId?: true
    laltitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    entityBaseId?: true
    laltitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: number
    entityBaseId: number
    laltitude: Decimal | null
    longitude: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityBaseId?: boolean
    laltitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    entityBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
    cardAllocation?: boolean | Shop$cardAllocationArgs<ExtArgs>
    userShop?: boolean | Shop$userShopArgs<ExtArgs>
    customerAlias?: boolean | Shop$customerAliasArgs<ExtArgs>
    payment?: boolean | Shop$paymentArgs<ExtArgs>
    cardRequest?: boolean | Shop$cardRequestArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>



  export type ShopSelectScalar = {
    id?: boolean
    entityBaseId?: boolean
    laltitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
  }

  export type ShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityBaseId" | "laltitude" | "longitude" | "createdAt" | "updatedAt" | "byId", ExtArgs["result"]["shop"]>
  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
    cardAllocation?: boolean | Shop$cardAllocationArgs<ExtArgs>
    userShop?: boolean | Shop$userShopArgs<ExtArgs>
    customerAlias?: boolean | Shop$customerAliasArgs<ExtArgs>
    payment?: boolean | Shop$paymentArgs<ExtArgs>
    cardRequest?: boolean | Shop$cardRequestArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      entityBase: Prisma.$WalletBasePayload<ExtArgs>
      cardAllocation: Prisma.$CardAllocationPayload<ExtArgs>[]
      userShop: Prisma.$UserShopPayload<ExtArgs>[]
      customerAlias: Prisma.$CustomerAliasPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      cardRequest: Prisma.$CardRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityBaseId: number
      laltitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityBase<T extends WalletBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletBaseDefaultArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cardAllocation<T extends Shop$cardAllocationArgs<ExtArgs> = {}>(args?: Subset<T, Shop$cardAllocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userShop<T extends Shop$userShopArgs<ExtArgs> = {}>(args?: Subset<T, Shop$userShopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerAlias<T extends Shop$customerAliasArgs<ExtArgs> = {}>(args?: Subset<T, Shop$customerAliasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAliasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Shop$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Shop$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cardRequest<T extends Shop$cardRequestArgs<ExtArgs> = {}>(args?: Subset<T, Shop$cardRequestArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */ 
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'Int'>
    readonly entityBaseId: FieldRef<"Shop", 'Int'>
    readonly laltitude: FieldRef<"Shop", 'Decimal'>
    readonly longitude: FieldRef<"Shop", 'Decimal'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
    readonly byId: FieldRef<"Shop", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to delete.
     */
    limit?: number
  }

  /**
   * Shop.cardAllocation
   */
  export type Shop$cardAllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    where?: CardAllocationWhereInput
    orderBy?: CardAllocationOrderByWithRelationInput | CardAllocationOrderByWithRelationInput[]
    cursor?: CardAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardAllocationScalarFieldEnum | CardAllocationScalarFieldEnum[]
  }

  /**
   * Shop.userShop
   */
  export type Shop$userShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    where?: UserShopWhereInput
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    cursor?: UserShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserShopScalarFieldEnum | UserShopScalarFieldEnum[]
  }

  /**
   * Shop.customerAlias
   */
  export type Shop$customerAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAlias
     */
    select?: CustomerAliasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAlias
     */
    omit?: CustomerAliasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAliasInclude<ExtArgs> | null
    where?: CustomerAliasWhereInput
    orderBy?: CustomerAliasOrderByWithRelationInput | CustomerAliasOrderByWithRelationInput[]
    cursor?: CustomerAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAliasScalarFieldEnum | CustomerAliasScalarFieldEnum[]
  }

  /**
   * Shop.payment
   */
  export type Shop$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Shop.cardRequest
   */
  export type Shop$cardRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    where?: CardRequestWhereInput
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model UserShop
   */

  export type AggregateUserShop = {
    _count: UserShopCountAggregateOutputType | null
    _avg: UserShopAvgAggregateOutputType | null
    _sum: UserShopSumAggregateOutputType | null
    _min: UserShopMinAggregateOutputType | null
    _max: UserShopMaxAggregateOutputType | null
  }

  export type UserShopAvgAggregateOutputType = {
    shopId: number | null
    userId: number | null
  }

  export type UserShopSumAggregateOutputType = {
    shopId: number | null
    userId: number | null
  }

  export type UserShopMinAggregateOutputType = {
    shopId: number | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.UserShopRoleEnum | null
  }

  export type UserShopMaxAggregateOutputType = {
    shopId: number | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.UserShopRoleEnum | null
  }

  export type UserShopCountAggregateOutputType = {
    shopId: number
    userId: number
    isActive: number
    createdAt: number
    updatedAt: number
    role: number
    _all: number
  }


  export type UserShopAvgAggregateInputType = {
    shopId?: true
    userId?: true
  }

  export type UserShopSumAggregateInputType = {
    shopId?: true
    userId?: true
  }

  export type UserShopMinAggregateInputType = {
    shopId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserShopMaxAggregateInputType = {
    shopId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserShopCountAggregateInputType = {
    shopId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    _all?: true
  }

  export type UserShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserShop to aggregate.
     */
    where?: UserShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShops to fetch.
     */
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserShops
    **/
    _count?: true | UserShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserShopMaxAggregateInputType
  }

  export type GetUserShopAggregateType<T extends UserShopAggregateArgs> = {
        [P in keyof T & keyof AggregateUserShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserShop[P]>
      : GetScalarType<T[P], AggregateUserShop[P]>
  }




  export type UserShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserShopWhereInput
    orderBy?: UserShopOrderByWithAggregationInput | UserShopOrderByWithAggregationInput[]
    by: UserShopScalarFieldEnum[] | UserShopScalarFieldEnum
    having?: UserShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserShopCountAggregateInputType | true
    _avg?: UserShopAvgAggregateInputType
    _sum?: UserShopSumAggregateInputType
    _min?: UserShopMinAggregateInputType
    _max?: UserShopMaxAggregateInputType
  }

  export type UserShopGroupByOutputType = {
    shopId: number
    userId: number
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.UserShopRoleEnum
    _count: UserShopCountAggregateOutputType | null
    _avg: UserShopAvgAggregateOutputType | null
    _sum: UserShopSumAggregateOutputType | null
    _min: UserShopMinAggregateOutputType | null
    _max: UserShopMaxAggregateOutputType | null
  }

  type GetUserShopGroupByPayload<T extends UserShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserShopGroupByOutputType[P]>
            : GetScalarType<T[P], UserShopGroupByOutputType[P]>
        }
      >
    >


  export type UserShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userShop"]>



  export type UserShopSelectScalar = {
    shopId?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }

  export type UserShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "userId" | "isActive" | "createdAt" | "updatedAt" | "role", ExtArgs["result"]["userShop"]>
  export type UserShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserShop"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: number
      userId: number
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
      role: $Enums.UserShopRoleEnum
    }, ExtArgs["result"]["userShop"]>
    composites: {}
  }

  type UserShopGetPayload<S extends boolean | null | undefined | UserShopDefaultArgs> = $Result.GetResult<Prisma.$UserShopPayload, S>

  type UserShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserShopCountAggregateInputType | true
    }

  export interface UserShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserShop'], meta: { name: 'UserShop' } }
    /**
     * Find zero or one UserShop that matches the filter.
     * @param {UserShopFindUniqueArgs} args - Arguments to find a UserShop
     * @example
     * // Get one UserShop
     * const userShop = await prisma.userShop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserShopFindUniqueArgs>(args: SelectSubset<T, UserShopFindUniqueArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserShop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserShopFindUniqueOrThrowArgs} args - Arguments to find a UserShop
     * @example
     * // Get one UserShop
     * const userShop = await prisma.userShop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserShopFindUniqueOrThrowArgs>(args: SelectSubset<T, UserShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserShop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopFindFirstArgs} args - Arguments to find a UserShop
     * @example
     * // Get one UserShop
     * const userShop = await prisma.userShop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserShopFindFirstArgs>(args?: SelectSubset<T, UserShopFindFirstArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserShop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopFindFirstOrThrowArgs} args - Arguments to find a UserShop
     * @example
     * // Get one UserShop
     * const userShop = await prisma.userShop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserShopFindFirstOrThrowArgs>(args?: SelectSubset<T, UserShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserShops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserShops
     * const userShops = await prisma.userShop.findMany()
     * 
     * // Get first 10 UserShops
     * const userShops = await prisma.userShop.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const userShopWithShopIdOnly = await prisma.userShop.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends UserShopFindManyArgs>(args?: SelectSubset<T, UserShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserShop.
     * @param {UserShopCreateArgs} args - Arguments to create a UserShop.
     * @example
     * // Create one UserShop
     * const UserShop = await prisma.userShop.create({
     *   data: {
     *     // ... data to create a UserShop
     *   }
     * })
     * 
     */
    create<T extends UserShopCreateArgs>(args: SelectSubset<T, UserShopCreateArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserShops.
     * @param {UserShopCreateManyArgs} args - Arguments to create many UserShops.
     * @example
     * // Create many UserShops
     * const userShop = await prisma.userShop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserShopCreateManyArgs>(args?: SelectSubset<T, UserShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserShop.
     * @param {UserShopDeleteArgs} args - Arguments to delete one UserShop.
     * @example
     * // Delete one UserShop
     * const UserShop = await prisma.userShop.delete({
     *   where: {
     *     // ... filter to delete one UserShop
     *   }
     * })
     * 
     */
    delete<T extends UserShopDeleteArgs>(args: SelectSubset<T, UserShopDeleteArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserShop.
     * @param {UserShopUpdateArgs} args - Arguments to update one UserShop.
     * @example
     * // Update one UserShop
     * const userShop = await prisma.userShop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserShopUpdateArgs>(args: SelectSubset<T, UserShopUpdateArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserShops.
     * @param {UserShopDeleteManyArgs} args - Arguments to filter UserShops to delete.
     * @example
     * // Delete a few UserShops
     * const { count } = await prisma.userShop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserShopDeleteManyArgs>(args?: SelectSubset<T, UserShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserShops
     * const userShop = await prisma.userShop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserShopUpdateManyArgs>(args: SelectSubset<T, UserShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserShop.
     * @param {UserShopUpsertArgs} args - Arguments to update or create a UserShop.
     * @example
     * // Update or create a UserShop
     * const userShop = await prisma.userShop.upsert({
     *   create: {
     *     // ... data to create a UserShop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserShop we want to update
     *   }
     * })
     */
    upsert<T extends UserShopUpsertArgs>(args: SelectSubset<T, UserShopUpsertArgs<ExtArgs>>): Prisma__UserShopClient<$Result.GetResult<Prisma.$UserShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopCountArgs} args - Arguments to filter UserShops to count.
     * @example
     * // Count the number of UserShops
     * const count = await prisma.userShop.count({
     *   where: {
     *     // ... the filter for the UserShops we want to count
     *   }
     * })
    **/
    count<T extends UserShopCountArgs>(
      args?: Subset<T, UserShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserShopAggregateArgs>(args: Subset<T, UserShopAggregateArgs>): Prisma.PrismaPromise<GetUserShopAggregateType<T>>

    /**
     * Group by UserShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserShopGroupByArgs['orderBy'] }
        : { orderBy?: UserShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserShop model
   */
  readonly fields: UserShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserShop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserShop model
   */ 
  interface UserShopFieldRefs {
    readonly shopId: FieldRef<"UserShop", 'Int'>
    readonly userId: FieldRef<"UserShop", 'Int'>
    readonly isActive: FieldRef<"UserShop", 'Boolean'>
    readonly createdAt: FieldRef<"UserShop", 'DateTime'>
    readonly updatedAt: FieldRef<"UserShop", 'DateTime'>
    readonly role: FieldRef<"UserShop", 'UserShopRoleEnum'>
  }
    

  // Custom InputTypes
  /**
   * UserShop findUnique
   */
  export type UserShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter, which UserShop to fetch.
     */
    where: UserShopWhereUniqueInput
  }

  /**
   * UserShop findUniqueOrThrow
   */
  export type UserShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter, which UserShop to fetch.
     */
    where: UserShopWhereUniqueInput
  }

  /**
   * UserShop findFirst
   */
  export type UserShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter, which UserShop to fetch.
     */
    where?: UserShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShops to fetch.
     */
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserShops.
     */
    cursor?: UserShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserShops.
     */
    distinct?: UserShopScalarFieldEnum | UserShopScalarFieldEnum[]
  }

  /**
   * UserShop findFirstOrThrow
   */
  export type UserShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter, which UserShop to fetch.
     */
    where?: UserShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShops to fetch.
     */
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserShops.
     */
    cursor?: UserShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserShops.
     */
    distinct?: UserShopScalarFieldEnum | UserShopScalarFieldEnum[]
  }

  /**
   * UserShop findMany
   */
  export type UserShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter, which UserShops to fetch.
     */
    where?: UserShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShops to fetch.
     */
    orderBy?: UserShopOrderByWithRelationInput | UserShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserShops.
     */
    cursor?: UserShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShops.
     */
    skip?: number
    distinct?: UserShopScalarFieldEnum | UserShopScalarFieldEnum[]
  }

  /**
   * UserShop create
   */
  export type UserShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * The data needed to create a UserShop.
     */
    data: XOR<UserShopCreateInput, UserShopUncheckedCreateInput>
  }

  /**
   * UserShop createMany
   */
  export type UserShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserShops.
     */
    data: UserShopCreateManyInput | UserShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserShop update
   */
  export type UserShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * The data needed to update a UserShop.
     */
    data: XOR<UserShopUpdateInput, UserShopUncheckedUpdateInput>
    /**
     * Choose, which UserShop to update.
     */
    where: UserShopWhereUniqueInput
  }

  /**
   * UserShop updateMany
   */
  export type UserShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserShops.
     */
    data: XOR<UserShopUpdateManyMutationInput, UserShopUncheckedUpdateManyInput>
    /**
     * Filter which UserShops to update
     */
    where?: UserShopWhereInput
    /**
     * Limit how many UserShops to update.
     */
    limit?: number
  }

  /**
   * UserShop upsert
   */
  export type UserShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * The filter to search for the UserShop to update in case it exists.
     */
    where: UserShopWhereUniqueInput
    /**
     * In case the UserShop found by the `where` argument doesn't exist, create a new UserShop with this data.
     */
    create: XOR<UserShopCreateInput, UserShopUncheckedCreateInput>
    /**
     * In case the UserShop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserShopUpdateInput, UserShopUncheckedUpdateInput>
  }

  /**
   * UserShop delete
   */
  export type UserShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
    /**
     * Filter which UserShop to delete.
     */
    where: UserShopWhereUniqueInput
  }

  /**
   * UserShop deleteMany
   */
  export type UserShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserShops to delete
     */
    where?: UserShopWhereInput
    /**
     * Limit how many UserShops to delete.
     */
    limit?: number
  }

  /**
   * UserShop without action
   */
  export type UserShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserShop
     */
    select?: UserShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserShop
     */
    omit?: UserShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserShopInclude<ExtArgs> | null
  }


  /**
   * Model WalletBase
   */

  export type AggregateWalletBase = {
    _count: WalletBaseCountAggregateOutputType | null
    _avg: WalletBaseAvgAggregateOutputType | null
    _sum: WalletBaseSumAggregateOutputType | null
    _min: WalletBaseMinAggregateOutputType | null
    _max: WalletBaseMaxAggregateOutputType | null
  }

  export type WalletBaseAvgAggregateOutputType = {
    id: number | null
  }

  export type WalletBaseSumAggregateOutputType = {
    id: number | null
  }

  export type WalletBaseMinAggregateOutputType = {
    id: number | null
    type: $Enums.EntityEnum | null
    isActive: boolean | null
  }

  export type WalletBaseMaxAggregateOutputType = {
    id: number | null
    type: $Enums.EntityEnum | null
    isActive: boolean | null
  }

  export type WalletBaseCountAggregateOutputType = {
    id: number
    type: number
    isActive: number
    _all: number
  }


  export type WalletBaseAvgAggregateInputType = {
    id?: true
  }

  export type WalletBaseSumAggregateInputType = {
    id?: true
  }

  export type WalletBaseMinAggregateInputType = {
    id?: true
    type?: true
    isActive?: true
  }

  export type WalletBaseMaxAggregateInputType = {
    id?: true
    type?: true
    isActive?: true
  }

  export type WalletBaseCountAggregateInputType = {
    id?: true
    type?: true
    isActive?: true
    _all?: true
  }

  export type WalletBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletBase to aggregate.
     */
    where?: WalletBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletBases to fetch.
     */
    orderBy?: WalletBaseOrderByWithRelationInput | WalletBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletBases
    **/
    _count?: true | WalletBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletBaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletBaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletBaseMaxAggregateInputType
  }

  export type GetWalletBaseAggregateType<T extends WalletBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletBase[P]>
      : GetScalarType<T[P], AggregateWalletBase[P]>
  }




  export type WalletBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletBaseWhereInput
    orderBy?: WalletBaseOrderByWithAggregationInput | WalletBaseOrderByWithAggregationInput[]
    by: WalletBaseScalarFieldEnum[] | WalletBaseScalarFieldEnum
    having?: WalletBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletBaseCountAggregateInputType | true
    _avg?: WalletBaseAvgAggregateInputType
    _sum?: WalletBaseSumAggregateInputType
    _min?: WalletBaseMinAggregateInputType
    _max?: WalletBaseMaxAggregateInputType
  }

  export type WalletBaseGroupByOutputType = {
    id: number
    type: $Enums.EntityEnum
    isActive: boolean
    _count: WalletBaseCountAggregateOutputType | null
    _avg: WalletBaseAvgAggregateOutputType | null
    _sum: WalletBaseSumAggregateOutputType | null
    _min: WalletBaseMinAggregateOutputType | null
    _max: WalletBaseMaxAggregateOutputType | null
  }

  type GetWalletBaseGroupByPayload<T extends WalletBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletBaseGroupByOutputType[P]>
            : GetScalarType<T[P], WalletBaseGroupByOutputType[P]>
        }
      >
    >


  export type WalletBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    isActive?: boolean
    fromTransaction?: boolean | WalletBase$fromTransactionArgs<ExtArgs>
    toTransaction?: boolean | WalletBase$toTransactionArgs<ExtArgs>
    walletStatus?: boolean | WalletBase$walletStatusArgs<ExtArgs>
    shop?: boolean | WalletBase$shopArgs<ExtArgs>
    customer?: boolean | WalletBase$customerArgs<ExtArgs>
    _count?: boolean | WalletBaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletBase"]>



  export type WalletBaseSelectScalar = {
    id?: boolean
    type?: boolean
    isActive?: boolean
  }

  export type WalletBaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "isActive", ExtArgs["result"]["walletBase"]>
  export type WalletBaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromTransaction?: boolean | WalletBase$fromTransactionArgs<ExtArgs>
    toTransaction?: boolean | WalletBase$toTransactionArgs<ExtArgs>
    walletStatus?: boolean | WalletBase$walletStatusArgs<ExtArgs>
    shop?: boolean | WalletBase$shopArgs<ExtArgs>
    customer?: boolean | WalletBase$customerArgs<ExtArgs>
    _count?: boolean | WalletBaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WalletBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletBase"
    objects: {
      fromTransaction: Prisma.$TransactionPayload<ExtArgs>[]
      toTransaction: Prisma.$TransactionPayload<ExtArgs>[]
      walletStatus: Prisma.$WalletStatusPayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.EntityEnum
      isActive: boolean
    }, ExtArgs["result"]["walletBase"]>
    composites: {}
  }

  type WalletBaseGetPayload<S extends boolean | null | undefined | WalletBaseDefaultArgs> = $Result.GetResult<Prisma.$WalletBasePayload, S>

  type WalletBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletBaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletBaseCountAggregateInputType | true
    }

  export interface WalletBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletBase'], meta: { name: 'WalletBase' } }
    /**
     * Find zero or one WalletBase that matches the filter.
     * @param {WalletBaseFindUniqueArgs} args - Arguments to find a WalletBase
     * @example
     * // Get one WalletBase
     * const walletBase = await prisma.walletBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletBaseFindUniqueArgs>(args: SelectSubset<T, WalletBaseFindUniqueArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletBase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletBaseFindUniqueOrThrowArgs} args - Arguments to find a WalletBase
     * @example
     * // Get one WalletBase
     * const walletBase = await prisma.walletBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletBaseFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletBaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseFindFirstArgs} args - Arguments to find a WalletBase
     * @example
     * // Get one WalletBase
     * const walletBase = await prisma.walletBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletBaseFindFirstArgs>(args?: SelectSubset<T, WalletBaseFindFirstArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseFindFirstOrThrowArgs} args - Arguments to find a WalletBase
     * @example
     * // Get one WalletBase
     * const walletBase = await prisma.walletBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletBaseFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletBaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletBases
     * const walletBases = await prisma.walletBase.findMany()
     * 
     * // Get first 10 WalletBases
     * const walletBases = await prisma.walletBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletBaseWithIdOnly = await prisma.walletBase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletBaseFindManyArgs>(args?: SelectSubset<T, WalletBaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletBase.
     * @param {WalletBaseCreateArgs} args - Arguments to create a WalletBase.
     * @example
     * // Create one WalletBase
     * const WalletBase = await prisma.walletBase.create({
     *   data: {
     *     // ... data to create a WalletBase
     *   }
     * })
     * 
     */
    create<T extends WalletBaseCreateArgs>(args: SelectSubset<T, WalletBaseCreateArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletBases.
     * @param {WalletBaseCreateManyArgs} args - Arguments to create many WalletBases.
     * @example
     * // Create many WalletBases
     * const walletBase = await prisma.walletBase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletBaseCreateManyArgs>(args?: SelectSubset<T, WalletBaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WalletBase.
     * @param {WalletBaseDeleteArgs} args - Arguments to delete one WalletBase.
     * @example
     * // Delete one WalletBase
     * const WalletBase = await prisma.walletBase.delete({
     *   where: {
     *     // ... filter to delete one WalletBase
     *   }
     * })
     * 
     */
    delete<T extends WalletBaseDeleteArgs>(args: SelectSubset<T, WalletBaseDeleteArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletBase.
     * @param {WalletBaseUpdateArgs} args - Arguments to update one WalletBase.
     * @example
     * // Update one WalletBase
     * const walletBase = await prisma.walletBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletBaseUpdateArgs>(args: SelectSubset<T, WalletBaseUpdateArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletBases.
     * @param {WalletBaseDeleteManyArgs} args - Arguments to filter WalletBases to delete.
     * @example
     * // Delete a few WalletBases
     * const { count } = await prisma.walletBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletBaseDeleteManyArgs>(args?: SelectSubset<T, WalletBaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletBases
     * const walletBase = await prisma.walletBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletBaseUpdateManyArgs>(args: SelectSubset<T, WalletBaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletBase.
     * @param {WalletBaseUpsertArgs} args - Arguments to update or create a WalletBase.
     * @example
     * // Update or create a WalletBase
     * const walletBase = await prisma.walletBase.upsert({
     *   create: {
     *     // ... data to create a WalletBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletBase we want to update
     *   }
     * })
     */
    upsert<T extends WalletBaseUpsertArgs>(args: SelectSubset<T, WalletBaseUpsertArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseCountArgs} args - Arguments to filter WalletBases to count.
     * @example
     * // Count the number of WalletBases
     * const count = await prisma.walletBase.count({
     *   where: {
     *     // ... the filter for the WalletBases we want to count
     *   }
     * })
    **/
    count<T extends WalletBaseCountArgs>(
      args?: Subset<T, WalletBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletBaseAggregateArgs>(args: Subset<T, WalletBaseAggregateArgs>): Prisma.PrismaPromise<GetWalletBaseAggregateType<T>>

    /**
     * Group by WalletBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletBaseGroupByArgs['orderBy'] }
        : { orderBy?: WalletBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletBase model
   */
  readonly fields: WalletBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromTransaction<T extends WalletBase$fromTransactionArgs<ExtArgs> = {}>(args?: Subset<T, WalletBase$fromTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toTransaction<T extends WalletBase$toTransactionArgs<ExtArgs> = {}>(args?: Subset<T, WalletBase$toTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    walletStatus<T extends WalletBase$walletStatusArgs<ExtArgs> = {}>(args?: Subset<T, WalletBase$walletStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends WalletBase$shopArgs<ExtArgs> = {}>(args?: Subset<T, WalletBase$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends WalletBase$customerArgs<ExtArgs> = {}>(args?: Subset<T, WalletBase$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletBase model
   */ 
  interface WalletBaseFieldRefs {
    readonly id: FieldRef<"WalletBase", 'Int'>
    readonly type: FieldRef<"WalletBase", 'EntityEnum'>
    readonly isActive: FieldRef<"WalletBase", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WalletBase findUnique
   */
  export type WalletBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter, which WalletBase to fetch.
     */
    where: WalletBaseWhereUniqueInput
  }

  /**
   * WalletBase findUniqueOrThrow
   */
  export type WalletBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter, which WalletBase to fetch.
     */
    where: WalletBaseWhereUniqueInput
  }

  /**
   * WalletBase findFirst
   */
  export type WalletBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter, which WalletBase to fetch.
     */
    where?: WalletBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletBases to fetch.
     */
    orderBy?: WalletBaseOrderByWithRelationInput | WalletBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletBases.
     */
    cursor?: WalletBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletBases.
     */
    distinct?: WalletBaseScalarFieldEnum | WalletBaseScalarFieldEnum[]
  }

  /**
   * WalletBase findFirstOrThrow
   */
  export type WalletBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter, which WalletBase to fetch.
     */
    where?: WalletBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletBases to fetch.
     */
    orderBy?: WalletBaseOrderByWithRelationInput | WalletBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletBases.
     */
    cursor?: WalletBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletBases.
     */
    distinct?: WalletBaseScalarFieldEnum | WalletBaseScalarFieldEnum[]
  }

  /**
   * WalletBase findMany
   */
  export type WalletBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter, which WalletBases to fetch.
     */
    where?: WalletBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletBases to fetch.
     */
    orderBy?: WalletBaseOrderByWithRelationInput | WalletBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletBases.
     */
    cursor?: WalletBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletBases.
     */
    skip?: number
    distinct?: WalletBaseScalarFieldEnum | WalletBaseScalarFieldEnum[]
  }

  /**
   * WalletBase create
   */
  export type WalletBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletBase.
     */
    data: XOR<WalletBaseCreateInput, WalletBaseUncheckedCreateInput>
  }

  /**
   * WalletBase createMany
   */
  export type WalletBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletBases.
     */
    data: WalletBaseCreateManyInput | WalletBaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletBase update
   */
  export type WalletBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletBase.
     */
    data: XOR<WalletBaseUpdateInput, WalletBaseUncheckedUpdateInput>
    /**
     * Choose, which WalletBase to update.
     */
    where: WalletBaseWhereUniqueInput
  }

  /**
   * WalletBase updateMany
   */
  export type WalletBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletBases.
     */
    data: XOR<WalletBaseUpdateManyMutationInput, WalletBaseUncheckedUpdateManyInput>
    /**
     * Filter which WalletBases to update
     */
    where?: WalletBaseWhereInput
    /**
     * Limit how many WalletBases to update.
     */
    limit?: number
  }

  /**
   * WalletBase upsert
   */
  export type WalletBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletBase to update in case it exists.
     */
    where: WalletBaseWhereUniqueInput
    /**
     * In case the WalletBase found by the `where` argument doesn't exist, create a new WalletBase with this data.
     */
    create: XOR<WalletBaseCreateInput, WalletBaseUncheckedCreateInput>
    /**
     * In case the WalletBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletBaseUpdateInput, WalletBaseUncheckedUpdateInput>
  }

  /**
   * WalletBase delete
   */
  export type WalletBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
    /**
     * Filter which WalletBase to delete.
     */
    where: WalletBaseWhereUniqueInput
  }

  /**
   * WalletBase deleteMany
   */
  export type WalletBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletBases to delete
     */
    where?: WalletBaseWhereInput
    /**
     * Limit how many WalletBases to delete.
     */
    limit?: number
  }

  /**
   * WalletBase.fromTransaction
   */
  export type WalletBase$fromTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * WalletBase.toTransaction
   */
  export type WalletBase$toTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * WalletBase.walletStatus
   */
  export type WalletBase$walletStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    where?: WalletStatusWhereInput
    orderBy?: WalletStatusOrderByWithRelationInput | WalletStatusOrderByWithRelationInput[]
    cursor?: WalletStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletStatusScalarFieldEnum | WalletStatusScalarFieldEnum[]
  }

  /**
   * WalletBase.shop
   */
  export type WalletBase$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * WalletBase.customer
   */
  export type WalletBase$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * WalletBase without action
   */
  export type WalletBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletBase
     */
    select?: WalletBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletBase
     */
    omit?: WalletBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletBaseInclude<ExtArgs> | null
  }


  /**
   * Model WalletStatus
   */

  export type AggregateWalletStatus = {
    _count: WalletStatusCountAggregateOutputType | null
    _avg: WalletStatusAvgAggregateOutputType | null
    _sum: WalletStatusSumAggregateOutputType | null
    _min: WalletStatusMinAggregateOutputType | null
    _max: WalletStatusMaxAggregateOutputType | null
  }

  export type WalletStatusAvgAggregateOutputType = {
    id: number | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    walletBaseId: number | null
  }

  export type WalletStatusSumAggregateOutputType = {
    id: number | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    walletBaseId: number | null
  }

  export type WalletStatusMinAggregateOutputType = {
    id: number | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    walletBaseId: number | null
    createdAt: Date | null
  }

  export type WalletStatusMaxAggregateOutputType = {
    id: number | null
    totalDebit: Decimal | null
    totalCredit: Decimal | null
    walletBaseId: number | null
    createdAt: Date | null
  }

  export type WalletStatusCountAggregateOutputType = {
    id: number
    totalDebit: number
    totalCredit: number
    walletBaseId: number
    createdAt: number
    _all: number
  }


  export type WalletStatusAvgAggregateInputType = {
    id?: true
    totalDebit?: true
    totalCredit?: true
    walletBaseId?: true
  }

  export type WalletStatusSumAggregateInputType = {
    id?: true
    totalDebit?: true
    totalCredit?: true
    walletBaseId?: true
  }

  export type WalletStatusMinAggregateInputType = {
    id?: true
    totalDebit?: true
    totalCredit?: true
    walletBaseId?: true
    createdAt?: true
  }

  export type WalletStatusMaxAggregateInputType = {
    id?: true
    totalDebit?: true
    totalCredit?: true
    walletBaseId?: true
    createdAt?: true
  }

  export type WalletStatusCountAggregateInputType = {
    id?: true
    totalDebit?: true
    totalCredit?: true
    walletBaseId?: true
    createdAt?: true
    _all?: true
  }

  export type WalletStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletStatus to aggregate.
     */
    where?: WalletStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletStatuses to fetch.
     */
    orderBy?: WalletStatusOrderByWithRelationInput | WalletStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletStatuses
    **/
    _count?: true | WalletStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletStatusMaxAggregateInputType
  }

  export type GetWalletStatusAggregateType<T extends WalletStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletStatus[P]>
      : GetScalarType<T[P], AggregateWalletStatus[P]>
  }




  export type WalletStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletStatusWhereInput
    orderBy?: WalletStatusOrderByWithAggregationInput | WalletStatusOrderByWithAggregationInput[]
    by: WalletStatusScalarFieldEnum[] | WalletStatusScalarFieldEnum
    having?: WalletStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletStatusCountAggregateInputType | true
    _avg?: WalletStatusAvgAggregateInputType
    _sum?: WalletStatusSumAggregateInputType
    _min?: WalletStatusMinAggregateInputType
    _max?: WalletStatusMaxAggregateInputType
  }

  export type WalletStatusGroupByOutputType = {
    id: number
    totalDebit: Decimal
    totalCredit: Decimal
    walletBaseId: number
    createdAt: Date | null
    _count: WalletStatusCountAggregateOutputType | null
    _avg: WalletStatusAvgAggregateOutputType | null
    _sum: WalletStatusSumAggregateOutputType | null
    _min: WalletStatusMinAggregateOutputType | null
    _max: WalletStatusMaxAggregateOutputType | null
  }

  type GetWalletStatusGroupByPayload<T extends WalletStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletStatusGroupByOutputType[P]>
            : GetScalarType<T[P], WalletStatusGroupByOutputType[P]>
        }
      >
    >


  export type WalletStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalDebit?: boolean
    totalCredit?: boolean
    walletBaseId?: boolean
    createdAt?: boolean
    walletBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletStatus"]>



  export type WalletStatusSelectScalar = {
    id?: boolean
    totalDebit?: boolean
    totalCredit?: boolean
    walletBaseId?: boolean
    createdAt?: boolean
  }

  export type WalletStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalDebit" | "totalCredit" | "walletBaseId" | "createdAt", ExtArgs["result"]["walletStatus"]>
  export type WalletStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    walletBase?: boolean | WalletBaseDefaultArgs<ExtArgs>
  }

  export type $WalletStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletStatus"
    objects: {
      walletBase: Prisma.$WalletBasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalDebit: Prisma.Decimal
      totalCredit: Prisma.Decimal
      walletBaseId: number
      createdAt: Date | null
    }, ExtArgs["result"]["walletStatus"]>
    composites: {}
  }

  type WalletStatusGetPayload<S extends boolean | null | undefined | WalletStatusDefaultArgs> = $Result.GetResult<Prisma.$WalletStatusPayload, S>

  type WalletStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletStatusCountAggregateInputType | true
    }

  export interface WalletStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletStatus'], meta: { name: 'WalletStatus' } }
    /**
     * Find zero or one WalletStatus that matches the filter.
     * @param {WalletStatusFindUniqueArgs} args - Arguments to find a WalletStatus
     * @example
     * // Get one WalletStatus
     * const walletStatus = await prisma.walletStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletStatusFindUniqueArgs>(args: SelectSubset<T, WalletStatusFindUniqueArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletStatusFindUniqueOrThrowArgs} args - Arguments to find a WalletStatus
     * @example
     * // Get one WalletStatus
     * const walletStatus = await prisma.walletStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusFindFirstArgs} args - Arguments to find a WalletStatus
     * @example
     * // Get one WalletStatus
     * const walletStatus = await prisma.walletStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletStatusFindFirstArgs>(args?: SelectSubset<T, WalletStatusFindFirstArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusFindFirstOrThrowArgs} args - Arguments to find a WalletStatus
     * @example
     * // Get one WalletStatus
     * const walletStatus = await prisma.walletStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletStatuses
     * const walletStatuses = await prisma.walletStatus.findMany()
     * 
     * // Get first 10 WalletStatuses
     * const walletStatuses = await prisma.walletStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletStatusWithIdOnly = await prisma.walletStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletStatusFindManyArgs>(args?: SelectSubset<T, WalletStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletStatus.
     * @param {WalletStatusCreateArgs} args - Arguments to create a WalletStatus.
     * @example
     * // Create one WalletStatus
     * const WalletStatus = await prisma.walletStatus.create({
     *   data: {
     *     // ... data to create a WalletStatus
     *   }
     * })
     * 
     */
    create<T extends WalletStatusCreateArgs>(args: SelectSubset<T, WalletStatusCreateArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletStatuses.
     * @param {WalletStatusCreateManyArgs} args - Arguments to create many WalletStatuses.
     * @example
     * // Create many WalletStatuses
     * const walletStatus = await prisma.walletStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletStatusCreateManyArgs>(args?: SelectSubset<T, WalletStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WalletStatus.
     * @param {WalletStatusDeleteArgs} args - Arguments to delete one WalletStatus.
     * @example
     * // Delete one WalletStatus
     * const WalletStatus = await prisma.walletStatus.delete({
     *   where: {
     *     // ... filter to delete one WalletStatus
     *   }
     * })
     * 
     */
    delete<T extends WalletStatusDeleteArgs>(args: SelectSubset<T, WalletStatusDeleteArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletStatus.
     * @param {WalletStatusUpdateArgs} args - Arguments to update one WalletStatus.
     * @example
     * // Update one WalletStatus
     * const walletStatus = await prisma.walletStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletStatusUpdateArgs>(args: SelectSubset<T, WalletStatusUpdateArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletStatuses.
     * @param {WalletStatusDeleteManyArgs} args - Arguments to filter WalletStatuses to delete.
     * @example
     * // Delete a few WalletStatuses
     * const { count } = await prisma.walletStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletStatusDeleteManyArgs>(args?: SelectSubset<T, WalletStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletStatuses
     * const walletStatus = await prisma.walletStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletStatusUpdateManyArgs>(args: SelectSubset<T, WalletStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletStatus.
     * @param {WalletStatusUpsertArgs} args - Arguments to update or create a WalletStatus.
     * @example
     * // Update or create a WalletStatus
     * const walletStatus = await prisma.walletStatus.upsert({
     *   create: {
     *     // ... data to create a WalletStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletStatus we want to update
     *   }
     * })
     */
    upsert<T extends WalletStatusUpsertArgs>(args: SelectSubset<T, WalletStatusUpsertArgs<ExtArgs>>): Prisma__WalletStatusClient<$Result.GetResult<Prisma.$WalletStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusCountArgs} args - Arguments to filter WalletStatuses to count.
     * @example
     * // Count the number of WalletStatuses
     * const count = await prisma.walletStatus.count({
     *   where: {
     *     // ... the filter for the WalletStatuses we want to count
     *   }
     * })
    **/
    count<T extends WalletStatusCountArgs>(
      args?: Subset<T, WalletStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletStatusAggregateArgs>(args: Subset<T, WalletStatusAggregateArgs>): Prisma.PrismaPromise<GetWalletStatusAggregateType<T>>

    /**
     * Group by WalletStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletStatusGroupByArgs['orderBy'] }
        : { orderBy?: WalletStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletStatus model
   */
  readonly fields: WalletStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    walletBase<T extends WalletBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletBaseDefaultArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletStatus model
   */ 
  interface WalletStatusFieldRefs {
    readonly id: FieldRef<"WalletStatus", 'Int'>
    readonly totalDebit: FieldRef<"WalletStatus", 'Decimal'>
    readonly totalCredit: FieldRef<"WalletStatus", 'Decimal'>
    readonly walletBaseId: FieldRef<"WalletStatus", 'Int'>
    readonly createdAt: FieldRef<"WalletStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletStatus findUnique
   */
  export type WalletStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter, which WalletStatus to fetch.
     */
    where: WalletStatusWhereUniqueInput
  }

  /**
   * WalletStatus findUniqueOrThrow
   */
  export type WalletStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter, which WalletStatus to fetch.
     */
    where: WalletStatusWhereUniqueInput
  }

  /**
   * WalletStatus findFirst
   */
  export type WalletStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter, which WalletStatus to fetch.
     */
    where?: WalletStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletStatuses to fetch.
     */
    orderBy?: WalletStatusOrderByWithRelationInput | WalletStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletStatuses.
     */
    cursor?: WalletStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletStatuses.
     */
    distinct?: WalletStatusScalarFieldEnum | WalletStatusScalarFieldEnum[]
  }

  /**
   * WalletStatus findFirstOrThrow
   */
  export type WalletStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter, which WalletStatus to fetch.
     */
    where?: WalletStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletStatuses to fetch.
     */
    orderBy?: WalletStatusOrderByWithRelationInput | WalletStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletStatuses.
     */
    cursor?: WalletStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletStatuses.
     */
    distinct?: WalletStatusScalarFieldEnum | WalletStatusScalarFieldEnum[]
  }

  /**
   * WalletStatus findMany
   */
  export type WalletStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter, which WalletStatuses to fetch.
     */
    where?: WalletStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletStatuses to fetch.
     */
    orderBy?: WalletStatusOrderByWithRelationInput | WalletStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletStatuses.
     */
    cursor?: WalletStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletStatuses.
     */
    skip?: number
    distinct?: WalletStatusScalarFieldEnum | WalletStatusScalarFieldEnum[]
  }

  /**
   * WalletStatus create
   */
  export type WalletStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletStatus.
     */
    data: XOR<WalletStatusCreateInput, WalletStatusUncheckedCreateInput>
  }

  /**
   * WalletStatus createMany
   */
  export type WalletStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletStatuses.
     */
    data: WalletStatusCreateManyInput | WalletStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletStatus update
   */
  export type WalletStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletStatus.
     */
    data: XOR<WalletStatusUpdateInput, WalletStatusUncheckedUpdateInput>
    /**
     * Choose, which WalletStatus to update.
     */
    where: WalletStatusWhereUniqueInput
  }

  /**
   * WalletStatus updateMany
   */
  export type WalletStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletStatuses.
     */
    data: XOR<WalletStatusUpdateManyMutationInput, WalletStatusUncheckedUpdateManyInput>
    /**
     * Filter which WalletStatuses to update
     */
    where?: WalletStatusWhereInput
    /**
     * Limit how many WalletStatuses to update.
     */
    limit?: number
  }

  /**
   * WalletStatus upsert
   */
  export type WalletStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletStatus to update in case it exists.
     */
    where: WalletStatusWhereUniqueInput
    /**
     * In case the WalletStatus found by the `where` argument doesn't exist, create a new WalletStatus with this data.
     */
    create: XOR<WalletStatusCreateInput, WalletStatusUncheckedCreateInput>
    /**
     * In case the WalletStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletStatusUpdateInput, WalletStatusUncheckedUpdateInput>
  }

  /**
   * WalletStatus delete
   */
  export type WalletStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
    /**
     * Filter which WalletStatus to delete.
     */
    where: WalletStatusWhereUniqueInput
  }

  /**
   * WalletStatus deleteMany
   */
  export type WalletStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletStatuses to delete
     */
    where?: WalletStatusWhereInput
    /**
     * Limit how many WalletStatuses to delete.
     */
    limit?: number
  }

  /**
   * WalletStatus without action
   */
  export type WalletStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletStatus
     */
    select?: WalletStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletStatus
     */
    omit?: WalletStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletStatusInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    amount: Decimal | null
    walletBaseId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    amount: Decimal | null
    walletBaseId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    walletBaseId: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    walletBaseId: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    fromId: number
    toId: number
    amount: number
    createdAt: number
    updatedAt: number
    walletBaseId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    amount?: true
    walletBaseId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    amount?: true
    walletBaseId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    walletBaseId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    walletBaseId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    walletBaseId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    fromId: number
    toId: number
    amount: Decimal
    createdAt: Date | null
    updatedAt: Date | null
    walletBaseId: number | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromId?: boolean
    toId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletBaseId?: boolean
    from?: boolean | WalletBaseDefaultArgs<ExtArgs>
    to?: boolean | WalletBaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    fromId?: boolean
    toId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletBaseId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromId" | "toId" | "amount" | "createdAt" | "updatedAt" | "walletBaseId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    from?: boolean | WalletBaseDefaultArgs<ExtArgs>
    to?: boolean | WalletBaseDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      from: Prisma.$WalletBasePayload<ExtArgs>
      to: Prisma.$WalletBasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromId: number
      toId: number
      amount: Prisma.Decimal
      createdAt: Date | null
      updatedAt: Date | null
      walletBaseId: number | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    from<T extends WalletBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletBaseDefaultArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    to<T extends WalletBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletBaseDefaultArgs<ExtArgs>>): Prisma__WalletBaseClient<$Result.GetResult<Prisma.$WalletBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly fromId: FieldRef<"Transaction", 'Int'>
    readonly toId: FieldRef<"Transaction", 'Int'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly walletBaseId: FieldRef<"Transaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    byId: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    byId: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    serial: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    serial: number
    isActive: number
    createdAt: number
    updatedAt: number
    byId: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    byId?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    byId?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    serial?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    serial?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    serial?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: number
    serial: string
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    assignment?: boolean | Card$assignmentArgs<ExtArgs>
    cardAllocationDetail?: boolean | Card$cardAllocationDetailArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>



  export type CardSelectScalar = {
    id?: boolean
    serial?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
  }

  export type CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serial" | "isActive" | "createdAt" | "updatedAt" | "byId", ExtArgs["result"]["card"]>
  export type CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | Card$assignmentArgs<ExtArgs>
    cardAllocationDetail?: boolean | Card$cardAllocationDetailArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>[]
      cardAllocationDetail: Prisma.$CardAllocationDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends Card$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, Card$assignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cardAllocationDetail<T extends Card$cardAllocationDetailArgs<ExtArgs> = {}>(args?: Subset<T, Card$cardAllocationDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */ 
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'Int'>
    readonly serial: FieldRef<"Card", 'String'>
    readonly isActive: FieldRef<"Card", 'Boolean'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly updatedAt: FieldRef<"Card", 'DateTime'>
    readonly byId: FieldRef<"Card", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Card.assignment
   */
  export type Card$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Card.cardAllocationDetail
   */
  export type Card$cardAllocationDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    where?: CardAllocationDetailWhereInput
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    cursor?: CardAllocationDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardAllocationDetailScalarFieldEnum | CardAllocationDetailScalarFieldEnum[]
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
  }


  /**
   * Model CardAllocation
   */

  export type AggregateCardAllocation = {
    _count: CardAllocationCountAggregateOutputType | null
    _avg: CardAllocationAvgAggregateOutputType | null
    _sum: CardAllocationSumAggregateOutputType | null
    _min: CardAllocationMinAggregateOutputType | null
    _max: CardAllocationMaxAggregateOutputType | null
  }

  export type CardAllocationAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    byId: number | null
  }

  export type CardAllocationSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    byId: number | null
  }

  export type CardAllocationMinAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number | null
    byId: number | null
  }

  export type CardAllocationMaxAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number | null
    byId: number | null
  }

  export type CardAllocationCountAggregateOutputType = {
    id: number
    isActive: number
    createdAt: number
    updatedAt: number
    shopId: number
    byId: number
    _all: number
  }


  export type CardAllocationAvgAggregateInputType = {
    id?: true
    shopId?: true
    byId?: true
  }

  export type CardAllocationSumAggregateInputType = {
    id?: true
    shopId?: true
    byId?: true
  }

  export type CardAllocationMinAggregateInputType = {
    id?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    byId?: true
  }

  export type CardAllocationMaxAggregateInputType = {
    id?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    byId?: true
  }

  export type CardAllocationCountAggregateInputType = {
    id?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    byId?: true
    _all?: true
  }

  export type CardAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAllocation to aggregate.
     */
    where?: CardAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocations to fetch.
     */
    orderBy?: CardAllocationOrderByWithRelationInput | CardAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardAllocations
    **/
    _count?: true | CardAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardAllocationMaxAggregateInputType
  }

  export type GetCardAllocationAggregateType<T extends CardAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateCardAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardAllocation[P]>
      : GetScalarType<T[P], AggregateCardAllocation[P]>
  }




  export type CardAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAllocationWhereInput
    orderBy?: CardAllocationOrderByWithAggregationInput | CardAllocationOrderByWithAggregationInput[]
    by: CardAllocationScalarFieldEnum[] | CardAllocationScalarFieldEnum
    having?: CardAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardAllocationCountAggregateInputType | true
    _avg?: CardAllocationAvgAggregateInputType
    _sum?: CardAllocationSumAggregateInputType
    _min?: CardAllocationMinAggregateInputType
    _max?: CardAllocationMaxAggregateInputType
  }

  export type CardAllocationGroupByOutputType = {
    id: number
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number
    byId: number | null
    _count: CardAllocationCountAggregateOutputType | null
    _avg: CardAllocationAvgAggregateOutputType | null
    _sum: CardAllocationSumAggregateOutputType | null
    _min: CardAllocationMinAggregateOutputType | null
    _max: CardAllocationMaxAggregateOutputType | null
  }

  type GetCardAllocationGroupByPayload<T extends CardAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], CardAllocationGroupByOutputType[P]>
        }
      >
    >


  export type CardAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    byId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    cardAllocationDetail?: boolean | CardAllocation$cardAllocationDetailArgs<ExtArgs>
    _count?: boolean | CardAllocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardAllocation"]>



  export type CardAllocationSelectScalar = {
    id?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    byId?: boolean
  }

  export type CardAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isActive" | "createdAt" | "updatedAt" | "shopId" | "byId", ExtArgs["result"]["cardAllocation"]>
  export type CardAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    cardAllocationDetail?: boolean | CardAllocation$cardAllocationDetailArgs<ExtArgs>
    _count?: boolean | CardAllocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CardAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardAllocation"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      cardAllocationDetail: Prisma.$CardAllocationDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
      shopId: number
      byId: number | null
    }, ExtArgs["result"]["cardAllocation"]>
    composites: {}
  }

  type CardAllocationGetPayload<S extends boolean | null | undefined | CardAllocationDefaultArgs> = $Result.GetResult<Prisma.$CardAllocationPayload, S>

  type CardAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardAllocationCountAggregateInputType | true
    }

  export interface CardAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardAllocation'], meta: { name: 'CardAllocation' } }
    /**
     * Find zero or one CardAllocation that matches the filter.
     * @param {CardAllocationFindUniqueArgs} args - Arguments to find a CardAllocation
     * @example
     * // Get one CardAllocation
     * const cardAllocation = await prisma.cardAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardAllocationFindUniqueArgs>(args: SelectSubset<T, CardAllocationFindUniqueArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardAllocationFindUniqueOrThrowArgs} args - Arguments to find a CardAllocation
     * @example
     * // Get one CardAllocation
     * const cardAllocation = await prisma.cardAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, CardAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationFindFirstArgs} args - Arguments to find a CardAllocation
     * @example
     * // Get one CardAllocation
     * const cardAllocation = await prisma.cardAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardAllocationFindFirstArgs>(args?: SelectSubset<T, CardAllocationFindFirstArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationFindFirstOrThrowArgs} args - Arguments to find a CardAllocation
     * @example
     * // Get one CardAllocation
     * const cardAllocation = await prisma.cardAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, CardAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardAllocations
     * const cardAllocations = await prisma.cardAllocation.findMany()
     * 
     * // Get first 10 CardAllocations
     * const cardAllocations = await prisma.cardAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardAllocationWithIdOnly = await prisma.cardAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardAllocationFindManyArgs>(args?: SelectSubset<T, CardAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardAllocation.
     * @param {CardAllocationCreateArgs} args - Arguments to create a CardAllocation.
     * @example
     * // Create one CardAllocation
     * const CardAllocation = await prisma.cardAllocation.create({
     *   data: {
     *     // ... data to create a CardAllocation
     *   }
     * })
     * 
     */
    create<T extends CardAllocationCreateArgs>(args: SelectSubset<T, CardAllocationCreateArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardAllocations.
     * @param {CardAllocationCreateManyArgs} args - Arguments to create many CardAllocations.
     * @example
     * // Create many CardAllocations
     * const cardAllocation = await prisma.cardAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardAllocationCreateManyArgs>(args?: SelectSubset<T, CardAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CardAllocation.
     * @param {CardAllocationDeleteArgs} args - Arguments to delete one CardAllocation.
     * @example
     * // Delete one CardAllocation
     * const CardAllocation = await prisma.cardAllocation.delete({
     *   where: {
     *     // ... filter to delete one CardAllocation
     *   }
     * })
     * 
     */
    delete<T extends CardAllocationDeleteArgs>(args: SelectSubset<T, CardAllocationDeleteArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardAllocation.
     * @param {CardAllocationUpdateArgs} args - Arguments to update one CardAllocation.
     * @example
     * // Update one CardAllocation
     * const cardAllocation = await prisma.cardAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardAllocationUpdateArgs>(args: SelectSubset<T, CardAllocationUpdateArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardAllocations.
     * @param {CardAllocationDeleteManyArgs} args - Arguments to filter CardAllocations to delete.
     * @example
     * // Delete a few CardAllocations
     * const { count } = await prisma.cardAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardAllocationDeleteManyArgs>(args?: SelectSubset<T, CardAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardAllocations
     * const cardAllocation = await prisma.cardAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardAllocationUpdateManyArgs>(args: SelectSubset<T, CardAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardAllocation.
     * @param {CardAllocationUpsertArgs} args - Arguments to update or create a CardAllocation.
     * @example
     * // Update or create a CardAllocation
     * const cardAllocation = await prisma.cardAllocation.upsert({
     *   create: {
     *     // ... data to create a CardAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardAllocation we want to update
     *   }
     * })
     */
    upsert<T extends CardAllocationUpsertArgs>(args: SelectSubset<T, CardAllocationUpsertArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationCountArgs} args - Arguments to filter CardAllocations to count.
     * @example
     * // Count the number of CardAllocations
     * const count = await prisma.cardAllocation.count({
     *   where: {
     *     // ... the filter for the CardAllocations we want to count
     *   }
     * })
    **/
    count<T extends CardAllocationCountArgs>(
      args?: Subset<T, CardAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAllocationAggregateArgs>(args: Subset<T, CardAllocationAggregateArgs>): Prisma.PrismaPromise<GetCardAllocationAggregateType<T>>

    /**
     * Group by CardAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardAllocationGroupByArgs['orderBy'] }
        : { orderBy?: CardAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardAllocation model
   */
  readonly fields: CardAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cardAllocationDetail<T extends CardAllocation$cardAllocationDetailArgs<ExtArgs> = {}>(args?: Subset<T, CardAllocation$cardAllocationDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardAllocation model
   */ 
  interface CardAllocationFieldRefs {
    readonly id: FieldRef<"CardAllocation", 'Int'>
    readonly isActive: FieldRef<"CardAllocation", 'Boolean'>
    readonly createdAt: FieldRef<"CardAllocation", 'DateTime'>
    readonly updatedAt: FieldRef<"CardAllocation", 'DateTime'>
    readonly shopId: FieldRef<"CardAllocation", 'Int'>
    readonly byId: FieldRef<"CardAllocation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CardAllocation findUnique
   */
  export type CardAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocation to fetch.
     */
    where: CardAllocationWhereUniqueInput
  }

  /**
   * CardAllocation findUniqueOrThrow
   */
  export type CardAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocation to fetch.
     */
    where: CardAllocationWhereUniqueInput
  }

  /**
   * CardAllocation findFirst
   */
  export type CardAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocation to fetch.
     */
    where?: CardAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocations to fetch.
     */
    orderBy?: CardAllocationOrderByWithRelationInput | CardAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAllocations.
     */
    cursor?: CardAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAllocations.
     */
    distinct?: CardAllocationScalarFieldEnum | CardAllocationScalarFieldEnum[]
  }

  /**
   * CardAllocation findFirstOrThrow
   */
  export type CardAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocation to fetch.
     */
    where?: CardAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocations to fetch.
     */
    orderBy?: CardAllocationOrderByWithRelationInput | CardAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAllocations.
     */
    cursor?: CardAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAllocations.
     */
    distinct?: CardAllocationScalarFieldEnum | CardAllocationScalarFieldEnum[]
  }

  /**
   * CardAllocation findMany
   */
  export type CardAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocations to fetch.
     */
    where?: CardAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocations to fetch.
     */
    orderBy?: CardAllocationOrderByWithRelationInput | CardAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardAllocations.
     */
    cursor?: CardAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocations.
     */
    skip?: number
    distinct?: CardAllocationScalarFieldEnum | CardAllocationScalarFieldEnum[]
  }

  /**
   * CardAllocation create
   */
  export type CardAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a CardAllocation.
     */
    data: XOR<CardAllocationCreateInput, CardAllocationUncheckedCreateInput>
  }

  /**
   * CardAllocation createMany
   */
  export type CardAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardAllocations.
     */
    data: CardAllocationCreateManyInput | CardAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardAllocation update
   */
  export type CardAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a CardAllocation.
     */
    data: XOR<CardAllocationUpdateInput, CardAllocationUncheckedUpdateInput>
    /**
     * Choose, which CardAllocation to update.
     */
    where: CardAllocationWhereUniqueInput
  }

  /**
   * CardAllocation updateMany
   */
  export type CardAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardAllocations.
     */
    data: XOR<CardAllocationUpdateManyMutationInput, CardAllocationUncheckedUpdateManyInput>
    /**
     * Filter which CardAllocations to update
     */
    where?: CardAllocationWhereInput
    /**
     * Limit how many CardAllocations to update.
     */
    limit?: number
  }

  /**
   * CardAllocation upsert
   */
  export type CardAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the CardAllocation to update in case it exists.
     */
    where: CardAllocationWhereUniqueInput
    /**
     * In case the CardAllocation found by the `where` argument doesn't exist, create a new CardAllocation with this data.
     */
    create: XOR<CardAllocationCreateInput, CardAllocationUncheckedCreateInput>
    /**
     * In case the CardAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardAllocationUpdateInput, CardAllocationUncheckedUpdateInput>
  }

  /**
   * CardAllocation delete
   */
  export type CardAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
    /**
     * Filter which CardAllocation to delete.
     */
    where: CardAllocationWhereUniqueInput
  }

  /**
   * CardAllocation deleteMany
   */
  export type CardAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAllocations to delete
     */
    where?: CardAllocationWhereInput
    /**
     * Limit how many CardAllocations to delete.
     */
    limit?: number
  }

  /**
   * CardAllocation.cardAllocationDetail
   */
  export type CardAllocation$cardAllocationDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    where?: CardAllocationDetailWhereInput
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    cursor?: CardAllocationDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardAllocationDetailScalarFieldEnum | CardAllocationDetailScalarFieldEnum[]
  }

  /**
   * CardAllocation without action
   */
  export type CardAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocation
     */
    select?: CardAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocation
     */
    omit?: CardAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationInclude<ExtArgs> | null
  }


  /**
   * Model CardRequest
   */

  export type AggregateCardRequest = {
    _count: CardRequestCountAggregateOutputType | null
    _avg: CardRequestAvgAggregateOutputType | null
    _sum: CardRequestSumAggregateOutputType | null
    _min: CardRequestMinAggregateOutputType | null
    _max: CardRequestMaxAggregateOutputType | null
  }

  export type CardRequestAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    quantity: number | null
    shopId1: number | null
    byId: number | null
  }

  export type CardRequestSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    quantity: number | null
    shopId1: number | null
    byId: number | null
  }

  export type CardRequestMinAggregateOutputType = {
    id: number | null
    label: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number | null
    quantity: number | null
    status: $Enums.CardRequestEnum | null
    shopId1: number | null
    byId: number | null
  }

  export type CardRequestMaxAggregateOutputType = {
    id: number | null
    label: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number | null
    quantity: number | null
    status: $Enums.CardRequestEnum | null
    shopId1: number | null
    byId: number | null
  }

  export type CardRequestCountAggregateOutputType = {
    id: number
    label: number
    isActive: number
    createdAt: number
    updatedAt: number
    shopId: number
    quantity: number
    status: number
    shopId1: number
    byId: number
    _all: number
  }


  export type CardRequestAvgAggregateInputType = {
    id?: true
    shopId?: true
    quantity?: true
    shopId1?: true
    byId?: true
  }

  export type CardRequestSumAggregateInputType = {
    id?: true
    shopId?: true
    quantity?: true
    shopId1?: true
    byId?: true
  }

  export type CardRequestMinAggregateInputType = {
    id?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    quantity?: true
    status?: true
    shopId1?: true
    byId?: true
  }

  export type CardRequestMaxAggregateInputType = {
    id?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    quantity?: true
    status?: true
    shopId1?: true
    byId?: true
  }

  export type CardRequestCountAggregateInputType = {
    id?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    shopId?: true
    quantity?: true
    status?: true
    shopId1?: true
    byId?: true
    _all?: true
  }

  export type CardRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequest to aggregate.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardRequests
    **/
    _count?: true | CardRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardRequestMaxAggregateInputType
  }

  export type GetCardRequestAggregateType<T extends CardRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCardRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardRequest[P]>
      : GetScalarType<T[P], AggregateCardRequest[P]>
  }




  export type CardRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardRequestWhereInput
    orderBy?: CardRequestOrderByWithAggregationInput | CardRequestOrderByWithAggregationInput[]
    by: CardRequestScalarFieldEnum[] | CardRequestScalarFieldEnum
    having?: CardRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardRequestCountAggregateInputType | true
    _avg?: CardRequestAvgAggregateInputType
    _sum?: CardRequestSumAggregateInputType
    _min?: CardRequestMinAggregateInputType
    _max?: CardRequestMaxAggregateInputType
  }

  export type CardRequestGroupByOutputType = {
    id: number
    label: string
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    shopId1: number | null
    byId: number | null
    _count: CardRequestCountAggregateOutputType | null
    _avg: CardRequestAvgAggregateOutputType | null
    _sum: CardRequestSumAggregateOutputType | null
    _min: CardRequestMinAggregateOutputType | null
    _max: CardRequestMaxAggregateOutputType | null
  }

  type GetCardRequestGroupByPayload<T extends CardRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CardRequestGroupByOutputType[P]>
        }
      >
    >


  export type CardRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    quantity?: boolean
    status?: boolean
    shopId1?: boolean
    byId?: boolean
    shop?: boolean | CardRequest$shopArgs<ExtArgs>
    cardrequeststatus?: boolean | CardRequest$cardrequeststatusArgs<ExtArgs>
  }, ExtArgs["result"]["cardRequest"]>



  export type CardRequestSelectScalar = {
    id?: boolean
    label?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shopId?: boolean
    quantity?: boolean
    status?: boolean
    shopId1?: boolean
    byId?: boolean
  }

  export type CardRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "isActive" | "createdAt" | "updatedAt" | "shopId" | "quantity" | "status" | "shopId1" | "byId", ExtArgs["result"]["cardRequest"]>
  export type CardRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | CardRequest$shopArgs<ExtArgs>
    cardrequeststatus?: boolean | CardRequest$cardrequeststatusArgs<ExtArgs>
  }

  export type $CardRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardRequest"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs> | null
      cardrequeststatus: Prisma.$CardRequestStatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
      shopId: number
      quantity: number
      status: $Enums.CardRequestEnum
      shopId1: number | null
      byId: number | null
    }, ExtArgs["result"]["cardRequest"]>
    composites: {}
  }

  type CardRequestGetPayload<S extends boolean | null | undefined | CardRequestDefaultArgs> = $Result.GetResult<Prisma.$CardRequestPayload, S>

  type CardRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardRequestCountAggregateInputType | true
    }

  export interface CardRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardRequest'], meta: { name: 'CardRequest' } }
    /**
     * Find zero or one CardRequest that matches the filter.
     * @param {CardRequestFindUniqueArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardRequestFindUniqueArgs>(args: SelectSubset<T, CardRequestFindUniqueArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardRequestFindUniqueOrThrowArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CardRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindFirstArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardRequestFindFirstArgs>(args?: SelectSubset<T, CardRequestFindFirstArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindFirstOrThrowArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CardRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardRequests
     * const cardRequests = await prisma.cardRequest.findMany()
     * 
     * // Get first 10 CardRequests
     * const cardRequests = await prisma.cardRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardRequestWithIdOnly = await prisma.cardRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardRequestFindManyArgs>(args?: SelectSubset<T, CardRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardRequest.
     * @param {CardRequestCreateArgs} args - Arguments to create a CardRequest.
     * @example
     * // Create one CardRequest
     * const CardRequest = await prisma.cardRequest.create({
     *   data: {
     *     // ... data to create a CardRequest
     *   }
     * })
     * 
     */
    create<T extends CardRequestCreateArgs>(args: SelectSubset<T, CardRequestCreateArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardRequests.
     * @param {CardRequestCreateManyArgs} args - Arguments to create many CardRequests.
     * @example
     * // Create many CardRequests
     * const cardRequest = await prisma.cardRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardRequestCreateManyArgs>(args?: SelectSubset<T, CardRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CardRequest.
     * @param {CardRequestDeleteArgs} args - Arguments to delete one CardRequest.
     * @example
     * // Delete one CardRequest
     * const CardRequest = await prisma.cardRequest.delete({
     *   where: {
     *     // ... filter to delete one CardRequest
     *   }
     * })
     * 
     */
    delete<T extends CardRequestDeleteArgs>(args: SelectSubset<T, CardRequestDeleteArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardRequest.
     * @param {CardRequestUpdateArgs} args - Arguments to update one CardRequest.
     * @example
     * // Update one CardRequest
     * const cardRequest = await prisma.cardRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardRequestUpdateArgs>(args: SelectSubset<T, CardRequestUpdateArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardRequests.
     * @param {CardRequestDeleteManyArgs} args - Arguments to filter CardRequests to delete.
     * @example
     * // Delete a few CardRequests
     * const { count } = await prisma.cardRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardRequestDeleteManyArgs>(args?: SelectSubset<T, CardRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardRequests
     * const cardRequest = await prisma.cardRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardRequestUpdateManyArgs>(args: SelectSubset<T, CardRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardRequest.
     * @param {CardRequestUpsertArgs} args - Arguments to update or create a CardRequest.
     * @example
     * // Update or create a CardRequest
     * const cardRequest = await prisma.cardRequest.upsert({
     *   create: {
     *     // ... data to create a CardRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardRequest we want to update
     *   }
     * })
     */
    upsert<T extends CardRequestUpsertArgs>(args: SelectSubset<T, CardRequestUpsertArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestCountArgs} args - Arguments to filter CardRequests to count.
     * @example
     * // Count the number of CardRequests
     * const count = await prisma.cardRequest.count({
     *   where: {
     *     // ... the filter for the CardRequests we want to count
     *   }
     * })
    **/
    count<T extends CardRequestCountArgs>(
      args?: Subset<T, CardRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardRequestAggregateArgs>(args: Subset<T, CardRequestAggregateArgs>): Prisma.PrismaPromise<GetCardRequestAggregateType<T>>

    /**
     * Group by CardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardRequestGroupByArgs['orderBy'] }
        : { orderBy?: CardRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardRequest model
   */
  readonly fields: CardRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends CardRequest$shopArgs<ExtArgs> = {}>(args?: Subset<T, CardRequest$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cardrequeststatus<T extends CardRequest$cardrequeststatusArgs<ExtArgs> = {}>(args?: Subset<T, CardRequest$cardrequeststatusArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardRequest model
   */ 
  interface CardRequestFieldRefs {
    readonly id: FieldRef<"CardRequest", 'Int'>
    readonly label: FieldRef<"CardRequest", 'String'>
    readonly isActive: FieldRef<"CardRequest", 'Boolean'>
    readonly createdAt: FieldRef<"CardRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CardRequest", 'DateTime'>
    readonly shopId: FieldRef<"CardRequest", 'Int'>
    readonly quantity: FieldRef<"CardRequest", 'Int'>
    readonly status: FieldRef<"CardRequest", 'CardRequestEnum'>
    readonly shopId1: FieldRef<"CardRequest", 'Int'>
    readonly byId: FieldRef<"CardRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CardRequest findUnique
   */
  export type CardRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest findUniqueOrThrow
   */
  export type CardRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest findFirst
   */
  export type CardRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequests.
     */
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest findFirstOrThrow
   */
  export type CardRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequests.
     */
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest findMany
   */
  export type CardRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequests to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest create
   */
  export type CardRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CardRequest.
     */
    data: XOR<CardRequestCreateInput, CardRequestUncheckedCreateInput>
  }

  /**
   * CardRequest createMany
   */
  export type CardRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardRequests.
     */
    data: CardRequestCreateManyInput | CardRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardRequest update
   */
  export type CardRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CardRequest.
     */
    data: XOR<CardRequestUpdateInput, CardRequestUncheckedUpdateInput>
    /**
     * Choose, which CardRequest to update.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest updateMany
   */
  export type CardRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardRequests.
     */
    data: XOR<CardRequestUpdateManyMutationInput, CardRequestUncheckedUpdateManyInput>
    /**
     * Filter which CardRequests to update
     */
    where?: CardRequestWhereInput
    /**
     * Limit how many CardRequests to update.
     */
    limit?: number
  }

  /**
   * CardRequest upsert
   */
  export type CardRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CardRequest to update in case it exists.
     */
    where: CardRequestWhereUniqueInput
    /**
     * In case the CardRequest found by the `where` argument doesn't exist, create a new CardRequest with this data.
     */
    create: XOR<CardRequestCreateInput, CardRequestUncheckedCreateInput>
    /**
     * In case the CardRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardRequestUpdateInput, CardRequestUncheckedUpdateInput>
  }

  /**
   * CardRequest delete
   */
  export type CardRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter which CardRequest to delete.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest deleteMany
   */
  export type CardRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequests to delete
     */
    where?: CardRequestWhereInput
    /**
     * Limit how many CardRequests to delete.
     */
    limit?: number
  }

  /**
   * CardRequest.shop
   */
  export type CardRequest$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * CardRequest.cardrequeststatus
   */
  export type CardRequest$cardrequeststatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    where?: CardRequestStatusWhereInput
  }

  /**
   * CardRequest without action
   */
  export type CardRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequest
     */
    omit?: CardRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
  }


  /**
   * Model CardRequestStatus
   */

  export type AggregateCardRequestStatus = {
    _count: CardRequestStatusCountAggregateOutputType | null
    _avg: CardRequestStatusAvgAggregateOutputType | null
    _sum: CardRequestStatusSumAggregateOutputType | null
    _min: CardRequestStatusMinAggregateOutputType | null
    _max: CardRequestStatusMaxAggregateOutputType | null
  }

  export type CardRequestStatusAvgAggregateOutputType = {
    id: number | null
    byId: number | null
    cardRequestId: number | null
  }

  export type CardRequestStatusSumAggregateOutputType = {
    id: number | null
    byId: number | null
    cardRequestId: number | null
  }

  export type CardRequestStatusMinAggregateOutputType = {
    id: number | null
    status: $Enums.CardRequestEnum | null
    byId: number | null
    cardRequestId: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardRequestStatusMaxAggregateOutputType = {
    id: number | null
    status: $Enums.CardRequestEnum | null
    byId: number | null
    cardRequestId: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardRequestStatusCountAggregateOutputType = {
    id: number
    status: number
    byId: number
    cardRequestId: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardRequestStatusAvgAggregateInputType = {
    id?: true
    byId?: true
    cardRequestId?: true
  }

  export type CardRequestStatusSumAggregateInputType = {
    id?: true
    byId?: true
    cardRequestId?: true
  }

  export type CardRequestStatusMinAggregateInputType = {
    id?: true
    status?: true
    byId?: true
    cardRequestId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardRequestStatusMaxAggregateInputType = {
    id?: true
    status?: true
    byId?: true
    cardRequestId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardRequestStatusCountAggregateInputType = {
    id?: true
    status?: true
    byId?: true
    cardRequestId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardRequestStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequestStatus to aggregate.
     */
    where?: CardRequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequestStatuses to fetch.
     */
    orderBy?: CardRequestStatusOrderByWithRelationInput | CardRequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardRequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardRequestStatuses
    **/
    _count?: true | CardRequestStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardRequestStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardRequestStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardRequestStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardRequestStatusMaxAggregateInputType
  }

  export type GetCardRequestStatusAggregateType<T extends CardRequestStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCardRequestStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardRequestStatus[P]>
      : GetScalarType<T[P], AggregateCardRequestStatus[P]>
  }




  export type CardRequestStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardRequestStatusWhereInput
    orderBy?: CardRequestStatusOrderByWithAggregationInput | CardRequestStatusOrderByWithAggregationInput[]
    by: CardRequestStatusScalarFieldEnum[] | CardRequestStatusScalarFieldEnum
    having?: CardRequestStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardRequestStatusCountAggregateInputType | true
    _avg?: CardRequestStatusAvgAggregateInputType
    _sum?: CardRequestStatusSumAggregateInputType
    _min?: CardRequestStatusMinAggregateInputType
    _max?: CardRequestStatusMaxAggregateInputType
  }

  export type CardRequestStatusGroupByOutputType = {
    id: number
    status: $Enums.CardRequestEnum
    byId: number | null
    cardRequestId: number
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CardRequestStatusCountAggregateOutputType | null
    _avg: CardRequestStatusAvgAggregateOutputType | null
    _sum: CardRequestStatusSumAggregateOutputType | null
    _min: CardRequestStatusMinAggregateOutputType | null
    _max: CardRequestStatusMaxAggregateOutputType | null
  }

  type GetCardRequestStatusGroupByPayload<T extends CardRequestStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardRequestStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardRequestStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardRequestStatusGroupByOutputType[P]>
            : GetScalarType<T[P], CardRequestStatusGroupByOutputType[P]>
        }
      >
    >


  export type CardRequestStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    byId?: boolean
    cardRequestId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cardRequest?: boolean | CardRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardRequestStatus"]>



  export type CardRequestStatusSelectScalar = {
    id?: boolean
    status?: boolean
    byId?: boolean
    cardRequestId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardRequestStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "byId" | "cardRequestId" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["cardRequestStatus"]>
  export type CardRequestStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cardRequest?: boolean | CardRequestDefaultArgs<ExtArgs>
  }

  export type $CardRequestStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardRequestStatus"
    objects: {
      cardRequest: Prisma.$CardRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: $Enums.CardRequestEnum
      byId: number | null
      cardRequestId: number
      comment: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["cardRequestStatus"]>
    composites: {}
  }

  type CardRequestStatusGetPayload<S extends boolean | null | undefined | CardRequestStatusDefaultArgs> = $Result.GetResult<Prisma.$CardRequestStatusPayload, S>

  type CardRequestStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardRequestStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardRequestStatusCountAggregateInputType | true
    }

  export interface CardRequestStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardRequestStatus'], meta: { name: 'CardRequestStatus' } }
    /**
     * Find zero or one CardRequestStatus that matches the filter.
     * @param {CardRequestStatusFindUniqueArgs} args - Arguments to find a CardRequestStatus
     * @example
     * // Get one CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardRequestStatusFindUniqueArgs>(args: SelectSubset<T, CardRequestStatusFindUniqueArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardRequestStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardRequestStatusFindUniqueOrThrowArgs} args - Arguments to find a CardRequestStatus
     * @example
     * // Get one CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardRequestStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, CardRequestStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardRequestStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusFindFirstArgs} args - Arguments to find a CardRequestStatus
     * @example
     * // Get one CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardRequestStatusFindFirstArgs>(args?: SelectSubset<T, CardRequestStatusFindFirstArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardRequestStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusFindFirstOrThrowArgs} args - Arguments to find a CardRequestStatus
     * @example
     * // Get one CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardRequestStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, CardRequestStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardRequestStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardRequestStatuses
     * const cardRequestStatuses = await prisma.cardRequestStatus.findMany()
     * 
     * // Get first 10 CardRequestStatuses
     * const cardRequestStatuses = await prisma.cardRequestStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardRequestStatusWithIdOnly = await prisma.cardRequestStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardRequestStatusFindManyArgs>(args?: SelectSubset<T, CardRequestStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardRequestStatus.
     * @param {CardRequestStatusCreateArgs} args - Arguments to create a CardRequestStatus.
     * @example
     * // Create one CardRequestStatus
     * const CardRequestStatus = await prisma.cardRequestStatus.create({
     *   data: {
     *     // ... data to create a CardRequestStatus
     *   }
     * })
     * 
     */
    create<T extends CardRequestStatusCreateArgs>(args: SelectSubset<T, CardRequestStatusCreateArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardRequestStatuses.
     * @param {CardRequestStatusCreateManyArgs} args - Arguments to create many CardRequestStatuses.
     * @example
     * // Create many CardRequestStatuses
     * const cardRequestStatus = await prisma.cardRequestStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardRequestStatusCreateManyArgs>(args?: SelectSubset<T, CardRequestStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CardRequestStatus.
     * @param {CardRequestStatusDeleteArgs} args - Arguments to delete one CardRequestStatus.
     * @example
     * // Delete one CardRequestStatus
     * const CardRequestStatus = await prisma.cardRequestStatus.delete({
     *   where: {
     *     // ... filter to delete one CardRequestStatus
     *   }
     * })
     * 
     */
    delete<T extends CardRequestStatusDeleteArgs>(args: SelectSubset<T, CardRequestStatusDeleteArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardRequestStatus.
     * @param {CardRequestStatusUpdateArgs} args - Arguments to update one CardRequestStatus.
     * @example
     * // Update one CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardRequestStatusUpdateArgs>(args: SelectSubset<T, CardRequestStatusUpdateArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardRequestStatuses.
     * @param {CardRequestStatusDeleteManyArgs} args - Arguments to filter CardRequestStatuses to delete.
     * @example
     * // Delete a few CardRequestStatuses
     * const { count } = await prisma.cardRequestStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardRequestStatusDeleteManyArgs>(args?: SelectSubset<T, CardRequestStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardRequestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardRequestStatuses
     * const cardRequestStatus = await prisma.cardRequestStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardRequestStatusUpdateManyArgs>(args: SelectSubset<T, CardRequestStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardRequestStatus.
     * @param {CardRequestStatusUpsertArgs} args - Arguments to update or create a CardRequestStatus.
     * @example
     * // Update or create a CardRequestStatus
     * const cardRequestStatus = await prisma.cardRequestStatus.upsert({
     *   create: {
     *     // ... data to create a CardRequestStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardRequestStatus we want to update
     *   }
     * })
     */
    upsert<T extends CardRequestStatusUpsertArgs>(args: SelectSubset<T, CardRequestStatusUpsertArgs<ExtArgs>>): Prisma__CardRequestStatusClient<$Result.GetResult<Prisma.$CardRequestStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardRequestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusCountArgs} args - Arguments to filter CardRequestStatuses to count.
     * @example
     * // Count the number of CardRequestStatuses
     * const count = await prisma.cardRequestStatus.count({
     *   where: {
     *     // ... the filter for the CardRequestStatuses we want to count
     *   }
     * })
    **/
    count<T extends CardRequestStatusCountArgs>(
      args?: Subset<T, CardRequestStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardRequestStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardRequestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardRequestStatusAggregateArgs>(args: Subset<T, CardRequestStatusAggregateArgs>): Prisma.PrismaPromise<GetCardRequestStatusAggregateType<T>>

    /**
     * Group by CardRequestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardRequestStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardRequestStatusGroupByArgs['orderBy'] }
        : { orderBy?: CardRequestStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardRequestStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardRequestStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardRequestStatus model
   */
  readonly fields: CardRequestStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardRequestStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardRequestStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cardRequest<T extends CardRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardRequestDefaultArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardRequestStatus model
   */ 
  interface CardRequestStatusFieldRefs {
    readonly id: FieldRef<"CardRequestStatus", 'Int'>
    readonly status: FieldRef<"CardRequestStatus", 'CardRequestEnum'>
    readonly byId: FieldRef<"CardRequestStatus", 'Int'>
    readonly cardRequestId: FieldRef<"CardRequestStatus", 'Int'>
    readonly comment: FieldRef<"CardRequestStatus", 'String'>
    readonly createdAt: FieldRef<"CardRequestStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"CardRequestStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CardRequestStatus findUnique
   */
  export type CardRequestStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which CardRequestStatus to fetch.
     */
    where: CardRequestStatusWhereUniqueInput
  }

  /**
   * CardRequestStatus findUniqueOrThrow
   */
  export type CardRequestStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which CardRequestStatus to fetch.
     */
    where: CardRequestStatusWhereUniqueInput
  }

  /**
   * CardRequestStatus findFirst
   */
  export type CardRequestStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which CardRequestStatus to fetch.
     */
    where?: CardRequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequestStatuses to fetch.
     */
    orderBy?: CardRequestStatusOrderByWithRelationInput | CardRequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequestStatuses.
     */
    cursor?: CardRequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequestStatuses.
     */
    distinct?: CardRequestStatusScalarFieldEnum | CardRequestStatusScalarFieldEnum[]
  }

  /**
   * CardRequestStatus findFirstOrThrow
   */
  export type CardRequestStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which CardRequestStatus to fetch.
     */
    where?: CardRequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequestStatuses to fetch.
     */
    orderBy?: CardRequestStatusOrderByWithRelationInput | CardRequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequestStatuses.
     */
    cursor?: CardRequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequestStatuses.
     */
    distinct?: CardRequestStatusScalarFieldEnum | CardRequestStatusScalarFieldEnum[]
  }

  /**
   * CardRequestStatus findMany
   */
  export type CardRequestStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter, which CardRequestStatuses to fetch.
     */
    where?: CardRequestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequestStatuses to fetch.
     */
    orderBy?: CardRequestStatusOrderByWithRelationInput | CardRequestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardRequestStatuses.
     */
    cursor?: CardRequestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequestStatuses.
     */
    skip?: number
    distinct?: CardRequestStatusScalarFieldEnum | CardRequestStatusScalarFieldEnum[]
  }

  /**
   * CardRequestStatus create
   */
  export type CardRequestStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a CardRequestStatus.
     */
    data: XOR<CardRequestStatusCreateInput, CardRequestStatusUncheckedCreateInput>
  }

  /**
   * CardRequestStatus createMany
   */
  export type CardRequestStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardRequestStatuses.
     */
    data: CardRequestStatusCreateManyInput | CardRequestStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardRequestStatus update
   */
  export type CardRequestStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a CardRequestStatus.
     */
    data: XOR<CardRequestStatusUpdateInput, CardRequestStatusUncheckedUpdateInput>
    /**
     * Choose, which CardRequestStatus to update.
     */
    where: CardRequestStatusWhereUniqueInput
  }

  /**
   * CardRequestStatus updateMany
   */
  export type CardRequestStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardRequestStatuses.
     */
    data: XOR<CardRequestStatusUpdateManyMutationInput, CardRequestStatusUncheckedUpdateManyInput>
    /**
     * Filter which CardRequestStatuses to update
     */
    where?: CardRequestStatusWhereInput
    /**
     * Limit how many CardRequestStatuses to update.
     */
    limit?: number
  }

  /**
   * CardRequestStatus upsert
   */
  export type CardRequestStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the CardRequestStatus to update in case it exists.
     */
    where: CardRequestStatusWhereUniqueInput
    /**
     * In case the CardRequestStatus found by the `where` argument doesn't exist, create a new CardRequestStatus with this data.
     */
    create: XOR<CardRequestStatusCreateInput, CardRequestStatusUncheckedCreateInput>
    /**
     * In case the CardRequestStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardRequestStatusUpdateInput, CardRequestStatusUncheckedUpdateInput>
  }

  /**
   * CardRequestStatus delete
   */
  export type CardRequestStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
    /**
     * Filter which CardRequestStatus to delete.
     */
    where: CardRequestStatusWhereUniqueInput
  }

  /**
   * CardRequestStatus deleteMany
   */
  export type CardRequestStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequestStatuses to delete
     */
    where?: CardRequestStatusWhereInput
    /**
     * Limit how many CardRequestStatuses to delete.
     */
    limit?: number
  }

  /**
   * CardRequestStatus without action
   */
  export type CardRequestStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequestStatus
     */
    select?: CardRequestStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardRequestStatus
     */
    omit?: CardRequestStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestStatusInclude<ExtArgs> | null
  }


  /**
   * Model CardAllocationDetail
   */

  export type AggregateCardAllocationDetail = {
    _count: CardAllocationDetailCountAggregateOutputType | null
    _avg: CardAllocationDetailAvgAggregateOutputType | null
    _sum: CardAllocationDetailSumAggregateOutputType | null
    _min: CardAllocationDetailMinAggregateOutputType | null
    _max: CardAllocationDetailMaxAggregateOutputType | null
  }

  export type CardAllocationDetailAvgAggregateOutputType = {
    cardId: number | null
    cardAllocationId: number | null
  }

  export type CardAllocationDetailSumAggregateOutputType = {
    cardId: number | null
    cardAllocationId: number | null
  }

  export type CardAllocationDetailMinAggregateOutputType = {
    cardId: number | null
    cardAllocationId: number | null
  }

  export type CardAllocationDetailMaxAggregateOutputType = {
    cardId: number | null
    cardAllocationId: number | null
  }

  export type CardAllocationDetailCountAggregateOutputType = {
    cardId: number
    cardAllocationId: number
    _all: number
  }


  export type CardAllocationDetailAvgAggregateInputType = {
    cardId?: true
    cardAllocationId?: true
  }

  export type CardAllocationDetailSumAggregateInputType = {
    cardId?: true
    cardAllocationId?: true
  }

  export type CardAllocationDetailMinAggregateInputType = {
    cardId?: true
    cardAllocationId?: true
  }

  export type CardAllocationDetailMaxAggregateInputType = {
    cardId?: true
    cardAllocationId?: true
  }

  export type CardAllocationDetailCountAggregateInputType = {
    cardId?: true
    cardAllocationId?: true
    _all?: true
  }

  export type CardAllocationDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAllocationDetail to aggregate.
     */
    where?: CardAllocationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocationDetails to fetch.
     */
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardAllocationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardAllocationDetails
    **/
    _count?: true | CardAllocationDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAllocationDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardAllocationDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardAllocationDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardAllocationDetailMaxAggregateInputType
  }

  export type GetCardAllocationDetailAggregateType<T extends CardAllocationDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCardAllocationDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardAllocationDetail[P]>
      : GetScalarType<T[P], AggregateCardAllocationDetail[P]>
  }




  export type CardAllocationDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardAllocationDetailWhereInput
    orderBy?: CardAllocationDetailOrderByWithAggregationInput | CardAllocationDetailOrderByWithAggregationInput[]
    by: CardAllocationDetailScalarFieldEnum[] | CardAllocationDetailScalarFieldEnum
    having?: CardAllocationDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardAllocationDetailCountAggregateInputType | true
    _avg?: CardAllocationDetailAvgAggregateInputType
    _sum?: CardAllocationDetailSumAggregateInputType
    _min?: CardAllocationDetailMinAggregateInputType
    _max?: CardAllocationDetailMaxAggregateInputType
  }

  export type CardAllocationDetailGroupByOutputType = {
    cardId: number
    cardAllocationId: number
    _count: CardAllocationDetailCountAggregateOutputType | null
    _avg: CardAllocationDetailAvgAggregateOutputType | null
    _sum: CardAllocationDetailSumAggregateOutputType | null
    _min: CardAllocationDetailMinAggregateOutputType | null
    _max: CardAllocationDetailMaxAggregateOutputType | null
  }

  type GetCardAllocationDetailGroupByPayload<T extends CardAllocationDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardAllocationDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardAllocationDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardAllocationDetailGroupByOutputType[P]>
            : GetScalarType<T[P], CardAllocationDetailGroupByOutputType[P]>
        }
      >
    >


  export type CardAllocationDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cardId?: boolean
    cardAllocationId?: boolean
    card?: boolean | CardDefaultArgs<ExtArgs>
    cardAllocation?: boolean | CardAllocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardAllocationDetail"]>



  export type CardAllocationDetailSelectScalar = {
    cardId?: boolean
    cardAllocationId?: boolean
  }

  export type CardAllocationDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cardId" | "cardAllocationId", ExtArgs["result"]["cardAllocationDetail"]>
  export type CardAllocationDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    card?: boolean | CardDefaultArgs<ExtArgs>
    cardAllocation?: boolean | CardAllocationDefaultArgs<ExtArgs>
  }

  export type $CardAllocationDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardAllocationDetail"
    objects: {
      card: Prisma.$CardPayload<ExtArgs>
      cardAllocation: Prisma.$CardAllocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cardId: number
      cardAllocationId: number
    }, ExtArgs["result"]["cardAllocationDetail"]>
    composites: {}
  }

  type CardAllocationDetailGetPayload<S extends boolean | null | undefined | CardAllocationDetailDefaultArgs> = $Result.GetResult<Prisma.$CardAllocationDetailPayload, S>

  type CardAllocationDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardAllocationDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardAllocationDetailCountAggregateInputType | true
    }

  export interface CardAllocationDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardAllocationDetail'], meta: { name: 'CardAllocationDetail' } }
    /**
     * Find zero or one CardAllocationDetail that matches the filter.
     * @param {CardAllocationDetailFindUniqueArgs} args - Arguments to find a CardAllocationDetail
     * @example
     * // Get one CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardAllocationDetailFindUniqueArgs>(args: SelectSubset<T, CardAllocationDetailFindUniqueArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardAllocationDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardAllocationDetailFindUniqueOrThrowArgs} args - Arguments to find a CardAllocationDetail
     * @example
     * // Get one CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardAllocationDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, CardAllocationDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAllocationDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailFindFirstArgs} args - Arguments to find a CardAllocationDetail
     * @example
     * // Get one CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardAllocationDetailFindFirstArgs>(args?: SelectSubset<T, CardAllocationDetailFindFirstArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardAllocationDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailFindFirstOrThrowArgs} args - Arguments to find a CardAllocationDetail
     * @example
     * // Get one CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardAllocationDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, CardAllocationDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardAllocationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardAllocationDetails
     * const cardAllocationDetails = await prisma.cardAllocationDetail.findMany()
     * 
     * // Get first 10 CardAllocationDetails
     * const cardAllocationDetails = await prisma.cardAllocationDetail.findMany({ take: 10 })
     * 
     * // Only select the `cardId`
     * const cardAllocationDetailWithCardIdOnly = await prisma.cardAllocationDetail.findMany({ select: { cardId: true } })
     * 
     */
    findMany<T extends CardAllocationDetailFindManyArgs>(args?: SelectSubset<T, CardAllocationDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardAllocationDetail.
     * @param {CardAllocationDetailCreateArgs} args - Arguments to create a CardAllocationDetail.
     * @example
     * // Create one CardAllocationDetail
     * const CardAllocationDetail = await prisma.cardAllocationDetail.create({
     *   data: {
     *     // ... data to create a CardAllocationDetail
     *   }
     * })
     * 
     */
    create<T extends CardAllocationDetailCreateArgs>(args: SelectSubset<T, CardAllocationDetailCreateArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardAllocationDetails.
     * @param {CardAllocationDetailCreateManyArgs} args - Arguments to create many CardAllocationDetails.
     * @example
     * // Create many CardAllocationDetails
     * const cardAllocationDetail = await prisma.cardAllocationDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardAllocationDetailCreateManyArgs>(args?: SelectSubset<T, CardAllocationDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CardAllocationDetail.
     * @param {CardAllocationDetailDeleteArgs} args - Arguments to delete one CardAllocationDetail.
     * @example
     * // Delete one CardAllocationDetail
     * const CardAllocationDetail = await prisma.cardAllocationDetail.delete({
     *   where: {
     *     // ... filter to delete one CardAllocationDetail
     *   }
     * })
     * 
     */
    delete<T extends CardAllocationDetailDeleteArgs>(args: SelectSubset<T, CardAllocationDetailDeleteArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardAllocationDetail.
     * @param {CardAllocationDetailUpdateArgs} args - Arguments to update one CardAllocationDetail.
     * @example
     * // Update one CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardAllocationDetailUpdateArgs>(args: SelectSubset<T, CardAllocationDetailUpdateArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardAllocationDetails.
     * @param {CardAllocationDetailDeleteManyArgs} args - Arguments to filter CardAllocationDetails to delete.
     * @example
     * // Delete a few CardAllocationDetails
     * const { count } = await prisma.cardAllocationDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardAllocationDetailDeleteManyArgs>(args?: SelectSubset<T, CardAllocationDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardAllocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardAllocationDetails
     * const cardAllocationDetail = await prisma.cardAllocationDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardAllocationDetailUpdateManyArgs>(args: SelectSubset<T, CardAllocationDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardAllocationDetail.
     * @param {CardAllocationDetailUpsertArgs} args - Arguments to update or create a CardAllocationDetail.
     * @example
     * // Update or create a CardAllocationDetail
     * const cardAllocationDetail = await prisma.cardAllocationDetail.upsert({
     *   create: {
     *     // ... data to create a CardAllocationDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardAllocationDetail we want to update
     *   }
     * })
     */
    upsert<T extends CardAllocationDetailUpsertArgs>(args: SelectSubset<T, CardAllocationDetailUpsertArgs<ExtArgs>>): Prisma__CardAllocationDetailClient<$Result.GetResult<Prisma.$CardAllocationDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardAllocationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailCountArgs} args - Arguments to filter CardAllocationDetails to count.
     * @example
     * // Count the number of CardAllocationDetails
     * const count = await prisma.cardAllocationDetail.count({
     *   where: {
     *     // ... the filter for the CardAllocationDetails we want to count
     *   }
     * })
    **/
    count<T extends CardAllocationDetailCountArgs>(
      args?: Subset<T, CardAllocationDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardAllocationDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardAllocationDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAllocationDetailAggregateArgs>(args: Subset<T, CardAllocationDetailAggregateArgs>): Prisma.PrismaPromise<GetCardAllocationDetailAggregateType<T>>

    /**
     * Group by CardAllocationDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAllocationDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardAllocationDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardAllocationDetailGroupByArgs['orderBy'] }
        : { orderBy?: CardAllocationDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardAllocationDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardAllocationDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardAllocationDetail model
   */
  readonly fields: CardAllocationDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardAllocationDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardAllocationDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cardAllocation<T extends CardAllocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardAllocationDefaultArgs<ExtArgs>>): Prisma__CardAllocationClient<$Result.GetResult<Prisma.$CardAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardAllocationDetail model
   */ 
  interface CardAllocationDetailFieldRefs {
    readonly cardId: FieldRef<"CardAllocationDetail", 'Int'>
    readonly cardAllocationId: FieldRef<"CardAllocationDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CardAllocationDetail findUnique
   */
  export type CardAllocationDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocationDetail to fetch.
     */
    where: CardAllocationDetailWhereUniqueInput
  }

  /**
   * CardAllocationDetail findUniqueOrThrow
   */
  export type CardAllocationDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocationDetail to fetch.
     */
    where: CardAllocationDetailWhereUniqueInput
  }

  /**
   * CardAllocationDetail findFirst
   */
  export type CardAllocationDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocationDetail to fetch.
     */
    where?: CardAllocationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocationDetails to fetch.
     */
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAllocationDetails.
     */
    cursor?: CardAllocationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAllocationDetails.
     */
    distinct?: CardAllocationDetailScalarFieldEnum | CardAllocationDetailScalarFieldEnum[]
  }

  /**
   * CardAllocationDetail findFirstOrThrow
   */
  export type CardAllocationDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocationDetail to fetch.
     */
    where?: CardAllocationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocationDetails to fetch.
     */
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardAllocationDetails.
     */
    cursor?: CardAllocationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardAllocationDetails.
     */
    distinct?: CardAllocationDetailScalarFieldEnum | CardAllocationDetailScalarFieldEnum[]
  }

  /**
   * CardAllocationDetail findMany
   */
  export type CardAllocationDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter, which CardAllocationDetails to fetch.
     */
    where?: CardAllocationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardAllocationDetails to fetch.
     */
    orderBy?: CardAllocationDetailOrderByWithRelationInput | CardAllocationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardAllocationDetails.
     */
    cursor?: CardAllocationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardAllocationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardAllocationDetails.
     */
    skip?: number
    distinct?: CardAllocationDetailScalarFieldEnum | CardAllocationDetailScalarFieldEnum[]
  }

  /**
   * CardAllocationDetail create
   */
  export type CardAllocationDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a CardAllocationDetail.
     */
    data: XOR<CardAllocationDetailCreateInput, CardAllocationDetailUncheckedCreateInput>
  }

  /**
   * CardAllocationDetail createMany
   */
  export type CardAllocationDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardAllocationDetails.
     */
    data: CardAllocationDetailCreateManyInput | CardAllocationDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardAllocationDetail update
   */
  export type CardAllocationDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a CardAllocationDetail.
     */
    data: XOR<CardAllocationDetailUpdateInput, CardAllocationDetailUncheckedUpdateInput>
    /**
     * Choose, which CardAllocationDetail to update.
     */
    where: CardAllocationDetailWhereUniqueInput
  }

  /**
   * CardAllocationDetail updateMany
   */
  export type CardAllocationDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardAllocationDetails.
     */
    data: XOR<CardAllocationDetailUpdateManyMutationInput, CardAllocationDetailUncheckedUpdateManyInput>
    /**
     * Filter which CardAllocationDetails to update
     */
    where?: CardAllocationDetailWhereInput
    /**
     * Limit how many CardAllocationDetails to update.
     */
    limit?: number
  }

  /**
   * CardAllocationDetail upsert
   */
  export type CardAllocationDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the CardAllocationDetail to update in case it exists.
     */
    where: CardAllocationDetailWhereUniqueInput
    /**
     * In case the CardAllocationDetail found by the `where` argument doesn't exist, create a new CardAllocationDetail with this data.
     */
    create: XOR<CardAllocationDetailCreateInput, CardAllocationDetailUncheckedCreateInput>
    /**
     * In case the CardAllocationDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardAllocationDetailUpdateInput, CardAllocationDetailUncheckedUpdateInput>
  }

  /**
   * CardAllocationDetail delete
   */
  export type CardAllocationDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
    /**
     * Filter which CardAllocationDetail to delete.
     */
    where: CardAllocationDetailWhereUniqueInput
  }

  /**
   * CardAllocationDetail deleteMany
   */
  export type CardAllocationDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardAllocationDetails to delete
     */
    where?: CardAllocationDetailWhereInput
    /**
     * Limit how many CardAllocationDetails to delete.
     */
    limit?: number
  }

  /**
   * CardAllocationDetail without action
   */
  export type CardAllocationDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardAllocationDetail
     */
    select?: CardAllocationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardAllocationDetail
     */
    omit?: CardAllocationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardAllocationDetailInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    customerId: number | null
    cardId: number | null
    byId: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    customerId: number | null
    cardId: number | null
    byId: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    customerId: number | null
    cardId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type AssignmentMaxAggregateOutputType = {
    customerId: number | null
    cardId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type AssignmentCountAggregateOutputType = {
    customerId: number
    cardId: number
    isActive: number
    createdAt: number
    updatedAt: number
    byId: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    customerId?: true
    cardId?: true
    byId?: true
  }

  export type AssignmentSumAggregateInputType = {
    customerId?: true
    cardId?: true
    byId?: true
  }

  export type AssignmentMinAggregateInputType = {
    customerId?: true
    cardId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type AssignmentMaxAggregateInputType = {
    customerId?: true
    cardId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type AssignmentCountAggregateInputType = {
    customerId?: true
    cardId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    customerId: number
    cardId: number
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    cardId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>



  export type AssignmentSelectScalar = {
    customerId?: boolean
    cardId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customerId" | "cardId" | "isActive" | "createdAt" | "updatedAt" | "byId", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      card: Prisma.$CardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      customerId: number
      cardId: number
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const assignmentWithCustomerIdOnly = await prisma.assignment.findMany({ select: { customerId: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly customerId: FieldRef<"Assignment", 'Int'>
    readonly cardId: FieldRef<"Assignment", 'Int'>
    readonly isActive: FieldRef<"Assignment", 'Boolean'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
    readonly byId: FieldRef<"Assignment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    id: number | null
  }

  export type ModuleSumAggregateOutputType = {
    id: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    id?: true
  }

  export type ModuleSumAggregateInputType = {
    id?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    permission?: boolean | Module$permissionArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>



  export type ModuleSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isActive", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | Module$permissionArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isActive: boolean
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends Module$permissionArgs<ExtArgs> = {}>(args?: Subset<T, Module$permissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'Int'>
    readonly name: FieldRef<"Module", 'String'>
    readonly isActive: FieldRef<"Module", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.permission
   */
  export type Module$permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
    byId: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
    byId: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    byId: number | null
    isActive: boolean | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    byId: number | null
    isActive: boolean | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    comment: number
    byId: number
    isActive: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
    byId?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
    byId?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    byId?: true
    isActive?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    byId?: true
    isActive?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    comment?: true
    byId?: true
    isActive?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    comment: string | null
    byId: number | null
    isActive: boolean
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    byId?: boolean
    isActive?: boolean
    rolePermission?: boolean | Role$rolePermissionArgs<ExtArgs>
    login?: boolean | Role$loginArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean
    byId?: boolean
    isActive?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "comment" | "byId" | "isActive", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | Role$rolePermissionArgs<ExtArgs>
    login?: boolean | Role$loginArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      rolePermission: Prisma.$RolePermissionPayload<ExtArgs>[]
      login: Prisma.$LoginPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date | null
      updatedAt: Date | null
      comment: string | null
      byId: number | null
      isActive: boolean
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermission<T extends Role$rolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    login<T extends Role$loginArgs<ExtArgs> = {}>(args?: Subset<T, Role$loginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly comment: FieldRef<"Role", 'String'>
    readonly byId: FieldRef<"Role", 'Int'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.rolePermission
   */
  export type Role$rolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.login
   */
  export type Role$loginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Login
     */
    omit?: LoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginInclude<ExtArgs> | null
    where?: LoginWhereInput
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    cursor?: LoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: number
    permissionId: number
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "permissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permissionId: number
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
    moduleId: number | null
    byId: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
    moduleId: number | null
    byId: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    code: string | null
    comment: string | null
    moduleId: number | null
    action: $Enums.PermissionActionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    comment: string | null
    moduleId: number | null
    action: $Enums.PermissionActionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    code: number
    comment: number
    moduleId: number
    action: number
    createdAt: number
    updatedAt: number
    byId: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
    moduleId?: true
    byId?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
    moduleId?: true
    byId?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    code?: true
    comment?: true
    moduleId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    code?: true
    comment?: true
    moduleId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    code?: true
    comment?: true
    moduleId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    code: string
    comment: string | null
    moduleId: number
    action: $Enums.PermissionActionEnum
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    comment?: boolean
    moduleId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    rolePermission?: boolean | Permission$rolePermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    code?: boolean
    comment?: boolean
    moduleId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "comment" | "moduleId" | "action" | "createdAt" | "updatedAt" | "byId", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    rolePermission?: boolean | Permission$rolePermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      rolePermission: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      comment: string | null
      moduleId: number
      action: $Enums.PermissionActionEnum
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rolePermission<T extends Permission$rolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly comment: FieldRef<"Permission", 'String'>
    readonly moduleId: FieldRef<"Permission", 'Int'>
    readonly action: FieldRef<"Permission", 'PermissionActionEnum'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
    readonly byId: FieldRef<"Permission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermission
   */
  export type Permission$rolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    byId: number | null
    duration: number | null
  }

  export type OfferSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    byId: number | null
    duration: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: number | null
    name: string | null
    comment: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    duration: number | null
  }

  export type OfferMaxAggregateOutputType = {
    id: number | null
    name: string | null
    comment: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    duration: number | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    name: number
    comment: number
    amount: number
    createdAt: number
    updatedAt: number
    byId: number
    duration: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    id?: true
    amount?: true
    byId?: true
    duration?: true
  }

  export type OfferSumAggregateInputType = {
    id?: true
    amount?: true
    byId?: true
    duration?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    name?: true
    comment?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    duration?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    name?: true
    comment?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    duration?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    name?: true
    comment?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    byId?: true
    duration?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: number
    name: string
    comment: string | null
    amount: Decimal
    createdAt: Date | null
    updatedAt: Date | null
    byId: number | null
    duration: number
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    comment?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    duration?: boolean
    payment?: boolean | Offer$paymentArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>



  export type OfferSelectScalar = {
    id?: boolean
    name?: boolean
    comment?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    byId?: boolean
    duration?: boolean
  }

  export type OfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "comment" | "amount" | "createdAt" | "updatedAt" | "byId" | "duration", ExtArgs["result"]["offer"]>
  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | Offer$paymentArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      comment: string | null
      amount: Prisma.Decimal
      createdAt: Date | null
      updatedAt: Date | null
      byId: number | null
      duration: number
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends Offer$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Offer$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */ 
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'Int'>
    readonly name: FieldRef<"Offer", 'String'>
    readonly comment: FieldRef<"Offer", 'String'>
    readonly amount: FieldRef<"Offer", 'Decimal'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
    readonly byId: FieldRef<"Offer", 'Int'>
    readonly duration: FieldRef<"Offer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to update.
     */
    limit?: number
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
    /**
     * Limit how many Offers to delete.
     */
    limit?: number
  }

  /**
   * Offer.payment
   */
  export type Offer$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
    offerId: number | null
    amount: Decimal | null
    byId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    shopId: number | null
    offerId: number | null
    amount: Decimal | null
    byId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    offerId: number | null
    amount: Decimal | null
    byId: number | null
    expirationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    offerId: number | null
    amount: Decimal | null
    byId: number | null
    expirationDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    shopId: number
    offerId: number
    amount: number
    byId: number
    expirationDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    shopId?: true
    offerId?: true
    amount?: true
    byId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    shopId?: true
    offerId?: true
    amount?: true
    byId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    shopId?: true
    offerId?: true
    amount?: true
    byId?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    shopId?: true
    offerId?: true
    amount?: true
    byId?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    shopId?: true
    offerId?: true
    amount?: true
    byId?: true
    expirationDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    shopId: number
    offerId: number
    amount: Decimal
    byId: number
    expirationDate: Date
    isActive: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    offerId?: boolean
    amount?: boolean
    byId?: boolean
    expirationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    offer?: boolean | Payment$offerArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    shopId?: boolean
    offerId?: boolean
    amount?: boolean
    byId?: boolean
    expirationDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "offerId" | "amount" | "byId" | "expirationDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    offer?: boolean | Payment$offerArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      offer: Prisma.$OfferPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shopId: number
      offerId: number
      amount: Prisma.Decimal
      byId: number
      expirationDate: Date
      isActive: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offer<T extends Payment$offerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$offerArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly shopId: FieldRef<"Payment", 'Int'>
    readonly offerId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly byId: FieldRef<"Payment", 'Int'>
    readonly expirationDate: FieldRef<"Payment", 'DateTime'>
    readonly isActive: FieldRef<"Payment", 'Boolean'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.offer
   */
  export type Payment$offerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offer
     */
    omit?: OfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LoginScalarFieldEnum: {
    id: 'id',
    type: 'type',
    username: 'username',
    password: 'password',
    isActive: 'isActive',
    isBlocked: 'isBlocked',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoginScalarFieldEnum = (typeof LoginScalarFieldEnum)[keyof typeof LoginScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    to: 'to',
    code: 'code',
    duration: 'duration',
    via: 'via',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    loginId: 'loginId'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    displayname: 'displayname',
    email: 'email',
    address: 'address',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    laltitude: 'laltitude',
    longitude: 'longitude'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    address: 'address',
    phone: 'phone',
    laltitude: 'laltitude',
    longitude: 'longitude',
    dateOfBirth: 'dateOfBirth',
    entityBaseId: 'entityBaseId'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerAliasScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId',
    shopId: 'shopId',
    isActive: 'isActive'
  };

  export type CustomerAliasScalarFieldEnum = (typeof CustomerAliasScalarFieldEnum)[keyof typeof CustomerAliasScalarFieldEnum]


  export const DebtStatusScalarFieldEnum: {
    id: 'id',
    totalCredit: 'totalCredit',
    totalDebut: 'totalDebut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerAliasId: 'customerAliasId'
  };

  export type DebtStatusScalarFieldEnum = (typeof DebtStatusScalarFieldEnum)[keyof typeof DebtStatusScalarFieldEnum]


  export const DeptScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    comment: 'comment',
    type: 'type',
    customerAliasId: 'customerAliasId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeptScalarFieldEnum = (typeof DeptScalarFieldEnum)[keyof typeof DeptScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    entityBaseId: 'entityBaseId',
    laltitude: 'laltitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const UserShopScalarFieldEnum: {
    shopId: 'shopId',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role'
  };

  export type UserShopScalarFieldEnum = (typeof UserShopScalarFieldEnum)[keyof typeof UserShopScalarFieldEnum]


  export const WalletBaseScalarFieldEnum: {
    id: 'id',
    type: 'type',
    isActive: 'isActive'
  };

  export type WalletBaseScalarFieldEnum = (typeof WalletBaseScalarFieldEnum)[keyof typeof WalletBaseScalarFieldEnum]


  export const WalletStatusScalarFieldEnum: {
    id: 'id',
    totalDebit: 'totalDebit',
    totalCredit: 'totalCredit',
    walletBaseId: 'walletBaseId',
    createdAt: 'createdAt'
  };

  export type WalletStatusScalarFieldEnum = (typeof WalletStatusScalarFieldEnum)[keyof typeof WalletStatusScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    fromId: 'fromId',
    toId: 'toId',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    walletBaseId: 'walletBaseId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const CardAllocationScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    shopId: 'shopId',
    byId: 'byId'
  };

  export type CardAllocationScalarFieldEnum = (typeof CardAllocationScalarFieldEnum)[keyof typeof CardAllocationScalarFieldEnum]


  export const CardRequestScalarFieldEnum: {
    id: 'id',
    label: 'label',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    shopId: 'shopId',
    quantity: 'quantity',
    status: 'status',
    shopId1: 'shopId1',
    byId: 'byId'
  };

  export type CardRequestScalarFieldEnum = (typeof CardRequestScalarFieldEnum)[keyof typeof CardRequestScalarFieldEnum]


  export const CardRequestStatusScalarFieldEnum: {
    id: 'id',
    status: 'status',
    byId: 'byId',
    cardRequestId: 'cardRequestId',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardRequestStatusScalarFieldEnum = (typeof CardRequestStatusScalarFieldEnum)[keyof typeof CardRequestStatusScalarFieldEnum]


  export const CardAllocationDetailScalarFieldEnum: {
    cardId: 'cardId',
    cardAllocationId: 'cardAllocationId'
  };

  export type CardAllocationDetailScalarFieldEnum = (typeof CardAllocationDetailScalarFieldEnum)[keyof typeof CardAllocationDetailScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    customerId: 'customerId',
    cardId: 'cardId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    comment: 'comment',
    byId: 'byId',
    isActive: 'isActive'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    comment: 'comment',
    moduleId: 'moduleId',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    name: 'name',
    comment: 'comment',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    byId: 'byId',
    duration: 'duration'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    offerId: 'offerId',
    amount: 'amount',
    byId: 'byId',
    expirationDate: 'expirationDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const LoginOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password'
  };

  export type LoginOrderByRelevanceFieldEnum = (typeof LoginOrderByRelevanceFieldEnum)[keyof typeof LoginOrderByRelevanceFieldEnum]


  export const OtpOrderByRelevanceFieldEnum: {
    to: 'to',
    code: 'code'
  };

  export type OtpOrderByRelevanceFieldEnum = (typeof OtpOrderByRelevanceFieldEnum)[keyof typeof OtpOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    displayname: 'displayname',
    email: 'email',
    address: 'address',
    phone: 'phone'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    address: 'address',
    phone: 'phone'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const DeptOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type DeptOrderByRelevanceFieldEnum = (typeof DeptOrderByRelevanceFieldEnum)[keyof typeof DeptOrderByRelevanceFieldEnum]


  export const CardOrderByRelevanceFieldEnum: {
    serial: 'serial'
  };

  export type CardOrderByRelevanceFieldEnum = (typeof CardOrderByRelevanceFieldEnum)[keyof typeof CardOrderByRelevanceFieldEnum]


  export const CardRequestOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type CardRequestOrderByRelevanceFieldEnum = (typeof CardRequestOrderByRelevanceFieldEnum)[keyof typeof CardRequestOrderByRelevanceFieldEnum]


  export const CardRequestStatusOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type CardRequestStatusOrderByRelevanceFieldEnum = (typeof CardRequestStatusOrderByRelevanceFieldEnum)[keyof typeof CardRequestStatusOrderByRelevanceFieldEnum]


  export const ModuleOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ModuleOrderByRelevanceFieldEnum = (typeof ModuleOrderByRelevanceFieldEnum)[keyof typeof ModuleOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    name: 'name',
    comment: 'comment'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    code: 'code',
    comment: 'comment'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const OfferOrderByRelevanceFieldEnum: {
    name: 'name',
    comment: 'comment'
  };

  export type OfferOrderByRelevanceFieldEnum = (typeof OfferOrderByRelevanceFieldEnum)[keyof typeof OfferOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'LoginEnum'
   */
  export type EnumLoginEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginEnum'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'OptDurationEnum'
   */
  export type EnumOptDurationEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptDurationEnum'>
    


  /**
   * Reference to a field of type 'OptViaEnum'
   */
  export type EnumOptViaEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptViaEnum'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'TransactionTypeEnum'
   */
  export type EnumTransactionTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionTypeEnum'>
    


  /**
   * Reference to a field of type 'UserShopRoleEnum'
   */
  export type EnumUserShopRoleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserShopRoleEnum'>
    


  /**
   * Reference to a field of type 'EntityEnum'
   */
  export type EnumEntityEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityEnum'>
    


  /**
   * Reference to a field of type 'CardRequestEnum'
   */
  export type EnumCardRequestEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardRequestEnum'>
    


  /**
   * Reference to a field of type 'PermissionActionEnum'
   */
  export type EnumPermissionActionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionActionEnum'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type LoginWhereInput = {
    AND?: LoginWhereInput | LoginWhereInput[]
    OR?: LoginWhereInput[]
    NOT?: LoginWhereInput | LoginWhereInput[]
    id?: IntFilter<"Login"> | number
    type?: EnumLoginEnumFilter<"Login"> | $Enums.LoginEnum
    username?: StringFilter<"Login"> | string
    password?: StringFilter<"Login"> | string
    isActive?: BoolFilter<"Login"> | boolean
    isBlocked?: BoolFilter<"Login"> | boolean
    roleId?: IntNullableFilter<"Login"> | number | null
    createdAt?: DateTimeNullableFilter<"Login"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Login"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Otp?: OtpListRelationFilter
  }

  export type LoginOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    roleId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    Otp?: OtpOrderByRelationAggregateInput
    _relevance?: LoginOrderByRelevanceInput
  }

  export type LoginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type_username?: LoginTypeUsernameCompoundUniqueInput
    AND?: LoginWhereInput | LoginWhereInput[]
    OR?: LoginWhereInput[]
    NOT?: LoginWhereInput | LoginWhereInput[]
    type?: EnumLoginEnumFilter<"Login"> | $Enums.LoginEnum
    username?: StringFilter<"Login"> | string
    password?: StringFilter<"Login"> | string
    isActive?: BoolFilter<"Login"> | boolean
    isBlocked?: BoolFilter<"Login"> | boolean
    roleId?: IntNullableFilter<"Login"> | number | null
    createdAt?: DateTimeNullableFilter<"Login"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Login"> | Date | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Otp?: OtpListRelationFilter
  }, "id" | "type_username">

  export type LoginOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    roleId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: LoginCountOrderByAggregateInput
    _avg?: LoginAvgOrderByAggregateInput
    _max?: LoginMaxOrderByAggregateInput
    _min?: LoginMinOrderByAggregateInput
    _sum?: LoginSumOrderByAggregateInput
  }

  export type LoginScalarWhereWithAggregatesInput = {
    AND?: LoginScalarWhereWithAggregatesInput | LoginScalarWhereWithAggregatesInput[]
    OR?: LoginScalarWhereWithAggregatesInput[]
    NOT?: LoginScalarWhereWithAggregatesInput | LoginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Login"> | number
    type?: EnumLoginEnumWithAggregatesFilter<"Login"> | $Enums.LoginEnum
    username?: StringWithAggregatesFilter<"Login"> | string
    password?: StringWithAggregatesFilter<"Login"> | string
    isActive?: BoolWithAggregatesFilter<"Login"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"Login"> | boolean
    roleId?: IntNullableWithAggregatesFilter<"Login"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Login"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Login"> | Date | string | null
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: IntFilter<"Otp"> | number
    to?: StringNullableFilter<"Otp"> | string | null
    code?: StringFilter<"Otp"> | string
    duration?: EnumOptDurationEnumFilter<"Otp"> | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFilter<"Otp"> | $Enums.OptViaEnum
    createdAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    loginId?: IntNullableFilter<"Otp"> | number | null
    login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    to?: SortOrderInput | SortOrder
    code?: SortOrder
    duration?: SortOrder
    via?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    loginId?: SortOrderInput | SortOrder
    login?: LoginOrderByWithRelationInput
    _relevance?: OtpOrderByRelevanceInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    to?: StringNullableFilter<"Otp"> | string | null
    code?: StringFilter<"Otp"> | string
    duration?: EnumOptDurationEnumFilter<"Otp"> | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFilter<"Otp"> | $Enums.OptViaEnum
    createdAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    loginId?: IntNullableFilter<"Otp"> | number | null
    login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    to?: SortOrderInput | SortOrder
    code?: SortOrder
    duration?: SortOrder
    via?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    loginId?: SortOrderInput | SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Otp"> | number
    to?: StringNullableWithAggregatesFilter<"Otp"> | string | null
    code?: StringWithAggregatesFilter<"Otp"> | string
    duration?: EnumOptDurationEnumWithAggregatesFilter<"Otp"> | $Enums.OptDurationEnum
    via?: EnumOptViaEnumWithAggregatesFilter<"Otp"> | $Enums.OptViaEnum
    createdAt?: DateTimeNullableWithAggregatesFilter<"Otp"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Otp"> | Date | string | null
    loginId?: IntNullableWithAggregatesFilter<"Otp"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    loginId?: IntNullableFilter<"User"> | number | null
    displayname?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    address?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    laltitude?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
    userShop?: UserShopListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrderInput | SortOrder
    displayname?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    login?: LoginOrderByWithRelationInput
    userShop?: UserShopOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    loginId?: number
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayname?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    laltitude?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
    userShop?: UserShopListRelationFilter
  }, "id" | "loginId" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrderInput | SortOrder
    displayname?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    loginId?: IntNullableWithAggregatesFilter<"User"> | number | null
    displayname?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    laltitude?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    loginId?: IntNullableFilter<"Customer"> | number | null
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringFilter<"Customer"> | string
    laltitude?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    entityBaseId?: IntFilter<"Customer"> | number
    Login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
    customerAlias?: CustomerAliasListRelationFilter
    WalletBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    assignment?: AssignmentListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    entityBaseId?: SortOrder
    Login?: LoginOrderByWithRelationInput
    customerAlias?: CustomerAliasOrderByRelationAggregateInput
    WalletBase?: WalletBaseOrderByWithRelationInput
    assignment?: AssignmentOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    loginId?: number
    phone?: string
    entityBaseId?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    address?: StringNullableFilter<"Customer"> | string | null
    laltitude?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    Login?: XOR<LoginNullableScalarRelationFilter, LoginWhereInput> | null
    customerAlias?: CustomerAliasListRelationFilter
    WalletBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    assignment?: AssignmentListRelationFilter
  }, "id" | "loginId" | "phone" | "entityBaseId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    entityBaseId?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    loginId?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringWithAggregatesFilter<"Customer"> | string
    laltitude?: DecimalNullableWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    entityBaseId?: IntWithAggregatesFilter<"Customer"> | number
  }

  export type CustomerAliasWhereInput = {
    AND?: CustomerAliasWhereInput | CustomerAliasWhereInput[]
    OR?: CustomerAliasWhereInput[]
    NOT?: CustomerAliasWhereInput | CustomerAliasWhereInput[]
    id?: IntFilter<"CustomerAlias"> | number
    customerId?: IntFilter<"CustomerAlias"> | number
    createdAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    byId?: IntNullableFilter<"CustomerAlias"> | number | null
    shopId?: IntFilter<"CustomerAlias"> | number
    isActive?: BoolFilter<"CustomerAlias"> | boolean
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    dept?: DeptListRelationFilter
    debtStatus?: DebtStatusListRelationFilter
  }

  export type CustomerAliasOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    shopId?: SortOrder
    isActive?: SortOrder
    shop?: ShopOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    dept?: DeptOrderByRelationAggregateInput
    debtStatus?: DebtStatusOrderByRelationAggregateInput
  }

  export type CustomerAliasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerAliasWhereInput | CustomerAliasWhereInput[]
    OR?: CustomerAliasWhereInput[]
    NOT?: CustomerAliasWhereInput | CustomerAliasWhereInput[]
    customerId?: IntFilter<"CustomerAlias"> | number
    createdAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    byId?: IntNullableFilter<"CustomerAlias"> | number | null
    shopId?: IntFilter<"CustomerAlias"> | number
    isActive?: BoolFilter<"CustomerAlias"> | boolean
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    dept?: DeptListRelationFilter
    debtStatus?: DebtStatusListRelationFilter
  }, "id">

  export type CustomerAliasOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    shopId?: SortOrder
    isActive?: SortOrder
    _count?: CustomerAliasCountOrderByAggregateInput
    _avg?: CustomerAliasAvgOrderByAggregateInput
    _max?: CustomerAliasMaxOrderByAggregateInput
    _min?: CustomerAliasMinOrderByAggregateInput
    _sum?: CustomerAliasSumOrderByAggregateInput
  }

  export type CustomerAliasScalarWhereWithAggregatesInput = {
    AND?: CustomerAliasScalarWhereWithAggregatesInput | CustomerAliasScalarWhereWithAggregatesInput[]
    OR?: CustomerAliasScalarWhereWithAggregatesInput[]
    NOT?: CustomerAliasScalarWhereWithAggregatesInput | CustomerAliasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerAlias"> | number
    customerId?: IntWithAggregatesFilter<"CustomerAlias"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"CustomerAlias"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CustomerAlias"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"CustomerAlias"> | number | null
    shopId?: IntWithAggregatesFilter<"CustomerAlias"> | number
    isActive?: BoolWithAggregatesFilter<"CustomerAlias"> | boolean
  }

  export type DebtStatusWhereInput = {
    AND?: DebtStatusWhereInput | DebtStatusWhereInput[]
    OR?: DebtStatusWhereInput[]
    NOT?: DebtStatusWhereInput | DebtStatusWhereInput[]
    id?: IntFilter<"DebtStatus"> | number
    totalCredit?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    customerAliasId?: IntFilter<"DebtStatus"> | number
    customerAlias?: XOR<CustomerAliasScalarRelationFilter, CustomerAliasWhereInput>
  }

  export type DebtStatusOrderByWithRelationInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    customerAliasId?: SortOrder
    customerAlias?: CustomerAliasOrderByWithRelationInput
  }

  export type DebtStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DebtStatusWhereInput | DebtStatusWhereInput[]
    OR?: DebtStatusWhereInput[]
    NOT?: DebtStatusWhereInput | DebtStatusWhereInput[]
    totalCredit?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    customerAliasId?: IntFilter<"DebtStatus"> | number
    customerAlias?: XOR<CustomerAliasScalarRelationFilter, CustomerAliasWhereInput>
  }, "id">

  export type DebtStatusOrderByWithAggregationInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    customerAliasId?: SortOrder
    _count?: DebtStatusCountOrderByAggregateInput
    _avg?: DebtStatusAvgOrderByAggregateInput
    _max?: DebtStatusMaxOrderByAggregateInput
    _min?: DebtStatusMinOrderByAggregateInput
    _sum?: DebtStatusSumOrderByAggregateInput
  }

  export type DebtStatusScalarWhereWithAggregatesInput = {
    AND?: DebtStatusScalarWhereWithAggregatesInput | DebtStatusScalarWhereWithAggregatesInput[]
    OR?: DebtStatusScalarWhereWithAggregatesInput[]
    NOT?: DebtStatusScalarWhereWithAggregatesInput | DebtStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DebtStatus"> | number
    totalCredit?: DecimalWithAggregatesFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalWithAggregatesFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"DebtStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DebtStatus"> | Date | string | null
    customerAliasId?: IntWithAggregatesFilter<"DebtStatus"> | number
  }

  export type DeptWhereInput = {
    AND?: DeptWhereInput | DeptWhereInput[]
    OR?: DeptWhereInput[]
    NOT?: DeptWhereInput | DeptWhereInput[]
    id?: IntFilter<"Dept"> | number
    amount?: DecimalFilter<"Dept"> | Decimal | DecimalJsLike | number | string
    comment?: StringNullableFilter<"Dept"> | string | null
    type?: EnumTransactionTypeEnumFilter<"Dept"> | $Enums.TransactionTypeEnum
    customerAliasId?: IntFilter<"Dept"> | number
    createdAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
    customerAlias?: XOR<CustomerAliasScalarRelationFilter, CustomerAliasWhereInput>
  }

  export type DeptOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    customerAliasId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    customerAlias?: CustomerAliasOrderByWithRelationInput
    _relevance?: DeptOrderByRelevanceInput
  }

  export type DeptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeptWhereInput | DeptWhereInput[]
    OR?: DeptWhereInput[]
    NOT?: DeptWhereInput | DeptWhereInput[]
    amount?: DecimalFilter<"Dept"> | Decimal | DecimalJsLike | number | string
    comment?: StringNullableFilter<"Dept"> | string | null
    type?: EnumTransactionTypeEnumFilter<"Dept"> | $Enums.TransactionTypeEnum
    customerAliasId?: IntFilter<"Dept"> | number
    createdAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
    customerAlias?: XOR<CustomerAliasScalarRelationFilter, CustomerAliasWhereInput>
  }, "id">

  export type DeptOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    customerAliasId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DeptCountOrderByAggregateInput
    _avg?: DeptAvgOrderByAggregateInput
    _max?: DeptMaxOrderByAggregateInput
    _min?: DeptMinOrderByAggregateInput
    _sum?: DeptSumOrderByAggregateInput
  }

  export type DeptScalarWhereWithAggregatesInput = {
    AND?: DeptScalarWhereWithAggregatesInput | DeptScalarWhereWithAggregatesInput[]
    OR?: DeptScalarWhereWithAggregatesInput[]
    NOT?: DeptScalarWhereWithAggregatesInput | DeptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dept"> | number
    amount?: DecimalWithAggregatesFilter<"Dept"> | Decimal | DecimalJsLike | number | string
    comment?: StringNullableWithAggregatesFilter<"Dept"> | string | null
    type?: EnumTransactionTypeEnumWithAggregatesFilter<"Dept"> | $Enums.TransactionTypeEnum
    customerAliasId?: IntWithAggregatesFilter<"Dept"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Dept"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Dept"> | Date | string | null
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: IntFilter<"Shop"> | number
    entityBaseId?: IntFilter<"Shop"> | number
    laltitude?: DecimalNullableFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    byId?: IntNullableFilter<"Shop"> | number | null
    entityBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    cardAllocation?: CardAllocationListRelationFilter
    userShop?: UserShopListRelationFilter
    customerAlias?: CustomerAliasListRelationFilter
    payment?: PaymentListRelationFilter
    cardRequest?: XOR<CardRequestNullableScalarRelationFilter, CardRequestWhereInput> | null
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    entityBase?: WalletBaseOrderByWithRelationInput
    cardAllocation?: CardAllocationOrderByRelationAggregateInput
    userShop?: UserShopOrderByRelationAggregateInput
    customerAlias?: CustomerAliasOrderByRelationAggregateInput
    payment?: PaymentOrderByRelationAggregateInput
    cardRequest?: CardRequestOrderByWithRelationInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    entityBaseId?: number
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    laltitude?: DecimalNullableFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Shop"> | Date | string | null
    byId?: IntNullableFilter<"Shop"> | number | null
    entityBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    cardAllocation?: CardAllocationListRelationFilter
    userShop?: UserShopListRelationFilter
    customerAlias?: CustomerAliasListRelationFilter
    payment?: PaymentListRelationFilter
    cardRequest?: XOR<CardRequestNullableScalarRelationFilter, CardRequestWhereInput> | null
  }, "id" | "entityBaseId">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shop"> | number
    entityBaseId?: IntWithAggregatesFilter<"Shop"> | number
    laltitude?: DecimalNullableWithAggregatesFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Shop"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Shop"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Shop"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"Shop"> | number | null
  }

  export type UserShopWhereInput = {
    AND?: UserShopWhereInput | UserShopWhereInput[]
    OR?: UserShopWhereInput[]
    NOT?: UserShopWhereInput | UserShopWhereInput[]
    shopId?: IntFilter<"UserShop"> | number
    userId?: IntFilter<"UserShop"> | number
    isActive?: BoolFilter<"UserShop"> | boolean
    createdAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    role?: EnumUserShopRoleEnumFilter<"UserShop"> | $Enums.UserShopRoleEnum
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserShopOrderByWithRelationInput = {
    shopId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    role?: SortOrder
    shop?: ShopOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserShopWhereUniqueInput = Prisma.AtLeast<{
    userId_shopId?: UserShopUserIdShopIdCompoundUniqueInput
    AND?: UserShopWhereInput | UserShopWhereInput[]
    OR?: UserShopWhereInput[]
    NOT?: UserShopWhereInput | UserShopWhereInput[]
    shopId?: IntFilter<"UserShop"> | number
    userId?: IntFilter<"UserShop"> | number
    isActive?: BoolFilter<"UserShop"> | boolean
    createdAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    role?: EnumUserShopRoleEnumFilter<"UserShop"> | $Enums.UserShopRoleEnum
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_shopId">

  export type UserShopOrderByWithAggregationInput = {
    shopId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: UserShopCountOrderByAggregateInput
    _avg?: UserShopAvgOrderByAggregateInput
    _max?: UserShopMaxOrderByAggregateInput
    _min?: UserShopMinOrderByAggregateInput
    _sum?: UserShopSumOrderByAggregateInput
  }

  export type UserShopScalarWhereWithAggregatesInput = {
    AND?: UserShopScalarWhereWithAggregatesInput | UserShopScalarWhereWithAggregatesInput[]
    OR?: UserShopScalarWhereWithAggregatesInput[]
    NOT?: UserShopScalarWhereWithAggregatesInput | UserShopScalarWhereWithAggregatesInput[]
    shopId?: IntWithAggregatesFilter<"UserShop"> | number
    userId?: IntWithAggregatesFilter<"UserShop"> | number
    isActive?: BoolWithAggregatesFilter<"UserShop"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"UserShop"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserShop"> | Date | string | null
    role?: EnumUserShopRoleEnumWithAggregatesFilter<"UserShop"> | $Enums.UserShopRoleEnum
  }

  export type WalletBaseWhereInput = {
    AND?: WalletBaseWhereInput | WalletBaseWhereInput[]
    OR?: WalletBaseWhereInput[]
    NOT?: WalletBaseWhereInput | WalletBaseWhereInput[]
    id?: IntFilter<"WalletBase"> | number
    type?: EnumEntityEnumFilter<"WalletBase"> | $Enums.EntityEnum
    isActive?: BoolFilter<"WalletBase"> | boolean
    fromTransaction?: TransactionListRelationFilter
    toTransaction?: TransactionListRelationFilter
    walletStatus?: WalletStatusListRelationFilter
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type WalletBaseOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    fromTransaction?: TransactionOrderByRelationAggregateInput
    toTransaction?: TransactionOrderByRelationAggregateInput
    walletStatus?: WalletStatusOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type WalletBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WalletBaseWhereInput | WalletBaseWhereInput[]
    OR?: WalletBaseWhereInput[]
    NOT?: WalletBaseWhereInput | WalletBaseWhereInput[]
    type?: EnumEntityEnumFilter<"WalletBase"> | $Enums.EntityEnum
    isActive?: BoolFilter<"WalletBase"> | boolean
    fromTransaction?: TransactionListRelationFilter
    toTransaction?: TransactionListRelationFilter
    walletStatus?: WalletStatusListRelationFilter
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type WalletBaseOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    _count?: WalletBaseCountOrderByAggregateInput
    _avg?: WalletBaseAvgOrderByAggregateInput
    _max?: WalletBaseMaxOrderByAggregateInput
    _min?: WalletBaseMinOrderByAggregateInput
    _sum?: WalletBaseSumOrderByAggregateInput
  }

  export type WalletBaseScalarWhereWithAggregatesInput = {
    AND?: WalletBaseScalarWhereWithAggregatesInput | WalletBaseScalarWhereWithAggregatesInput[]
    OR?: WalletBaseScalarWhereWithAggregatesInput[]
    NOT?: WalletBaseScalarWhereWithAggregatesInput | WalletBaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WalletBase"> | number
    type?: EnumEntityEnumWithAggregatesFilter<"WalletBase"> | $Enums.EntityEnum
    isActive?: BoolWithAggregatesFilter<"WalletBase"> | boolean
  }

  export type WalletStatusWhereInput = {
    AND?: WalletStatusWhereInput | WalletStatusWhereInput[]
    OR?: WalletStatusWhereInput[]
    NOT?: WalletStatusWhereInput | WalletStatusWhereInput[]
    id?: IntFilter<"WalletStatus"> | number
    totalDebit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntFilter<"WalletStatus"> | number
    createdAt?: DateTimeNullableFilter<"WalletStatus"> | Date | string | null
    walletBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
  }

  export type WalletStatusOrderByWithRelationInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    walletBase?: WalletBaseOrderByWithRelationInput
  }

  export type WalletStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WalletStatusWhereInput | WalletStatusWhereInput[]
    OR?: WalletStatusWhereInput[]
    NOT?: WalletStatusWhereInput | WalletStatusWhereInput[]
    totalDebit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntFilter<"WalletStatus"> | number
    createdAt?: DateTimeNullableFilter<"WalletStatus"> | Date | string | null
    walletBase?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
  }, "id">

  export type WalletStatusOrderByWithAggregationInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: WalletStatusCountOrderByAggregateInput
    _avg?: WalletStatusAvgOrderByAggregateInput
    _max?: WalletStatusMaxOrderByAggregateInput
    _min?: WalletStatusMinOrderByAggregateInput
    _sum?: WalletStatusSumOrderByAggregateInput
  }

  export type WalletStatusScalarWhereWithAggregatesInput = {
    AND?: WalletStatusScalarWhereWithAggregatesInput | WalletStatusScalarWhereWithAggregatesInput[]
    OR?: WalletStatusScalarWhereWithAggregatesInput[]
    NOT?: WalletStatusScalarWhereWithAggregatesInput | WalletStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WalletStatus"> | number
    totalDebit?: DecimalWithAggregatesFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalWithAggregatesFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntWithAggregatesFilter<"WalletStatus"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"WalletStatus"> | Date | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    fromId?: IntFilter<"Transaction"> | number
    toId?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    walletBaseId?: IntNullableFilter<"Transaction"> | number | null
    from?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    to?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    walletBaseId?: SortOrderInput | SortOrder
    from?: WalletBaseOrderByWithRelationInput
    to?: WalletBaseOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    fromId?: IntFilter<"Transaction"> | number
    toId?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    walletBaseId?: IntNullableFilter<"Transaction"> | number | null
    from?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
    to?: XOR<WalletBaseScalarRelationFilter, WalletBaseWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    walletBaseId?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    fromId?: IntWithAggregatesFilter<"Transaction"> | number
    toId?: IntWithAggregatesFilter<"Transaction"> | number
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    walletBaseId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: IntFilter<"Card"> | number
    serial?: StringFilter<"Card"> | string
    isActive?: BoolFilter<"Card"> | boolean
    createdAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    byId?: IntNullableFilter<"Card"> | number | null
    assignment?: AssignmentListRelationFilter
    cardAllocationDetail?: CardAllocationDetailListRelationFilter
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    assignment?: AssignmentOrderByRelationAggregateInput
    cardAllocationDetail?: CardAllocationDetailOrderByRelationAggregateInput
    _relevance?: CardOrderByRelevanceInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    isActive?: BoolFilter<"Card"> | boolean
    createdAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    byId?: IntNullableFilter<"Card"> | number | null
    assignment?: AssignmentListRelationFilter
    cardAllocationDetail?: CardAllocationDetailListRelationFilter
  }, "id" | "serial">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Card"> | number
    serial?: StringWithAggregatesFilter<"Card"> | string
    isActive?: BoolWithAggregatesFilter<"Card"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Card"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Card"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"Card"> | number | null
  }

  export type CardAllocationWhereInput = {
    AND?: CardAllocationWhereInput | CardAllocationWhereInput[]
    OR?: CardAllocationWhereInput[]
    NOT?: CardAllocationWhereInput | CardAllocationWhereInput[]
    id?: IntFilter<"CardAllocation"> | number
    isActive?: BoolFilter<"CardAllocation"> | boolean
    createdAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    shopId?: IntFilter<"CardAllocation"> | number
    byId?: IntNullableFilter<"CardAllocation"> | number | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    cardAllocationDetail?: CardAllocationDetailListRelationFilter
  }

  export type CardAllocationOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    shopId?: SortOrder
    byId?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    cardAllocationDetail?: CardAllocationDetailOrderByRelationAggregateInput
  }

  export type CardAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardAllocationWhereInput | CardAllocationWhereInput[]
    OR?: CardAllocationWhereInput[]
    NOT?: CardAllocationWhereInput | CardAllocationWhereInput[]
    isActive?: BoolFilter<"CardAllocation"> | boolean
    createdAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    shopId?: IntFilter<"CardAllocation"> | number
    byId?: IntNullableFilter<"CardAllocation"> | number | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    cardAllocationDetail?: CardAllocationDetailListRelationFilter
  }, "id">

  export type CardAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    shopId?: SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: CardAllocationCountOrderByAggregateInput
    _avg?: CardAllocationAvgOrderByAggregateInput
    _max?: CardAllocationMaxOrderByAggregateInput
    _min?: CardAllocationMinOrderByAggregateInput
    _sum?: CardAllocationSumOrderByAggregateInput
  }

  export type CardAllocationScalarWhereWithAggregatesInput = {
    AND?: CardAllocationScalarWhereWithAggregatesInput | CardAllocationScalarWhereWithAggregatesInput[]
    OR?: CardAllocationScalarWhereWithAggregatesInput[]
    NOT?: CardAllocationScalarWhereWithAggregatesInput | CardAllocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardAllocation"> | number
    isActive?: BoolWithAggregatesFilter<"CardAllocation"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"CardAllocation"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CardAllocation"> | Date | string | null
    shopId?: IntWithAggregatesFilter<"CardAllocation"> | number
    byId?: IntNullableWithAggregatesFilter<"CardAllocation"> | number | null
  }

  export type CardRequestWhereInput = {
    AND?: CardRequestWhereInput | CardRequestWhereInput[]
    OR?: CardRequestWhereInput[]
    NOT?: CardRequestWhereInput | CardRequestWhereInput[]
    id?: IntFilter<"CardRequest"> | number
    label?: StringFilter<"CardRequest"> | string
    isActive?: BoolFilter<"CardRequest"> | boolean
    createdAt?: DateTimeNullableFilter<"CardRequest"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardRequest"> | Date | string | null
    shopId?: IntFilter<"CardRequest"> | number
    quantity?: IntFilter<"CardRequest"> | number
    status?: EnumCardRequestEnumFilter<"CardRequest"> | $Enums.CardRequestEnum
    shopId1?: IntNullableFilter<"CardRequest"> | number | null
    byId?: IntNullableFilter<"CardRequest"> | number | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    cardrequeststatus?: XOR<CardRequestStatusNullableScalarRelationFilter, CardRequestStatusWhereInput> | null
  }

  export type CardRequestOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    shopId1?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    cardrequeststatus?: CardRequestStatusOrderByWithRelationInput
    _relevance?: CardRequestOrderByRelevanceInput
  }

  export type CardRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shopId1?: number
    AND?: CardRequestWhereInput | CardRequestWhereInput[]
    OR?: CardRequestWhereInput[]
    NOT?: CardRequestWhereInput | CardRequestWhereInput[]
    label?: StringFilter<"CardRequest"> | string
    isActive?: BoolFilter<"CardRequest"> | boolean
    createdAt?: DateTimeNullableFilter<"CardRequest"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardRequest"> | Date | string | null
    shopId?: IntFilter<"CardRequest"> | number
    quantity?: IntFilter<"CardRequest"> | number
    status?: EnumCardRequestEnumFilter<"CardRequest"> | $Enums.CardRequestEnum
    byId?: IntNullableFilter<"CardRequest"> | number | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    cardrequeststatus?: XOR<CardRequestStatusNullableScalarRelationFilter, CardRequestStatusWhereInput> | null
  }, "id" | "shopId1">

  export type CardRequestOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    shopId1?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: CardRequestCountOrderByAggregateInput
    _avg?: CardRequestAvgOrderByAggregateInput
    _max?: CardRequestMaxOrderByAggregateInput
    _min?: CardRequestMinOrderByAggregateInput
    _sum?: CardRequestSumOrderByAggregateInput
  }

  export type CardRequestScalarWhereWithAggregatesInput = {
    AND?: CardRequestScalarWhereWithAggregatesInput | CardRequestScalarWhereWithAggregatesInput[]
    OR?: CardRequestScalarWhereWithAggregatesInput[]
    NOT?: CardRequestScalarWhereWithAggregatesInput | CardRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardRequest"> | number
    label?: StringWithAggregatesFilter<"CardRequest"> | string
    isActive?: BoolWithAggregatesFilter<"CardRequest"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"CardRequest"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CardRequest"> | Date | string | null
    shopId?: IntWithAggregatesFilter<"CardRequest"> | number
    quantity?: IntWithAggregatesFilter<"CardRequest"> | number
    status?: EnumCardRequestEnumWithAggregatesFilter<"CardRequest"> | $Enums.CardRequestEnum
    shopId1?: IntNullableWithAggregatesFilter<"CardRequest"> | number | null
    byId?: IntNullableWithAggregatesFilter<"CardRequest"> | number | null
  }

  export type CardRequestStatusWhereInput = {
    AND?: CardRequestStatusWhereInput | CardRequestStatusWhereInput[]
    OR?: CardRequestStatusWhereInput[]
    NOT?: CardRequestStatusWhereInput | CardRequestStatusWhereInput[]
    id?: IntFilter<"CardRequestStatus"> | number
    status?: EnumCardRequestEnumFilter<"CardRequestStatus"> | $Enums.CardRequestEnum
    byId?: IntNullableFilter<"CardRequestStatus"> | number | null
    cardRequestId?: IntFilter<"CardRequestStatus"> | number
    comment?: StringNullableFilter<"CardRequestStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"CardRequestStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardRequestStatus"> | Date | string | null
    cardRequest?: XOR<CardRequestScalarRelationFilter, CardRequestWhereInput>
  }

  export type CardRequestStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    byId?: SortOrderInput | SortOrder
    cardRequestId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    cardRequest?: CardRequestOrderByWithRelationInput
    _relevance?: CardRequestStatusOrderByRelevanceInput
  }

  export type CardRequestStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cardRequestId?: number
    AND?: CardRequestStatusWhereInput | CardRequestStatusWhereInput[]
    OR?: CardRequestStatusWhereInput[]
    NOT?: CardRequestStatusWhereInput | CardRequestStatusWhereInput[]
    status?: EnumCardRequestEnumFilter<"CardRequestStatus"> | $Enums.CardRequestEnum
    byId?: IntNullableFilter<"CardRequestStatus"> | number | null
    comment?: StringNullableFilter<"CardRequestStatus"> | string | null
    createdAt?: DateTimeNullableFilter<"CardRequestStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardRequestStatus"> | Date | string | null
    cardRequest?: XOR<CardRequestScalarRelationFilter, CardRequestWhereInput>
  }, "id" | "cardRequestId">

  export type CardRequestStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    byId?: SortOrderInput | SortOrder
    cardRequestId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CardRequestStatusCountOrderByAggregateInput
    _avg?: CardRequestStatusAvgOrderByAggregateInput
    _max?: CardRequestStatusMaxOrderByAggregateInput
    _min?: CardRequestStatusMinOrderByAggregateInput
    _sum?: CardRequestStatusSumOrderByAggregateInput
  }

  export type CardRequestStatusScalarWhereWithAggregatesInput = {
    AND?: CardRequestStatusScalarWhereWithAggregatesInput | CardRequestStatusScalarWhereWithAggregatesInput[]
    OR?: CardRequestStatusScalarWhereWithAggregatesInput[]
    NOT?: CardRequestStatusScalarWhereWithAggregatesInput | CardRequestStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardRequestStatus"> | number
    status?: EnumCardRequestEnumWithAggregatesFilter<"CardRequestStatus"> | $Enums.CardRequestEnum
    byId?: IntNullableWithAggregatesFilter<"CardRequestStatus"> | number | null
    cardRequestId?: IntWithAggregatesFilter<"CardRequestStatus"> | number
    comment?: StringNullableWithAggregatesFilter<"CardRequestStatus"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"CardRequestStatus"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CardRequestStatus"> | Date | string | null
  }

  export type CardAllocationDetailWhereInput = {
    AND?: CardAllocationDetailWhereInput | CardAllocationDetailWhereInput[]
    OR?: CardAllocationDetailWhereInput[]
    NOT?: CardAllocationDetailWhereInput | CardAllocationDetailWhereInput[]
    cardId?: IntFilter<"CardAllocationDetail"> | number
    cardAllocationId?: IntFilter<"CardAllocationDetail"> | number
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    cardAllocation?: XOR<CardAllocationScalarRelationFilter, CardAllocationWhereInput>
  }

  export type CardAllocationDetailOrderByWithRelationInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
    card?: CardOrderByWithRelationInput
    cardAllocation?: CardAllocationOrderByWithRelationInput
  }

  export type CardAllocationDetailWhereUniqueInput = Prisma.AtLeast<{
    cardAllocationId_cardId?: CardAllocationDetailCardAllocationIdCardIdCompoundUniqueInput
    AND?: CardAllocationDetailWhereInput | CardAllocationDetailWhereInput[]
    OR?: CardAllocationDetailWhereInput[]
    NOT?: CardAllocationDetailWhereInput | CardAllocationDetailWhereInput[]
    cardId?: IntFilter<"CardAllocationDetail"> | number
    cardAllocationId?: IntFilter<"CardAllocationDetail"> | number
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
    cardAllocation?: XOR<CardAllocationScalarRelationFilter, CardAllocationWhereInput>
  }, "cardAllocationId_cardId">

  export type CardAllocationDetailOrderByWithAggregationInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
    _count?: CardAllocationDetailCountOrderByAggregateInput
    _avg?: CardAllocationDetailAvgOrderByAggregateInput
    _max?: CardAllocationDetailMaxOrderByAggregateInput
    _min?: CardAllocationDetailMinOrderByAggregateInput
    _sum?: CardAllocationDetailSumOrderByAggregateInput
  }

  export type CardAllocationDetailScalarWhereWithAggregatesInput = {
    AND?: CardAllocationDetailScalarWhereWithAggregatesInput | CardAllocationDetailScalarWhereWithAggregatesInput[]
    OR?: CardAllocationDetailScalarWhereWithAggregatesInput[]
    NOT?: CardAllocationDetailScalarWhereWithAggregatesInput | CardAllocationDetailScalarWhereWithAggregatesInput[]
    cardId?: IntWithAggregatesFilter<"CardAllocationDetail"> | number
    cardAllocationId?: IntWithAggregatesFilter<"CardAllocationDetail"> | number
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    customerId?: IntFilter<"Assignment"> | number
    cardId?: IntFilter<"Assignment"> | number
    isActive?: BoolFilter<"Assignment"> | boolean
    createdAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    byId?: IntNullableFilter<"Assignment"> | number | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }

  export type AssignmentOrderByWithRelationInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    card?: CardOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    customerId_cardId?: AssignmentCustomerIdCardIdCompoundUniqueInput
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    customerId?: IntFilter<"Assignment"> | number
    cardId?: IntFilter<"Assignment"> | number
    isActive?: BoolFilter<"Assignment"> | boolean
    createdAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    byId?: IntNullableFilter<"Assignment"> | number | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    card?: XOR<CardScalarRelationFilter, CardWhereInput>
  }, "customerId_cardId">

  export type AssignmentOrderByWithAggregationInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    customerId?: IntWithAggregatesFilter<"Assignment"> | number
    cardId?: IntWithAggregatesFilter<"Assignment"> | number
    isActive?: BoolWithAggregatesFilter<"Assignment"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: IntFilter<"Module"> | number
    name?: StringFilter<"Module"> | string
    isActive?: BoolFilter<"Module"> | boolean
    permission?: PermissionListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    permission?: PermissionOrderByRelationAggregateInput
    _relevance?: ModuleOrderByRelevanceInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    isActive?: BoolFilter<"Module"> | boolean
    permission?: PermissionListRelationFilter
  }, "id" | "name">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Module"> | number
    name?: StringWithAggregatesFilter<"Module"> | string
    isActive?: BoolWithAggregatesFilter<"Module"> | boolean
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    comment?: StringNullableFilter<"Role"> | string | null
    byId?: IntNullableFilter<"Role"> | number | null
    isActive?: BoolFilter<"Role"> | boolean
    rolePermission?: RolePermissionListRelationFilter
    login?: LoginListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    rolePermission?: RolePermissionOrderByRelationAggregateInput
    login?: LoginOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    comment?: StringNullableFilter<"Role"> | string | null
    byId?: IntNullableFilter<"Role"> | number | null
    isActive?: BoolFilter<"Role"> | boolean
    rolePermission?: RolePermissionListRelationFilter
    login?: LoginListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    comment?: StringNullableWithAggregatesFilter<"Role"> | string | null
    byId?: IntNullableWithAggregatesFilter<"Role"> | number | null
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    code?: StringFilter<"Permission"> | string
    comment?: StringNullableFilter<"Permission"> | string | null
    moduleId?: IntFilter<"Permission"> | number
    action?: EnumPermissionActionEnumFilter<"Permission"> | $Enums.PermissionActionEnum
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    byId?: IntNullableFilter<"Permission"> | number | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    rolePermission?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    comment?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    module?: ModuleOrderByWithRelationInput
    rolePermission?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    comment?: StringNullableFilter<"Permission"> | string | null
    moduleId?: IntFilter<"Permission"> | number
    action?: EnumPermissionActionEnumFilter<"Permission"> | $Enums.PermissionActionEnum
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    byId?: IntNullableFilter<"Permission"> | number | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    rolePermission?: RolePermissionListRelationFilter
  }, "id" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    comment?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    code?: StringWithAggregatesFilter<"Permission"> | string
    comment?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    moduleId?: IntWithAggregatesFilter<"Permission"> | number
    action?: EnumPermissionActionEnumWithAggregatesFilter<"Permission"> | $Enums.PermissionActionEnum
    createdAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"Permission"> | number | null
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: IntFilter<"Offer"> | number
    name?: StringFilter<"Offer"> | string
    comment?: StringNullableFilter<"Offer"> | string | null
    amount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    byId?: IntNullableFilter<"Offer"> | number | null
    duration?: IntFilter<"Offer"> | number
    payment?: PaymentListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    comment?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    duration?: SortOrder
    payment?: PaymentOrderByRelationAggregateInput
    _relevance?: OfferOrderByRelevanceInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    comment?: StringNullableFilter<"Offer"> | string | null
    amount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Offer"> | Date | string | null
    byId?: IntNullableFilter<"Offer"> | number | null
    duration?: IntFilter<"Offer"> | number
    payment?: PaymentListRelationFilter
  }, "id" | "name">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    comment?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    byId?: SortOrderInput | SortOrder
    duration?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Offer"> | number
    name?: StringWithAggregatesFilter<"Offer"> | string
    comment?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    amount?: DecimalWithAggregatesFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    byId?: IntNullableWithAggregatesFilter<"Offer"> | number | null
    duration?: IntWithAggregatesFilter<"Offer"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    shopId?: IntFilter<"Payment"> | number
    offerId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    byId?: IntFilter<"Payment"> | number
    expirationDate?: DateTimeFilter<"Payment"> | Date | string
    isActive?: BoolFilter<"Payment"> | boolean
    createdAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    shopId?: IntFilter<"Payment"> | number
    offerId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    byId?: IntFilter<"Payment"> | number
    expirationDate?: DateTimeFilter<"Payment"> | Date | string
    isActive?: BoolFilter<"Payment"> | boolean
    createdAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    offer?: XOR<OfferNullableScalarRelationFilter, OfferWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    shopId?: IntWithAggregatesFilter<"Payment"> | number
    offerId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    byId?: IntWithAggregatesFilter<"Payment"> | number
    expirationDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Payment"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type LoginCreateInput = {
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutLoginInput
    role?: RoleCreateNestedOneWithoutLoginInput
    user?: UserCreateNestedOneWithoutLoginInput
    Otp?: OtpCreateNestedManyWithoutLoginInput
  }

  export type LoginUncheckedCreateInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    roleId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerUncheckedCreateNestedOneWithoutLoginInput
    user?: UserUncheckedCreateNestedOneWithoutLoginInput
    Otp?: OtpUncheckedCreateNestedManyWithoutLoginInput
  }

  export type LoginUpdateInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutLoginNestedInput
    role?: RoleUpdateOneWithoutLoginNestedInput
    user?: UserUpdateOneWithoutLoginNestedInput
    Otp?: OtpUpdateManyWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUncheckedUpdateOneWithoutLoginNestedInput
    user?: UserUncheckedUpdateOneWithoutLoginNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutLoginNestedInput
  }

  export type LoginCreateManyInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    roleId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LoginUpdateManyMutationInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LoginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpCreateInput = {
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    login?: LoginCreateNestedOneWithoutOtpInput
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    loginId?: number | null
  }

  export type OtpUpdateInput = {
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login?: LoginUpdateOneWithoutOtpNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OtpCreateManyInput = {
    id?: number
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    loginId?: number | null
  }

  export type OtpUpdateManyMutationInput = {
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    login?: LoginCreateNestedOneWithoutUserInput
    userShop?: UserShopCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    loginId?: number | null
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    login?: LoginUpdateOneWithoutUserNestedInput
    userShop?: UserShopUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    loginId?: number | null
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
  }

  export type UserUpdateManyMutationInput = {
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CustomerCreateInput = {
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    Login?: LoginCreateNestedOneWithoutCustomerInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutCustomerInput
    WalletBase: WalletBaseCreateNestedOneWithoutCustomerInput
    assignment?: AssignmentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    loginId?: number | null
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    entityBaseId: number
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutCustomerInput
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Login?: LoginUpdateOneWithoutCustomerNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutCustomerNestedInput
    WalletBase?: WalletBaseUpdateOneRequiredWithoutCustomerNestedInput
    assignment?: AssignmentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityBaseId?: IntFieldUpdateOperationsInput | number
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutCustomerNestedInput
    assignment?: AssignmentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    loginId?: number | null
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    entityBaseId: number
  }

  export type CustomerUpdateManyMutationInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityBaseId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerAliasCreateInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    shop: ShopCreateNestedOneWithoutCustomerAliasInput
    customer: CustomerCreateNestedOneWithoutCustomerAliasInput
    dept?: DeptCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUncheckedCreateInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
    dept?: DeptUncheckedCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusUncheckedCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shop?: ShopUpdateOneRequiredWithoutCustomerAliasNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCustomerAliasNestedInput
    dept?: DeptUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dept?: DeptUncheckedUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUncheckedUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasCreateManyInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
  }

  export type CustomerAliasUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerAliasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DebtStatusCreateInput = {
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customerAlias: CustomerAliasCreateNestedOneWithoutDebtStatusInput
  }

  export type DebtStatusUncheckedCreateInput = {
    id?: number
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customerAliasId: number
  }

  export type DebtStatusUpdateInput = {
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAlias?: CustomerAliasUpdateOneRequiredWithoutDebtStatusNestedInput
  }

  export type DebtStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAliasId?: IntFieldUpdateOperationsInput | number
  }

  export type DebtStatusCreateManyInput = {
    id?: number
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customerAliasId: number
  }

  export type DebtStatusUpdateManyMutationInput = {
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DebtStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAliasId?: IntFieldUpdateOperationsInput | number
  }

  export type DeptCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customerAlias: CustomerAliasCreateNestedOneWithoutDeptInput
  }

  export type DeptUncheckedCreateInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    customerAliasId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DeptUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAlias?: CustomerAliasUpdateOneRequiredWithoutDeptNestedInput
  }

  export type DeptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    customerAliasId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeptCreateManyInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    customerAliasId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DeptUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    customerAliasId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCreateInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopUpdateInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type ShopUpdateManyMutationInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserShopCreateInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
    shop: ShopCreateNestedOneWithoutUserShopInput
    user: UserCreateNestedOneWithoutUserShopInput
  }

  export type UserShopUncheckedCreateInput = {
    shopId: number
    userId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type UserShopUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
    shop?: ShopUpdateOneRequiredWithoutUserShopNestedInput
    user?: UserUpdateOneRequiredWithoutUserShopNestedInput
  }

  export type UserShopUncheckedUpdateInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type UserShopCreateManyInput = {
    shopId: number
    userId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type UserShopUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type UserShopUncheckedUpdateManyInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type WalletBaseCreateInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionCreateNestedManyWithoutFromInput
    toTransaction?: TransactionCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusCreateNestedManyWithoutWalletBaseInput
    shop?: ShopCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUncheckedCreateInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionUncheckedCreateNestedManyWithoutFromInput
    toTransaction?: TransactionUncheckedCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput
    shop?: ShopUncheckedCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerUncheckedCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUpdateInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUncheckedUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUncheckedUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUncheckedUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseCreateManyInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
  }

  export type WalletBaseUpdateManyMutationInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WalletBaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WalletStatusCreateInput = {
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    walletBase: WalletBaseCreateNestedOneWithoutWalletStatusInput
  }

  export type WalletStatusUncheckedCreateInput = {
    id?: number
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    walletBaseId: number
    createdAt?: Date | string | null
  }

  export type WalletStatusUpdateInput = {
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBase?: WalletBaseUpdateOneRequiredWithoutWalletStatusNestedInput
  }

  export type WalletStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletStatusCreateManyInput = {
    id?: number
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    walletBaseId: number
    createdAt?: Date | string | null
  }

  export type WalletStatusUpdateManyMutationInput = {
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
    from: WalletBaseCreateNestedOneWithoutFromTransactionInput
    to: WalletBaseCreateNestedOneWithoutToTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    fromId: number
    toId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type TransactionUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
    from?: WalletBaseUpdateOneRequiredWithoutFromTransactionNestedInput
    to?: WalletBaseUpdateOneRequiredWithoutToTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionCreateManyInput = {
    id?: number
    fromId: number
    toId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type TransactionUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardCreateInput = {
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    assignment?: AssignmentCreateNestedManyWithoutCardInput
    cardAllocationDetail?: CardAllocationDetailCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateInput = {
    id?: number
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCardInput
    cardAllocationDetail?: CardAllocationDetailUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    assignment?: AssignmentUpdateManyWithoutCardNestedInput
    cardAllocationDetail?: CardAllocationDetailUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    assignment?: AssignmentUncheckedUpdateManyWithoutCardNestedInput
    cardAllocationDetail?: CardAllocationDetailUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardCreateManyInput = {
    id?: number
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type CardUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardAllocationCreateInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shop: ShopCreateNestedOneWithoutCardAllocationInput
    cardAllocationDetail?: CardAllocationDetailCreateNestedManyWithoutCardAllocationInput
  }

  export type CardAllocationUncheckedCreateInput = {
    id?: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    byId?: number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedCreateNestedManyWithoutCardAllocationInput
  }

  export type CardAllocationUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shop?: ShopUpdateOneRequiredWithoutCardAllocationNestedInput
    cardAllocationDetail?: CardAllocationDetailUpdateManyWithoutCardAllocationNestedInput
  }

  export type CardAllocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedUpdateManyWithoutCardAllocationNestedInput
  }

  export type CardAllocationCreateManyInput = {
    id?: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    byId?: number | null
  }

  export type CardAllocationUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardAllocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardRequestCreateInput = {
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    shop?: ShopCreateNestedOneWithoutCardRequestInput
    cardrequeststatus?: CardRequestStatusCreateNestedOneWithoutCardRequestInput
  }

  export type CardRequestUncheckedCreateInput = {
    id?: number
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    shopId1?: number | null
    byId?: number | null
    cardrequeststatus?: CardRequestStatusUncheckedCreateNestedOneWithoutCardRequestInput
  }

  export type CardRequestUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shop?: ShopUpdateOneWithoutCardRequestNestedInput
    cardrequeststatus?: CardRequestStatusUpdateOneWithoutCardRequestNestedInput
  }

  export type CardRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    shopId1?: NullableIntFieldUpdateOperationsInput | number | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardrequeststatus?: CardRequestStatusUncheckedUpdateOneWithoutCardRequestNestedInput
  }

  export type CardRequestCreateManyInput = {
    id?: number
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    shopId1?: number | null
    byId?: number | null
  }

  export type CardRequestUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    shopId1?: NullableIntFieldUpdateOperationsInput | number | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardRequestStatusCreateInput = {
    status: $Enums.CardRequestEnum
    byId?: number | null
    comment?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    cardRequest: CardRequestCreateNestedOneWithoutCardrequeststatusInput
  }

  export type CardRequestStatusUncheckedCreateInput = {
    id?: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    cardRequestId: number
    comment?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CardRequestStatusUpdateInput = {
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cardRequest?: CardRequestUpdateOneRequiredWithoutCardrequeststatusNestedInput
  }

  export type CardRequestStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardRequestId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardRequestStatusCreateManyInput = {
    id?: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    cardRequestId: number
    comment?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CardRequestStatusUpdateManyMutationInput = {
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardRequestStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardRequestId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardAllocationDetailCreateInput = {
    card: CardCreateNestedOneWithoutCardAllocationDetailInput
    cardAllocation: CardAllocationCreateNestedOneWithoutCardAllocationDetailInput
  }

  export type CardAllocationDetailUncheckedCreateInput = {
    cardId: number
    cardAllocationId: number
  }

  export type CardAllocationDetailUpdateInput = {
    card?: CardUpdateOneRequiredWithoutCardAllocationDetailNestedInput
    cardAllocation?: CardAllocationUpdateOneRequiredWithoutCardAllocationDetailNestedInput
  }

  export type CardAllocationDetailUncheckedUpdateInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    cardAllocationId?: IntFieldUpdateOperationsInput | number
  }

  export type CardAllocationDetailCreateManyInput = {
    cardId: number
    cardAllocationId: number
  }

  export type CardAllocationDetailUpdateManyMutationInput = {

  }

  export type CardAllocationDetailUncheckedUpdateManyInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    cardAllocationId?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentCreateInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    customer: CustomerCreateNestedOneWithoutAssignmentInput
    card: CardCreateNestedOneWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    customerId: number
    cardId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type AssignmentUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: CustomerUpdateOneRequiredWithoutAssignmentNestedInput
    card?: CardUpdateOneRequiredWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignmentCreateManyInput = {
    customerId: number
    cardId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type AssignmentUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignmentUncheckedUpdateManyInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ModuleCreateInput = {
    name: string
    isActive?: boolean
    permission?: PermissionCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    permission?: PermissionUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permission?: PermissionUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permission?: PermissionUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
  }

  export type ModuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleCreateInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    rolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
    login?: LoginCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    login?: LoginUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
    login?: LoginUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    login?: LoginUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionCreateInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
    permission: PermissionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionCreateManyInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionCreateInput = {
    code: string
    comment?: string | null
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    module: ModuleCreateNestedOneWithoutPermissionInput
    rolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    code: string
    comment?: string | null
    moduleId: number
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    module?: ModuleUpdateOneRequiredWithoutPermissionNestedInput
    rolePermission?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: IntFieldUpdateOperationsInput | number
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    code: string
    comment?: string | null
    moduleId: number
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type PermissionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: IntFieldUpdateOperationsInput | number
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OfferCreateInput = {
    name: string
    comment?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    duration: number
    payment?: PaymentCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: number
    name: string
    comment?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    duration: number
    payment?: PaymentUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    payment?: PaymentUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    payment?: PaymentUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: number
    name: string
    comment?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    duration: number
  }

  export type OfferUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shop: ShopCreateNestedOneWithoutPaymentInput
    offer?: OfferCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    shopId: number
    offerId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneRequiredWithoutPaymentNestedInput
    offer?: OfferUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    offerId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: number
    shopId: number
    offerId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    offerId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumLoginEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginEnum | EnumLoginEnumFieldRefInput<$PrismaModel>
    in?: $Enums.LoginEnum[]
    notIn?: $Enums.LoginEnum[]
    not?: NestedEnumLoginEnumFilter<$PrismaModel> | $Enums.LoginEnum
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginOrderByRelevanceInput = {
    fields: LoginOrderByRelevanceFieldEnum | LoginOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LoginTypeUsernameCompoundUniqueInput = {
    type: $Enums.LoginEnum
    username: string
  }

  export type LoginCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type LoginMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLoginEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginEnum | EnumLoginEnumFieldRefInput<$PrismaModel>
    in?: $Enums.LoginEnum[]
    notIn?: $Enums.LoginEnum[]
    not?: NestedEnumLoginEnumWithAggregatesFilter<$PrismaModel> | $Enums.LoginEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginEnumFilter<$PrismaModel>
    _max?: NestedEnumLoginEnumFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumOptDurationEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OptDurationEnum | EnumOptDurationEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptDurationEnum[]
    notIn?: $Enums.OptDurationEnum[]
    not?: NestedEnumOptDurationEnumFilter<$PrismaModel> | $Enums.OptDurationEnum
  }

  export type EnumOptViaEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OptViaEnum | EnumOptViaEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptViaEnum[]
    notIn?: $Enums.OptViaEnum[]
    not?: NestedEnumOptViaEnumFilter<$PrismaModel> | $Enums.OptViaEnum
  }

  export type LoginNullableScalarRelationFilter = {
    is?: LoginWhereInput | null
    isNot?: LoginWhereInput | null
  }

  export type OtpOrderByRelevanceInput = {
    fields: OtpOrderByRelevanceFieldEnum | OtpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loginId?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loginId?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loginId?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumOptDurationEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptDurationEnum | EnumOptDurationEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptDurationEnum[]
    notIn?: $Enums.OptDurationEnum[]
    not?: NestedEnumOptDurationEnumWithAggregatesFilter<$PrismaModel> | $Enums.OptDurationEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptDurationEnumFilter<$PrismaModel>
    _max?: NestedEnumOptDurationEnumFilter<$PrismaModel>
  }

  export type EnumOptViaEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptViaEnum | EnumOptViaEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptViaEnum[]
    notIn?: $Enums.OptViaEnum[]
    not?: NestedEnumOptViaEnumWithAggregatesFilter<$PrismaModel> | $Enums.OptViaEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptViaEnumFilter<$PrismaModel>
    _max?: NestedEnumOptViaEnumFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserShopListRelationFilter = {
    every?: UserShopWhereInput
    some?: UserShopWhereInput
    none?: UserShopWhereInput
  }

  export type UserShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CustomerAliasListRelationFilter = {
    every?: CustomerAliasWhereInput
    some?: CustomerAliasWhereInput
    none?: CustomerAliasWhereInput
  }

  export type WalletBaseScalarRelationFilter = {
    is?: WalletBaseWhereInput
    isNot?: WalletBaseWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type CustomerAliasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    dateOfBirth?: SortOrder
    entityBaseId?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    entityBaseId?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    dateOfBirth?: SortOrder
    entityBaseId?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    dateOfBirth?: SortOrder
    entityBaseId?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    entityBaseId?: SortOrder
  }

  export type ShopScalarRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type DeptListRelationFilter = {
    every?: DeptWhereInput
    some?: DeptWhereInput
    none?: DeptWhereInput
  }

  export type DebtStatusListRelationFilter = {
    every?: DebtStatusWhereInput
    some?: DebtStatusWhereInput
    none?: DebtStatusWhereInput
  }

  export type DeptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerAliasCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    shopId?: SortOrder
    isActive?: SortOrder
  }

  export type CustomerAliasAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    byId?: SortOrder
    shopId?: SortOrder
  }

  export type CustomerAliasMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    shopId?: SortOrder
    isActive?: SortOrder
  }

  export type CustomerAliasMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    shopId?: SortOrder
    isActive?: SortOrder
  }

  export type CustomerAliasSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    byId?: SortOrder
    shopId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerAliasScalarRelationFilter = {
    is?: CustomerAliasWhereInput
    isNot?: CustomerAliasWhereInput
  }

  export type DebtStatusCountOrderByAggregateInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DebtStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DebtStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DebtStatusMinOrderByAggregateInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DebtStatusSumOrderByAggregateInput = {
    id?: SortOrder
    totalCredit?: SortOrder
    totalDebut?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTransactionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[]
    notIn?: $Enums.TransactionTypeEnum[]
    not?: NestedEnumTransactionTypeEnumFilter<$PrismaModel> | $Enums.TransactionTypeEnum
  }

  export type DeptOrderByRelevanceInput = {
    fields: DeptOrderByRelevanceFieldEnum | DeptOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeptCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    customerAliasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeptAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customerAliasId?: SortOrder
  }

  export type DeptMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    customerAliasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeptMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    customerAliasId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeptSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customerAliasId?: SortOrder
  }

  export type EnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[]
    notIn?: $Enums.TransactionTypeEnum[]
    not?: NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
  }

  export type CardAllocationListRelationFilter = {
    every?: CardAllocationWhereInput
    some?: CardAllocationWhereInput
    none?: CardAllocationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CardRequestNullableScalarRelationFilter = {
    is?: CardRequestWhereInput | null
    isNot?: CardRequestWhereInput | null
  }

  export type CardAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    byId?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    id?: SortOrder
    entityBaseId?: SortOrder
    laltitude?: SortOrder
    longitude?: SortOrder
    byId?: SortOrder
  }

  export type EnumUserShopRoleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserShopRoleEnum | EnumUserShopRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserShopRoleEnum[]
    notIn?: $Enums.UserShopRoleEnum[]
    not?: NestedEnumUserShopRoleEnumFilter<$PrismaModel> | $Enums.UserShopRoleEnum
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserShopUserIdShopIdCompoundUniqueInput = {
    userId: number
    shopId: number
  }

  export type UserShopCountOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserShopAvgOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
  }

  export type UserShopMaxOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserShopMinOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserShopSumOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
  }

  export type EnumUserShopRoleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserShopRoleEnum | EnumUserShopRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserShopRoleEnum[]
    notIn?: $Enums.UserShopRoleEnum[]
    not?: NestedEnumUserShopRoleEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserShopRoleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserShopRoleEnumFilter<$PrismaModel>
    _max?: NestedEnumUserShopRoleEnumFilter<$PrismaModel>
  }

  export type EnumEntityEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityEnum | EnumEntityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EntityEnum[]
    notIn?: $Enums.EntityEnum[]
    not?: NestedEnumEntityEnumFilter<$PrismaModel> | $Enums.EntityEnum
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type WalletStatusListRelationFilter = {
    every?: WalletStatusWhereInput
    some?: WalletStatusWhereInput
    none?: WalletStatusWhereInput
  }

  export type ShopNullableScalarRelationFilter = {
    is?: ShopWhereInput | null
    isNot?: ShopWhereInput | null
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletBaseCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
  }

  export type WalletBaseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WalletBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
  }

  export type WalletBaseMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
  }

  export type WalletBaseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEntityEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityEnum | EnumEntityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EntityEnum[]
    notIn?: $Enums.EntityEnum[]
    not?: NestedEnumEntityEnumWithAggregatesFilter<$PrismaModel> | $Enums.EntityEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityEnumFilter<$PrismaModel>
    _max?: NestedEnumEntityEnumFilter<$PrismaModel>
  }

  export type WalletStatusCountOrderByAggregateInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
  }

  export type WalletStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletStatusMinOrderByAggregateInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletStatusSumOrderByAggregateInput = {
    id?: SortOrder
    totalDebit?: SortOrder
    totalCredit?: SortOrder
    walletBaseId?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletBaseId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    walletBaseId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletBaseId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletBaseId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    amount?: SortOrder
    walletBaseId?: SortOrder
  }

  export type CardAllocationDetailListRelationFilter = {
    every?: CardAllocationDetailWhereInput
    some?: CardAllocationDetailWhereInput
    none?: CardAllocationDetailWhereInput
  }

  export type CardAllocationDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardOrderByRelevanceInput = {
    fields: CardOrderByRelevanceFieldEnum | CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
  }

  export type CardAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    byId?: SortOrder
  }

  export type CardAllocationAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    byId?: SortOrder
  }

  export type CardAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    byId?: SortOrder
  }

  export type CardAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    byId?: SortOrder
  }

  export type CardAllocationSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    byId?: SortOrder
  }

  export type EnumCardRequestEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRequestEnum | EnumCardRequestEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CardRequestEnum[]
    notIn?: $Enums.CardRequestEnum[]
    not?: NestedEnumCardRequestEnumFilter<$PrismaModel> | $Enums.CardRequestEnum
  }

  export type CardRequestStatusNullableScalarRelationFilter = {
    is?: CardRequestStatusWhereInput | null
    isNot?: CardRequestStatusWhereInput | null
  }

  export type CardRequestOrderByRelevanceInput = {
    fields: CardRequestOrderByRelevanceFieldEnum | CardRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CardRequestCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    shopId1?: SortOrder
    byId?: SortOrder
  }

  export type CardRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    shopId1?: SortOrder
    byId?: SortOrder
  }

  export type CardRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    shopId1?: SortOrder
    byId?: SortOrder
  }

  export type CardRequestMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    shopId1?: SortOrder
    byId?: SortOrder
  }

  export type CardRequestSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    quantity?: SortOrder
    shopId1?: SortOrder
    byId?: SortOrder
  }

  export type EnumCardRequestEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRequestEnum | EnumCardRequestEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CardRequestEnum[]
    notIn?: $Enums.CardRequestEnum[]
    not?: NestedEnumCardRequestEnumWithAggregatesFilter<$PrismaModel> | $Enums.CardRequestEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardRequestEnumFilter<$PrismaModel>
    _max?: NestedEnumCardRequestEnumFilter<$PrismaModel>
  }

  export type CardRequestScalarRelationFilter = {
    is?: CardRequestWhereInput
    isNot?: CardRequestWhereInput
  }

  export type CardRequestStatusOrderByRelevanceInput = {
    fields: CardRequestStatusOrderByRelevanceFieldEnum | CardRequestStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CardRequestStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    byId?: SortOrder
    cardRequestId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardRequestStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
    cardRequestId?: SortOrder
  }

  export type CardRequestStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    byId?: SortOrder
    cardRequestId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardRequestStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    byId?: SortOrder
    cardRequestId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardRequestStatusSumOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
    cardRequestId?: SortOrder
  }

  export type CardScalarRelationFilter = {
    is?: CardWhereInput
    isNot?: CardWhereInput
  }

  export type CardAllocationScalarRelationFilter = {
    is?: CardAllocationWhereInput
    isNot?: CardAllocationWhereInput
  }

  export type CardAllocationDetailCardAllocationIdCardIdCompoundUniqueInput = {
    cardAllocationId: number
    cardId: number
  }

  export type CardAllocationDetailCountOrderByAggregateInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
  }

  export type CardAllocationDetailAvgOrderByAggregateInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
  }

  export type CardAllocationDetailMaxOrderByAggregateInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
  }

  export type CardAllocationDetailMinOrderByAggregateInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
  }

  export type CardAllocationDetailSumOrderByAggregateInput = {
    cardId?: SortOrder
    cardAllocationId?: SortOrder
  }

  export type AssignmentCustomerIdCardIdCompoundUniqueInput = {
    customerId: number
    cardId: number
  }

  export type AssignmentCountOrderByAggregateInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    byId?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    customerId?: SortOrder
    cardId?: SortOrder
    byId?: SortOrder
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelevanceInput = {
    fields: ModuleOrderByRelevanceFieldEnum | ModuleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type LoginListRelationFilter = {
    every?: LoginWhereInput
    some?: LoginWhereInput
    none?: LoginWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    byId?: SortOrder
    isActive?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    byId?: SortOrder
    isActive?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: SortOrder
    byId?: SortOrder
    isActive?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
    byId?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type EnumPermissionActionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionActionEnum | EnumPermissionActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionActionEnum[]
    notIn?: $Enums.PermissionActionEnum[]
    not?: NestedEnumPermissionActionEnumFilter<$PrismaModel> | $Enums.PermissionActionEnum
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    comment?: SortOrder
    moduleId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    byId?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    comment?: SortOrder
    moduleId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    comment?: SortOrder
    moduleId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    byId?: SortOrder
  }

  export type EnumPermissionActionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionActionEnum | EnumPermissionActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionActionEnum[]
    notIn?: $Enums.PermissionActionEnum[]
    not?: NestedEnumPermissionActionEnumWithAggregatesFilter<$PrismaModel> | $Enums.PermissionActionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionActionEnumFilter<$PrismaModel>
    _max?: NestedEnumPermissionActionEnumFilter<$PrismaModel>
  }

  export type OfferOrderByRelevanceInput = {
    fields: OfferOrderByRelevanceFieldEnum | OfferOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    comment?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    duration?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    duration?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    comment?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    duration?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    comment?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    byId?: SortOrder
    duration?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    duration?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OfferNullableScalarRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
    expirationDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    offerId?: SortOrder
    amount?: SortOrder
    byId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerCreateNestedOneWithoutLoginInput = {
    create?: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoginInput
    connect?: CustomerWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutLoginInput = {
    create?: XOR<RoleCreateWithoutLoginInput, RoleUncheckedCreateWithoutLoginInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLoginInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLoginInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    connect?: UserWhereUniqueInput
  }

  export type OtpCreateNestedManyWithoutLoginInput = {
    create?: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput> | OtpCreateWithoutLoginInput[] | OtpUncheckedCreateWithoutLoginInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutLoginInput | OtpCreateOrConnectWithoutLoginInput[]
    createMany?: OtpCreateManyLoginInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedOneWithoutLoginInput = {
    create?: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoginInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserUncheckedCreateNestedOneWithoutLoginInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    connect?: UserWhereUniqueInput
  }

  export type OtpUncheckedCreateNestedManyWithoutLoginInput = {
    create?: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput> | OtpCreateWithoutLoginInput[] | OtpUncheckedCreateWithoutLoginInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutLoginInput | OtpCreateOrConnectWithoutLoginInput[]
    createMany?: OtpCreateManyLoginInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type EnumLoginEnumFieldUpdateOperationsInput = {
    set?: $Enums.LoginEnum
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneWithoutLoginNestedInput = {
    create?: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoginInput
    upsert?: CustomerUpsertWithoutLoginInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLoginInput, CustomerUpdateWithoutLoginInput>, CustomerUncheckedUpdateWithoutLoginInput>
  }

  export type RoleUpdateOneWithoutLoginNestedInput = {
    create?: XOR<RoleCreateWithoutLoginInput, RoleUncheckedCreateWithoutLoginInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLoginInput
    upsert?: RoleUpsertWithoutLoginInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutLoginInput, RoleUpdateWithoutLoginInput>, RoleUncheckedUpdateWithoutLoginInput>
  }

  export type UserUpdateOneWithoutLoginNestedInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    upsert?: UserUpsertWithoutLoginInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginInput, UserUpdateWithoutLoginInput>, UserUncheckedUpdateWithoutLoginInput>
  }

  export type OtpUpdateManyWithoutLoginNestedInput = {
    create?: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput> | OtpCreateWithoutLoginInput[] | OtpUncheckedCreateWithoutLoginInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutLoginInput | OtpCreateOrConnectWithoutLoginInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutLoginInput | OtpUpsertWithWhereUniqueWithoutLoginInput[]
    createMany?: OtpCreateManyLoginInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutLoginInput | OtpUpdateWithWhereUniqueWithoutLoginInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutLoginInput | OtpUpdateManyWithWhereWithoutLoginInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUncheckedUpdateOneWithoutLoginNestedInput = {
    create?: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoginInput
    upsert?: CustomerUpsertWithoutLoginInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLoginInput, CustomerUpdateWithoutLoginInput>, CustomerUncheckedUpdateWithoutLoginInput>
  }

  export type UserUncheckedUpdateOneWithoutLoginNestedInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    upsert?: UserUpsertWithoutLoginInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginInput, UserUpdateWithoutLoginInput>, UserUncheckedUpdateWithoutLoginInput>
  }

  export type OtpUncheckedUpdateManyWithoutLoginNestedInput = {
    create?: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput> | OtpCreateWithoutLoginInput[] | OtpUncheckedCreateWithoutLoginInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutLoginInput | OtpCreateOrConnectWithoutLoginInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutLoginInput | OtpUpsertWithWhereUniqueWithoutLoginInput[]
    createMany?: OtpCreateManyLoginInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutLoginInput | OtpUpdateWithWhereUniqueWithoutLoginInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutLoginInput | OtpUpdateManyWithWhereWithoutLoginInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type LoginCreateNestedOneWithoutOtpInput = {
    create?: XOR<LoginCreateWithoutOtpInput, LoginUncheckedCreateWithoutOtpInput>
    connectOrCreate?: LoginCreateOrConnectWithoutOtpInput
    connect?: LoginWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumOptDurationEnumFieldUpdateOperationsInput = {
    set?: $Enums.OptDurationEnum
  }

  export type EnumOptViaEnumFieldUpdateOperationsInput = {
    set?: $Enums.OptViaEnum
  }

  export type LoginUpdateOneWithoutOtpNestedInput = {
    create?: XOR<LoginCreateWithoutOtpInput, LoginUncheckedCreateWithoutOtpInput>
    connectOrCreate?: LoginCreateOrConnectWithoutOtpInput
    upsert?: LoginUpsertWithoutOtpInput
    disconnect?: LoginWhereInput | boolean
    delete?: LoginWhereInput | boolean
    connect?: LoginWhereUniqueInput
    update?: XOR<XOR<LoginUpdateToOneWithWhereWithoutOtpInput, LoginUpdateWithoutOtpInput>, LoginUncheckedUpdateWithoutOtpInput>
  }

  export type LoginCreateNestedOneWithoutUserInput = {
    create?: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUserInput
    connect?: LoginWhereUniqueInput
  }

  export type UserShopCreateNestedManyWithoutUserInput = {
    create?: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput> | UserShopCreateWithoutUserInput[] | UserShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutUserInput | UserShopCreateOrConnectWithoutUserInput[]
    createMany?: UserShopCreateManyUserInputEnvelope
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
  }

  export type UserShopUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput> | UserShopCreateWithoutUserInput[] | UserShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutUserInput | UserShopCreateOrConnectWithoutUserInput[]
    createMany?: UserShopCreateManyUserInputEnvelope
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LoginUpdateOneWithoutUserNestedInput = {
    create?: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUserInput
    upsert?: LoginUpsertWithoutUserInput
    disconnect?: LoginWhereInput | boolean
    delete?: LoginWhereInput | boolean
    connect?: LoginWhereUniqueInput
    update?: XOR<XOR<LoginUpdateToOneWithWhereWithoutUserInput, LoginUpdateWithoutUserInput>, LoginUncheckedUpdateWithoutUserInput>
  }

  export type UserShopUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput> | UserShopCreateWithoutUserInput[] | UserShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutUserInput | UserShopCreateOrConnectWithoutUserInput[]
    upsert?: UserShopUpsertWithWhereUniqueWithoutUserInput | UserShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserShopCreateManyUserInputEnvelope
    set?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    disconnect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    delete?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    update?: UserShopUpdateWithWhereUniqueWithoutUserInput | UserShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserShopUpdateManyWithWhereWithoutUserInput | UserShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
  }

  export type UserShopUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput> | UserShopCreateWithoutUserInput[] | UserShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutUserInput | UserShopCreateOrConnectWithoutUserInput[]
    upsert?: UserShopUpsertWithWhereUniqueWithoutUserInput | UserShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserShopCreateManyUserInputEnvelope
    set?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    disconnect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    delete?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    update?: UserShopUpdateWithWhereUniqueWithoutUserInput | UserShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserShopUpdateManyWithWhereWithoutUserInput | UserShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
  }

  export type LoginCreateNestedOneWithoutCustomerInput = {
    create?: XOR<LoginCreateWithoutCustomerInput, LoginUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: LoginCreateOrConnectWithoutCustomerInput
    connect?: LoginWhereUniqueInput
  }

  export type CustomerAliasCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput> | CustomerAliasCreateWithoutCustomerInput[] | CustomerAliasUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutCustomerInput | CustomerAliasCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAliasCreateManyCustomerInputEnvelope
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
  }

  export type WalletBaseCreateNestedOneWithoutCustomerInput = {
    create?: XOR<WalletBaseCreateWithoutCustomerInput, WalletBaseUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutCustomerInput
    connect?: WalletBaseWhereUniqueInput
  }

  export type AssignmentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput> | AssignmentCreateWithoutCustomerInput[] | AssignmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCustomerInput | AssignmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AssignmentCreateManyCustomerInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CustomerAliasUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput> | CustomerAliasCreateWithoutCustomerInput[] | CustomerAliasUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutCustomerInput | CustomerAliasCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAliasCreateManyCustomerInputEnvelope
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput> | AssignmentCreateWithoutCustomerInput[] | AssignmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCustomerInput | AssignmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AssignmentCreateManyCustomerInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type LoginUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<LoginCreateWithoutCustomerInput, LoginUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: LoginCreateOrConnectWithoutCustomerInput
    upsert?: LoginUpsertWithoutCustomerInput
    disconnect?: LoginWhereInput | boolean
    delete?: LoginWhereInput | boolean
    connect?: LoginWhereUniqueInput
    update?: XOR<XOR<LoginUpdateToOneWithWhereWithoutCustomerInput, LoginUpdateWithoutCustomerInput>, LoginUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAliasUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput> | CustomerAliasCreateWithoutCustomerInput[] | CustomerAliasUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutCustomerInput | CustomerAliasCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAliasUpsertWithWhereUniqueWithoutCustomerInput | CustomerAliasUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAliasCreateManyCustomerInputEnvelope
    set?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    disconnect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    delete?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    update?: CustomerAliasUpdateWithWhereUniqueWithoutCustomerInput | CustomerAliasUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAliasUpdateManyWithWhereWithoutCustomerInput | CustomerAliasUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
  }

  export type WalletBaseUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<WalletBaseCreateWithoutCustomerInput, WalletBaseUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutCustomerInput
    upsert?: WalletBaseUpsertWithoutCustomerInput
    connect?: WalletBaseWhereUniqueInput
    update?: XOR<XOR<WalletBaseUpdateToOneWithWhereWithoutCustomerInput, WalletBaseUpdateWithoutCustomerInput>, WalletBaseUncheckedUpdateWithoutCustomerInput>
  }

  export type AssignmentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput> | AssignmentCreateWithoutCustomerInput[] | AssignmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCustomerInput | AssignmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutCustomerInput | AssignmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AssignmentCreateManyCustomerInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutCustomerInput | AssignmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutCustomerInput | AssignmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CustomerAliasUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput> | CustomerAliasCreateWithoutCustomerInput[] | CustomerAliasUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutCustomerInput | CustomerAliasCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAliasUpsertWithWhereUniqueWithoutCustomerInput | CustomerAliasUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAliasCreateManyCustomerInputEnvelope
    set?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    disconnect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    delete?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    update?: CustomerAliasUpdateWithWhereUniqueWithoutCustomerInput | CustomerAliasUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAliasUpdateManyWithWhereWithoutCustomerInput | CustomerAliasUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput> | AssignmentCreateWithoutCustomerInput[] | AssignmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCustomerInput | AssignmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutCustomerInput | AssignmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AssignmentCreateManyCustomerInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutCustomerInput | AssignmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutCustomerInput | AssignmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutCustomerAliasInput = {
    create?: XOR<ShopCreateWithoutCustomerAliasInput, ShopUncheckedCreateWithoutCustomerAliasInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCustomerAliasInput
    connect?: ShopWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCustomerAliasInput = {
    create?: XOR<CustomerCreateWithoutCustomerAliasInput, CustomerUncheckedCreateWithoutCustomerAliasInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAliasInput
    connect?: CustomerWhereUniqueInput
  }

  export type DeptCreateNestedManyWithoutCustomerAliasInput = {
    create?: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput> | DeptCreateWithoutCustomerAliasInput[] | DeptUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DeptCreateOrConnectWithoutCustomerAliasInput | DeptCreateOrConnectWithoutCustomerAliasInput[]
    createMany?: DeptCreateManyCustomerAliasInputEnvelope
    connect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
  }

  export type DebtStatusCreateNestedManyWithoutCustomerAliasInput = {
    create?: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput> | DebtStatusCreateWithoutCustomerAliasInput[] | DebtStatusUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DebtStatusCreateOrConnectWithoutCustomerAliasInput | DebtStatusCreateOrConnectWithoutCustomerAliasInput[]
    createMany?: DebtStatusCreateManyCustomerAliasInputEnvelope
    connect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
  }

  export type DeptUncheckedCreateNestedManyWithoutCustomerAliasInput = {
    create?: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput> | DeptCreateWithoutCustomerAliasInput[] | DeptUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DeptCreateOrConnectWithoutCustomerAliasInput | DeptCreateOrConnectWithoutCustomerAliasInput[]
    createMany?: DeptCreateManyCustomerAliasInputEnvelope
    connect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
  }

  export type DebtStatusUncheckedCreateNestedManyWithoutCustomerAliasInput = {
    create?: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput> | DebtStatusCreateWithoutCustomerAliasInput[] | DebtStatusUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DebtStatusCreateOrConnectWithoutCustomerAliasInput | DebtStatusCreateOrConnectWithoutCustomerAliasInput[]
    createMany?: DebtStatusCreateManyCustomerAliasInputEnvelope
    connect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
  }

  export type ShopUpdateOneRequiredWithoutCustomerAliasNestedInput = {
    create?: XOR<ShopCreateWithoutCustomerAliasInput, ShopUncheckedCreateWithoutCustomerAliasInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCustomerAliasInput
    upsert?: ShopUpsertWithoutCustomerAliasInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutCustomerAliasInput, ShopUpdateWithoutCustomerAliasInput>, ShopUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type CustomerUpdateOneRequiredWithoutCustomerAliasNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerAliasInput, CustomerUncheckedCreateWithoutCustomerAliasInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAliasInput
    upsert?: CustomerUpsertWithoutCustomerAliasInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerAliasInput, CustomerUpdateWithoutCustomerAliasInput>, CustomerUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type DeptUpdateManyWithoutCustomerAliasNestedInput = {
    create?: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput> | DeptCreateWithoutCustomerAliasInput[] | DeptUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DeptCreateOrConnectWithoutCustomerAliasInput | DeptCreateOrConnectWithoutCustomerAliasInput[]
    upsert?: DeptUpsertWithWhereUniqueWithoutCustomerAliasInput | DeptUpsertWithWhereUniqueWithoutCustomerAliasInput[]
    createMany?: DeptCreateManyCustomerAliasInputEnvelope
    set?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    disconnect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    delete?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    connect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    update?: DeptUpdateWithWhereUniqueWithoutCustomerAliasInput | DeptUpdateWithWhereUniqueWithoutCustomerAliasInput[]
    updateMany?: DeptUpdateManyWithWhereWithoutCustomerAliasInput | DeptUpdateManyWithWhereWithoutCustomerAliasInput[]
    deleteMany?: DeptScalarWhereInput | DeptScalarWhereInput[]
  }

  export type DebtStatusUpdateManyWithoutCustomerAliasNestedInput = {
    create?: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput> | DebtStatusCreateWithoutCustomerAliasInput[] | DebtStatusUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DebtStatusCreateOrConnectWithoutCustomerAliasInput | DebtStatusCreateOrConnectWithoutCustomerAliasInput[]
    upsert?: DebtStatusUpsertWithWhereUniqueWithoutCustomerAliasInput | DebtStatusUpsertWithWhereUniqueWithoutCustomerAliasInput[]
    createMany?: DebtStatusCreateManyCustomerAliasInputEnvelope
    set?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    disconnect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    delete?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    connect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    update?: DebtStatusUpdateWithWhereUniqueWithoutCustomerAliasInput | DebtStatusUpdateWithWhereUniqueWithoutCustomerAliasInput[]
    updateMany?: DebtStatusUpdateManyWithWhereWithoutCustomerAliasInput | DebtStatusUpdateManyWithWhereWithoutCustomerAliasInput[]
    deleteMany?: DebtStatusScalarWhereInput | DebtStatusScalarWhereInput[]
  }

  export type DeptUncheckedUpdateManyWithoutCustomerAliasNestedInput = {
    create?: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput> | DeptCreateWithoutCustomerAliasInput[] | DeptUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DeptCreateOrConnectWithoutCustomerAliasInput | DeptCreateOrConnectWithoutCustomerAliasInput[]
    upsert?: DeptUpsertWithWhereUniqueWithoutCustomerAliasInput | DeptUpsertWithWhereUniqueWithoutCustomerAliasInput[]
    createMany?: DeptCreateManyCustomerAliasInputEnvelope
    set?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    disconnect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    delete?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    connect?: DeptWhereUniqueInput | DeptWhereUniqueInput[]
    update?: DeptUpdateWithWhereUniqueWithoutCustomerAliasInput | DeptUpdateWithWhereUniqueWithoutCustomerAliasInput[]
    updateMany?: DeptUpdateManyWithWhereWithoutCustomerAliasInput | DeptUpdateManyWithWhereWithoutCustomerAliasInput[]
    deleteMany?: DeptScalarWhereInput | DeptScalarWhereInput[]
  }

  export type DebtStatusUncheckedUpdateManyWithoutCustomerAliasNestedInput = {
    create?: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput> | DebtStatusCreateWithoutCustomerAliasInput[] | DebtStatusUncheckedCreateWithoutCustomerAliasInput[]
    connectOrCreate?: DebtStatusCreateOrConnectWithoutCustomerAliasInput | DebtStatusCreateOrConnectWithoutCustomerAliasInput[]
    upsert?: DebtStatusUpsertWithWhereUniqueWithoutCustomerAliasInput | DebtStatusUpsertWithWhereUniqueWithoutCustomerAliasInput[]
    createMany?: DebtStatusCreateManyCustomerAliasInputEnvelope
    set?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    disconnect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    delete?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    connect?: DebtStatusWhereUniqueInput | DebtStatusWhereUniqueInput[]
    update?: DebtStatusUpdateWithWhereUniqueWithoutCustomerAliasInput | DebtStatusUpdateWithWhereUniqueWithoutCustomerAliasInput[]
    updateMany?: DebtStatusUpdateManyWithWhereWithoutCustomerAliasInput | DebtStatusUpdateManyWithWhereWithoutCustomerAliasInput[]
    deleteMany?: DebtStatusScalarWhereInput | DebtStatusScalarWhereInput[]
  }

  export type CustomerAliasCreateNestedOneWithoutDebtStatusInput = {
    create?: XOR<CustomerAliasCreateWithoutDebtStatusInput, CustomerAliasUncheckedCreateWithoutDebtStatusInput>
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutDebtStatusInput
    connect?: CustomerAliasWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CustomerAliasUpdateOneRequiredWithoutDebtStatusNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutDebtStatusInput, CustomerAliasUncheckedCreateWithoutDebtStatusInput>
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutDebtStatusInput
    upsert?: CustomerAliasUpsertWithoutDebtStatusInput
    connect?: CustomerAliasWhereUniqueInput
    update?: XOR<XOR<CustomerAliasUpdateToOneWithWhereWithoutDebtStatusInput, CustomerAliasUpdateWithoutDebtStatusInput>, CustomerAliasUncheckedUpdateWithoutDebtStatusInput>
  }

  export type CustomerAliasCreateNestedOneWithoutDeptInput = {
    create?: XOR<CustomerAliasCreateWithoutDeptInput, CustomerAliasUncheckedCreateWithoutDeptInput>
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutDeptInput
    connect?: CustomerAliasWhereUniqueInput
  }

  export type EnumTransactionTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.TransactionTypeEnum
  }

  export type CustomerAliasUpdateOneRequiredWithoutDeptNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutDeptInput, CustomerAliasUncheckedCreateWithoutDeptInput>
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutDeptInput
    upsert?: CustomerAliasUpsertWithoutDeptInput
    connect?: CustomerAliasWhereUniqueInput
    update?: XOR<XOR<CustomerAliasUpdateToOneWithWhereWithoutDeptInput, CustomerAliasUpdateWithoutDeptInput>, CustomerAliasUncheckedUpdateWithoutDeptInput>
  }

  export type WalletBaseCreateNestedOneWithoutShopInput = {
    create?: XOR<WalletBaseCreateWithoutShopInput, WalletBaseUncheckedCreateWithoutShopInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutShopInput
    connect?: WalletBaseWhereUniqueInput
  }

  export type CardAllocationCreateNestedManyWithoutShopInput = {
    create?: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput> | CardAllocationCreateWithoutShopInput[] | CardAllocationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CardAllocationCreateOrConnectWithoutShopInput | CardAllocationCreateOrConnectWithoutShopInput[]
    createMany?: CardAllocationCreateManyShopInputEnvelope
    connect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
  }

  export type UserShopCreateNestedManyWithoutShopInput = {
    create?: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput> | UserShopCreateWithoutShopInput[] | UserShopUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutShopInput | UserShopCreateOrConnectWithoutShopInput[]
    createMany?: UserShopCreateManyShopInputEnvelope
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
  }

  export type CustomerAliasCreateNestedManyWithoutShopInput = {
    create?: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput> | CustomerAliasCreateWithoutShopInput[] | CustomerAliasUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutShopInput | CustomerAliasCreateOrConnectWithoutShopInput[]
    createMany?: CustomerAliasCreateManyShopInputEnvelope
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutShopInput = {
    create?: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput> | PaymentCreateWithoutShopInput[] | PaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShopInput | PaymentCreateOrConnectWithoutShopInput[]
    createMany?: PaymentCreateManyShopInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CardRequestCreateNestedOneWithoutShopInput = {
    create?: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutShopInput
    connect?: CardRequestWhereUniqueInput
  }

  export type CardAllocationUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput> | CardAllocationCreateWithoutShopInput[] | CardAllocationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CardAllocationCreateOrConnectWithoutShopInput | CardAllocationCreateOrConnectWithoutShopInput[]
    createMany?: CardAllocationCreateManyShopInputEnvelope
    connect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
  }

  export type UserShopUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput> | UserShopCreateWithoutShopInput[] | UserShopUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutShopInput | UserShopCreateOrConnectWithoutShopInput[]
    createMany?: UserShopCreateManyShopInputEnvelope
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
  }

  export type CustomerAliasUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput> | CustomerAliasCreateWithoutShopInput[] | CustomerAliasUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutShopInput | CustomerAliasCreateOrConnectWithoutShopInput[]
    createMany?: CustomerAliasCreateManyShopInputEnvelope
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput> | PaymentCreateWithoutShopInput[] | PaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShopInput | PaymentCreateOrConnectWithoutShopInput[]
    createMany?: PaymentCreateManyShopInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CardRequestUncheckedCreateNestedOneWithoutShopInput = {
    create?: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutShopInput
    connect?: CardRequestWhereUniqueInput
  }

  export type WalletBaseUpdateOneRequiredWithoutShopNestedInput = {
    create?: XOR<WalletBaseCreateWithoutShopInput, WalletBaseUncheckedCreateWithoutShopInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutShopInput
    upsert?: WalletBaseUpsertWithoutShopInput
    connect?: WalletBaseWhereUniqueInput
    update?: XOR<XOR<WalletBaseUpdateToOneWithWhereWithoutShopInput, WalletBaseUpdateWithoutShopInput>, WalletBaseUncheckedUpdateWithoutShopInput>
  }

  export type CardAllocationUpdateManyWithoutShopNestedInput = {
    create?: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput> | CardAllocationCreateWithoutShopInput[] | CardAllocationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CardAllocationCreateOrConnectWithoutShopInput | CardAllocationCreateOrConnectWithoutShopInput[]
    upsert?: CardAllocationUpsertWithWhereUniqueWithoutShopInput | CardAllocationUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CardAllocationCreateManyShopInputEnvelope
    set?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    disconnect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    delete?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    connect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    update?: CardAllocationUpdateWithWhereUniqueWithoutShopInput | CardAllocationUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CardAllocationUpdateManyWithWhereWithoutShopInput | CardAllocationUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CardAllocationScalarWhereInput | CardAllocationScalarWhereInput[]
  }

  export type UserShopUpdateManyWithoutShopNestedInput = {
    create?: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput> | UserShopCreateWithoutShopInput[] | UserShopUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutShopInput | UserShopCreateOrConnectWithoutShopInput[]
    upsert?: UserShopUpsertWithWhereUniqueWithoutShopInput | UserShopUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: UserShopCreateManyShopInputEnvelope
    set?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    disconnect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    delete?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    update?: UserShopUpdateWithWhereUniqueWithoutShopInput | UserShopUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: UserShopUpdateManyWithWhereWithoutShopInput | UserShopUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
  }

  export type CustomerAliasUpdateManyWithoutShopNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput> | CustomerAliasCreateWithoutShopInput[] | CustomerAliasUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutShopInput | CustomerAliasCreateOrConnectWithoutShopInput[]
    upsert?: CustomerAliasUpsertWithWhereUniqueWithoutShopInput | CustomerAliasUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CustomerAliasCreateManyShopInputEnvelope
    set?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    disconnect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    delete?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    update?: CustomerAliasUpdateWithWhereUniqueWithoutShopInput | CustomerAliasUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CustomerAliasUpdateManyWithWhereWithoutShopInput | CustomerAliasUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutShopNestedInput = {
    create?: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput> | PaymentCreateWithoutShopInput[] | PaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShopInput | PaymentCreateOrConnectWithoutShopInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShopInput | PaymentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PaymentCreateManyShopInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShopInput | PaymentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShopInput | PaymentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CardRequestUpdateOneWithoutShopNestedInput = {
    create?: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutShopInput
    upsert?: CardRequestUpsertWithoutShopInput
    disconnect?: CardRequestWhereInput | boolean
    delete?: CardRequestWhereInput | boolean
    connect?: CardRequestWhereUniqueInput
    update?: XOR<XOR<CardRequestUpdateToOneWithWhereWithoutShopInput, CardRequestUpdateWithoutShopInput>, CardRequestUncheckedUpdateWithoutShopInput>
  }

  export type CardAllocationUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput> | CardAllocationCreateWithoutShopInput[] | CardAllocationUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CardAllocationCreateOrConnectWithoutShopInput | CardAllocationCreateOrConnectWithoutShopInput[]
    upsert?: CardAllocationUpsertWithWhereUniqueWithoutShopInput | CardAllocationUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CardAllocationCreateManyShopInputEnvelope
    set?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    disconnect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    delete?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    connect?: CardAllocationWhereUniqueInput | CardAllocationWhereUniqueInput[]
    update?: CardAllocationUpdateWithWhereUniqueWithoutShopInput | CardAllocationUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CardAllocationUpdateManyWithWhereWithoutShopInput | CardAllocationUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CardAllocationScalarWhereInput | CardAllocationScalarWhereInput[]
  }

  export type UserShopUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput> | UserShopCreateWithoutShopInput[] | UserShopUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UserShopCreateOrConnectWithoutShopInput | UserShopCreateOrConnectWithoutShopInput[]
    upsert?: UserShopUpsertWithWhereUniqueWithoutShopInput | UserShopUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: UserShopCreateManyShopInputEnvelope
    set?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    disconnect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    delete?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    connect?: UserShopWhereUniqueInput | UserShopWhereUniqueInput[]
    update?: UserShopUpdateWithWhereUniqueWithoutShopInput | UserShopUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: UserShopUpdateManyWithWhereWithoutShopInput | UserShopUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
  }

  export type CustomerAliasUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput> | CustomerAliasCreateWithoutShopInput[] | CustomerAliasUncheckedCreateWithoutShopInput[]
    connectOrCreate?: CustomerAliasCreateOrConnectWithoutShopInput | CustomerAliasCreateOrConnectWithoutShopInput[]
    upsert?: CustomerAliasUpsertWithWhereUniqueWithoutShopInput | CustomerAliasUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: CustomerAliasCreateManyShopInputEnvelope
    set?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    disconnect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    delete?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    connect?: CustomerAliasWhereUniqueInput | CustomerAliasWhereUniqueInput[]
    update?: CustomerAliasUpdateWithWhereUniqueWithoutShopInput | CustomerAliasUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: CustomerAliasUpdateManyWithWhereWithoutShopInput | CustomerAliasUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput> | PaymentCreateWithoutShopInput[] | PaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShopInput | PaymentCreateOrConnectWithoutShopInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShopInput | PaymentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: PaymentCreateManyShopInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShopInput | PaymentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShopInput | PaymentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CardRequestUncheckedUpdateOneWithoutShopNestedInput = {
    create?: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutShopInput
    upsert?: CardRequestUpsertWithoutShopInput
    disconnect?: CardRequestWhereInput | boolean
    delete?: CardRequestWhereInput | boolean
    connect?: CardRequestWhereUniqueInput
    update?: XOR<XOR<CardRequestUpdateToOneWithWhereWithoutShopInput, CardRequestUpdateWithoutShopInput>, CardRequestUncheckedUpdateWithoutShopInput>
  }

  export type ShopCreateNestedOneWithoutUserShopInput = {
    create?: XOR<ShopCreateWithoutUserShopInput, ShopUncheckedCreateWithoutUserShopInput>
    connectOrCreate?: ShopCreateOrConnectWithoutUserShopInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserShopInput = {
    create?: XOR<UserCreateWithoutUserShopInput, UserUncheckedCreateWithoutUserShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserShopInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserShopRoleEnumFieldUpdateOperationsInput = {
    set?: $Enums.UserShopRoleEnum
  }

  export type ShopUpdateOneRequiredWithoutUserShopNestedInput = {
    create?: XOR<ShopCreateWithoutUserShopInput, ShopUncheckedCreateWithoutUserShopInput>
    connectOrCreate?: ShopCreateOrConnectWithoutUserShopInput
    upsert?: ShopUpsertWithoutUserShopInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutUserShopInput, ShopUpdateWithoutUserShopInput>, ShopUncheckedUpdateWithoutUserShopInput>
  }

  export type UserUpdateOneRequiredWithoutUserShopNestedInput = {
    create?: XOR<UserCreateWithoutUserShopInput, UserUncheckedCreateWithoutUserShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserShopInput
    upsert?: UserUpsertWithoutUserShopInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserShopInput, UserUpdateWithoutUserShopInput>, UserUncheckedUpdateWithoutUserShopInput>
  }

  export type TransactionCreateNestedManyWithoutFromInput = {
    create?: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput> | TransactionCreateWithoutFromInput[] | TransactionUncheckedCreateWithoutFromInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromInput | TransactionCreateOrConnectWithoutFromInput[]
    createMany?: TransactionCreateManyFromInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutToInput = {
    create?: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput> | TransactionCreateWithoutToInput[] | TransactionUncheckedCreateWithoutToInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToInput | TransactionCreateOrConnectWithoutToInput[]
    createMany?: TransactionCreateManyToInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WalletStatusCreateNestedManyWithoutWalletBaseInput = {
    create?: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput> | WalletStatusCreateWithoutWalletBaseInput[] | WalletStatusUncheckedCreateWithoutWalletBaseInput[]
    connectOrCreate?: WalletStatusCreateOrConnectWithoutWalletBaseInput | WalletStatusCreateOrConnectWithoutWalletBaseInput[]
    createMany?: WalletStatusCreateManyWalletBaseInputEnvelope
    connect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutEntityBaseInput = {
    create?: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEntityBaseInput
    connect?: ShopWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutWalletBaseInput = {
    create?: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWalletBaseInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput> | TransactionCreateWithoutFromInput[] | TransactionUncheckedCreateWithoutFromInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromInput | TransactionCreateOrConnectWithoutFromInput[]
    createMany?: TransactionCreateManyFromInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput> | TransactionCreateWithoutToInput[] | TransactionUncheckedCreateWithoutToInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToInput | TransactionCreateOrConnectWithoutToInput[]
    createMany?: TransactionCreateManyToInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput = {
    create?: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput> | WalletStatusCreateWithoutWalletBaseInput[] | WalletStatusUncheckedCreateWithoutWalletBaseInput[]
    connectOrCreate?: WalletStatusCreateOrConnectWithoutWalletBaseInput | WalletStatusCreateOrConnectWithoutWalletBaseInput[]
    createMany?: WalletStatusCreateManyWalletBaseInputEnvelope
    connect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedOneWithoutEntityBaseInput = {
    create?: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEntityBaseInput
    connect?: ShopWhereUniqueInput
  }

  export type CustomerUncheckedCreateNestedOneWithoutWalletBaseInput = {
    create?: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWalletBaseInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumEntityEnumFieldUpdateOperationsInput = {
    set?: $Enums.EntityEnum
  }

  export type TransactionUpdateManyWithoutFromNestedInput = {
    create?: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput> | TransactionCreateWithoutFromInput[] | TransactionUncheckedCreateWithoutFromInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromInput | TransactionCreateOrConnectWithoutFromInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromInput | TransactionUpsertWithWhereUniqueWithoutFromInput[]
    createMany?: TransactionCreateManyFromInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromInput | TransactionUpdateWithWhereUniqueWithoutFromInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromInput | TransactionUpdateManyWithWhereWithoutFromInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutToNestedInput = {
    create?: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput> | TransactionCreateWithoutToInput[] | TransactionUncheckedCreateWithoutToInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToInput | TransactionCreateOrConnectWithoutToInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToInput | TransactionUpsertWithWhereUniqueWithoutToInput[]
    createMany?: TransactionCreateManyToInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToInput | TransactionUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToInput | TransactionUpdateManyWithWhereWithoutToInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WalletStatusUpdateManyWithoutWalletBaseNestedInput = {
    create?: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput> | WalletStatusCreateWithoutWalletBaseInput[] | WalletStatusUncheckedCreateWithoutWalletBaseInput[]
    connectOrCreate?: WalletStatusCreateOrConnectWithoutWalletBaseInput | WalletStatusCreateOrConnectWithoutWalletBaseInput[]
    upsert?: WalletStatusUpsertWithWhereUniqueWithoutWalletBaseInput | WalletStatusUpsertWithWhereUniqueWithoutWalletBaseInput[]
    createMany?: WalletStatusCreateManyWalletBaseInputEnvelope
    set?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    disconnect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    delete?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    connect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    update?: WalletStatusUpdateWithWhereUniqueWithoutWalletBaseInput | WalletStatusUpdateWithWhereUniqueWithoutWalletBaseInput[]
    updateMany?: WalletStatusUpdateManyWithWhereWithoutWalletBaseInput | WalletStatusUpdateManyWithWhereWithoutWalletBaseInput[]
    deleteMany?: WalletStatusScalarWhereInput | WalletStatusScalarWhereInput[]
  }

  export type ShopUpdateOneWithoutEntityBaseNestedInput = {
    create?: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEntityBaseInput
    upsert?: ShopUpsertWithoutEntityBaseInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutEntityBaseInput, ShopUpdateWithoutEntityBaseInput>, ShopUncheckedUpdateWithoutEntityBaseInput>
  }

  export type CustomerUpdateOneWithoutWalletBaseNestedInput = {
    create?: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWalletBaseInput
    upsert?: CustomerUpsertWithoutWalletBaseInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutWalletBaseInput, CustomerUpdateWithoutWalletBaseInput>, CustomerUncheckedUpdateWithoutWalletBaseInput>
  }

  export type TransactionUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput> | TransactionCreateWithoutFromInput[] | TransactionUncheckedCreateWithoutFromInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromInput | TransactionCreateOrConnectWithoutFromInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromInput | TransactionUpsertWithWhereUniqueWithoutFromInput[]
    createMany?: TransactionCreateManyFromInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromInput | TransactionUpdateWithWhereUniqueWithoutFromInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromInput | TransactionUpdateManyWithWhereWithoutFromInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput> | TransactionCreateWithoutToInput[] | TransactionUncheckedCreateWithoutToInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToInput | TransactionCreateOrConnectWithoutToInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToInput | TransactionUpsertWithWhereUniqueWithoutToInput[]
    createMany?: TransactionCreateManyToInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToInput | TransactionUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToInput | TransactionUpdateManyWithWhereWithoutToInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput = {
    create?: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput> | WalletStatusCreateWithoutWalletBaseInput[] | WalletStatusUncheckedCreateWithoutWalletBaseInput[]
    connectOrCreate?: WalletStatusCreateOrConnectWithoutWalletBaseInput | WalletStatusCreateOrConnectWithoutWalletBaseInput[]
    upsert?: WalletStatusUpsertWithWhereUniqueWithoutWalletBaseInput | WalletStatusUpsertWithWhereUniqueWithoutWalletBaseInput[]
    createMany?: WalletStatusCreateManyWalletBaseInputEnvelope
    set?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    disconnect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    delete?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    connect?: WalletStatusWhereUniqueInput | WalletStatusWhereUniqueInput[]
    update?: WalletStatusUpdateWithWhereUniqueWithoutWalletBaseInput | WalletStatusUpdateWithWhereUniqueWithoutWalletBaseInput[]
    updateMany?: WalletStatusUpdateManyWithWhereWithoutWalletBaseInput | WalletStatusUpdateManyWithWhereWithoutWalletBaseInput[]
    deleteMany?: WalletStatusScalarWhereInput | WalletStatusScalarWhereInput[]
  }

  export type ShopUncheckedUpdateOneWithoutEntityBaseNestedInput = {
    create?: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEntityBaseInput
    upsert?: ShopUpsertWithoutEntityBaseInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutEntityBaseInput, ShopUpdateWithoutEntityBaseInput>, ShopUncheckedUpdateWithoutEntityBaseInput>
  }

  export type CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput = {
    create?: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWalletBaseInput
    upsert?: CustomerUpsertWithoutWalletBaseInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutWalletBaseInput, CustomerUpdateWithoutWalletBaseInput>, CustomerUncheckedUpdateWithoutWalletBaseInput>
  }

  export type WalletBaseCreateNestedOneWithoutWalletStatusInput = {
    create?: XOR<WalletBaseCreateWithoutWalletStatusInput, WalletBaseUncheckedCreateWithoutWalletStatusInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutWalletStatusInput
    connect?: WalletBaseWhereUniqueInput
  }

  export type WalletBaseUpdateOneRequiredWithoutWalletStatusNestedInput = {
    create?: XOR<WalletBaseCreateWithoutWalletStatusInput, WalletBaseUncheckedCreateWithoutWalletStatusInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutWalletStatusInput
    upsert?: WalletBaseUpsertWithoutWalletStatusInput
    connect?: WalletBaseWhereUniqueInput
    update?: XOR<XOR<WalletBaseUpdateToOneWithWhereWithoutWalletStatusInput, WalletBaseUpdateWithoutWalletStatusInput>, WalletBaseUncheckedUpdateWithoutWalletStatusInput>
  }

  export type WalletBaseCreateNestedOneWithoutFromTransactionInput = {
    create?: XOR<WalletBaseCreateWithoutFromTransactionInput, WalletBaseUncheckedCreateWithoutFromTransactionInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutFromTransactionInput
    connect?: WalletBaseWhereUniqueInput
  }

  export type WalletBaseCreateNestedOneWithoutToTransactionInput = {
    create?: XOR<WalletBaseCreateWithoutToTransactionInput, WalletBaseUncheckedCreateWithoutToTransactionInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutToTransactionInput
    connect?: WalletBaseWhereUniqueInput
  }

  export type WalletBaseUpdateOneRequiredWithoutFromTransactionNestedInput = {
    create?: XOR<WalletBaseCreateWithoutFromTransactionInput, WalletBaseUncheckedCreateWithoutFromTransactionInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutFromTransactionInput
    upsert?: WalletBaseUpsertWithoutFromTransactionInput
    connect?: WalletBaseWhereUniqueInput
    update?: XOR<XOR<WalletBaseUpdateToOneWithWhereWithoutFromTransactionInput, WalletBaseUpdateWithoutFromTransactionInput>, WalletBaseUncheckedUpdateWithoutFromTransactionInput>
  }

  export type WalletBaseUpdateOneRequiredWithoutToTransactionNestedInput = {
    create?: XOR<WalletBaseCreateWithoutToTransactionInput, WalletBaseUncheckedCreateWithoutToTransactionInput>
    connectOrCreate?: WalletBaseCreateOrConnectWithoutToTransactionInput
    upsert?: WalletBaseUpsertWithoutToTransactionInput
    connect?: WalletBaseWhereUniqueInput
    update?: XOR<XOR<WalletBaseUpdateToOneWithWhereWithoutToTransactionInput, WalletBaseUpdateWithoutToTransactionInput>, WalletBaseUncheckedUpdateWithoutToTransactionInput>
  }

  export type AssignmentCreateNestedManyWithoutCardInput = {
    create?: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput> | AssignmentCreateWithoutCardInput[] | AssignmentUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCardInput | AssignmentCreateOrConnectWithoutCardInput[]
    createMany?: AssignmentCreateManyCardInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CardAllocationDetailCreateNestedManyWithoutCardInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput> | CardAllocationDetailCreateWithoutCardInput[] | CardAllocationDetailUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardInput | CardAllocationDetailCreateOrConnectWithoutCardInput[]
    createMany?: CardAllocationDetailCreateManyCardInputEnvelope
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput> | AssignmentCreateWithoutCardInput[] | AssignmentUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCardInput | AssignmentCreateOrConnectWithoutCardInput[]
    createMany?: AssignmentCreateManyCardInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type CardAllocationDetailUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput> | CardAllocationDetailCreateWithoutCardInput[] | CardAllocationDetailUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardInput | CardAllocationDetailCreateOrConnectWithoutCardInput[]
    createMany?: CardAllocationDetailCreateManyCardInputEnvelope
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
  }

  export type AssignmentUpdateManyWithoutCardNestedInput = {
    create?: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput> | AssignmentCreateWithoutCardInput[] | AssignmentUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCardInput | AssignmentCreateOrConnectWithoutCardInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutCardInput | AssignmentUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AssignmentCreateManyCardInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutCardInput | AssignmentUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutCardInput | AssignmentUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CardAllocationDetailUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput> | CardAllocationDetailCreateWithoutCardInput[] | CardAllocationDetailUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardInput | CardAllocationDetailCreateOrConnectWithoutCardInput[]
    upsert?: CardAllocationDetailUpsertWithWhereUniqueWithoutCardInput | CardAllocationDetailUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardAllocationDetailCreateManyCardInputEnvelope
    set?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    disconnect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    delete?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    update?: CardAllocationDetailUpdateWithWhereUniqueWithoutCardInput | CardAllocationDetailUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardAllocationDetailUpdateManyWithWhereWithoutCardInput | CardAllocationDetailUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput> | AssignmentCreateWithoutCardInput[] | AssignmentUncheckedCreateWithoutCardInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutCardInput | AssignmentCreateOrConnectWithoutCardInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutCardInput | AssignmentUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: AssignmentCreateManyCardInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutCardInput | AssignmentUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutCardInput | AssignmentUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type CardAllocationDetailUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput> | CardAllocationDetailCreateWithoutCardInput[] | CardAllocationDetailUncheckedCreateWithoutCardInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardInput | CardAllocationDetailCreateOrConnectWithoutCardInput[]
    upsert?: CardAllocationDetailUpsertWithWhereUniqueWithoutCardInput | CardAllocationDetailUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: CardAllocationDetailCreateManyCardInputEnvelope
    set?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    disconnect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    delete?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    update?: CardAllocationDetailUpdateWithWhereUniqueWithoutCardInput | CardAllocationDetailUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: CardAllocationDetailUpdateManyWithWhereWithoutCardInput | CardAllocationDetailUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutCardAllocationInput = {
    create?: XOR<ShopCreateWithoutCardAllocationInput, ShopUncheckedCreateWithoutCardAllocationInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCardAllocationInput
    connect?: ShopWhereUniqueInput
  }

  export type CardAllocationDetailCreateNestedManyWithoutCardAllocationInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput> | CardAllocationDetailCreateWithoutCardAllocationInput[] | CardAllocationDetailUncheckedCreateWithoutCardAllocationInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardAllocationInput | CardAllocationDetailCreateOrConnectWithoutCardAllocationInput[]
    createMany?: CardAllocationDetailCreateManyCardAllocationInputEnvelope
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
  }

  export type CardAllocationDetailUncheckedCreateNestedManyWithoutCardAllocationInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput> | CardAllocationDetailCreateWithoutCardAllocationInput[] | CardAllocationDetailUncheckedCreateWithoutCardAllocationInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardAllocationInput | CardAllocationDetailCreateOrConnectWithoutCardAllocationInput[]
    createMany?: CardAllocationDetailCreateManyCardAllocationInputEnvelope
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
  }

  export type ShopUpdateOneRequiredWithoutCardAllocationNestedInput = {
    create?: XOR<ShopCreateWithoutCardAllocationInput, ShopUncheckedCreateWithoutCardAllocationInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCardAllocationInput
    upsert?: ShopUpsertWithoutCardAllocationInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutCardAllocationInput, ShopUpdateWithoutCardAllocationInput>, ShopUncheckedUpdateWithoutCardAllocationInput>
  }

  export type CardAllocationDetailUpdateManyWithoutCardAllocationNestedInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput> | CardAllocationDetailCreateWithoutCardAllocationInput[] | CardAllocationDetailUncheckedCreateWithoutCardAllocationInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardAllocationInput | CardAllocationDetailCreateOrConnectWithoutCardAllocationInput[]
    upsert?: CardAllocationDetailUpsertWithWhereUniqueWithoutCardAllocationInput | CardAllocationDetailUpsertWithWhereUniqueWithoutCardAllocationInput[]
    createMany?: CardAllocationDetailCreateManyCardAllocationInputEnvelope
    set?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    disconnect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    delete?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    update?: CardAllocationDetailUpdateWithWhereUniqueWithoutCardAllocationInput | CardAllocationDetailUpdateWithWhereUniqueWithoutCardAllocationInput[]
    updateMany?: CardAllocationDetailUpdateManyWithWhereWithoutCardAllocationInput | CardAllocationDetailUpdateManyWithWhereWithoutCardAllocationInput[]
    deleteMany?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
  }

  export type CardAllocationDetailUncheckedUpdateManyWithoutCardAllocationNestedInput = {
    create?: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput> | CardAllocationDetailCreateWithoutCardAllocationInput[] | CardAllocationDetailUncheckedCreateWithoutCardAllocationInput[]
    connectOrCreate?: CardAllocationDetailCreateOrConnectWithoutCardAllocationInput | CardAllocationDetailCreateOrConnectWithoutCardAllocationInput[]
    upsert?: CardAllocationDetailUpsertWithWhereUniqueWithoutCardAllocationInput | CardAllocationDetailUpsertWithWhereUniqueWithoutCardAllocationInput[]
    createMany?: CardAllocationDetailCreateManyCardAllocationInputEnvelope
    set?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    disconnect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    delete?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    connect?: CardAllocationDetailWhereUniqueInput | CardAllocationDetailWhereUniqueInput[]
    update?: CardAllocationDetailUpdateWithWhereUniqueWithoutCardAllocationInput | CardAllocationDetailUpdateWithWhereUniqueWithoutCardAllocationInput[]
    updateMany?: CardAllocationDetailUpdateManyWithWhereWithoutCardAllocationInput | CardAllocationDetailUpdateManyWithWhereWithoutCardAllocationInput[]
    deleteMany?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutCardRequestInput = {
    create?: XOR<ShopCreateWithoutCardRequestInput, ShopUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCardRequestInput
    connect?: ShopWhereUniqueInput
  }

  export type CardRequestStatusCreateNestedOneWithoutCardRequestInput = {
    create?: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: CardRequestStatusCreateOrConnectWithoutCardRequestInput
    connect?: CardRequestStatusWhereUniqueInput
  }

  export type CardRequestStatusUncheckedCreateNestedOneWithoutCardRequestInput = {
    create?: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: CardRequestStatusCreateOrConnectWithoutCardRequestInput
    connect?: CardRequestStatusWhereUniqueInput
  }

  export type EnumCardRequestEnumFieldUpdateOperationsInput = {
    set?: $Enums.CardRequestEnum
  }

  export type ShopUpdateOneWithoutCardRequestNestedInput = {
    create?: XOR<ShopCreateWithoutCardRequestInput, ShopUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: ShopCreateOrConnectWithoutCardRequestInput
    upsert?: ShopUpsertWithoutCardRequestInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutCardRequestInput, ShopUpdateWithoutCardRequestInput>, ShopUncheckedUpdateWithoutCardRequestInput>
  }

  export type CardRequestStatusUpdateOneWithoutCardRequestNestedInput = {
    create?: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: CardRequestStatusCreateOrConnectWithoutCardRequestInput
    upsert?: CardRequestStatusUpsertWithoutCardRequestInput
    disconnect?: CardRequestStatusWhereInput | boolean
    delete?: CardRequestStatusWhereInput | boolean
    connect?: CardRequestStatusWhereUniqueInput
    update?: XOR<XOR<CardRequestStatusUpdateToOneWithWhereWithoutCardRequestInput, CardRequestStatusUpdateWithoutCardRequestInput>, CardRequestStatusUncheckedUpdateWithoutCardRequestInput>
  }

  export type CardRequestStatusUncheckedUpdateOneWithoutCardRequestNestedInput = {
    create?: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
    connectOrCreate?: CardRequestStatusCreateOrConnectWithoutCardRequestInput
    upsert?: CardRequestStatusUpsertWithoutCardRequestInput
    disconnect?: CardRequestStatusWhereInput | boolean
    delete?: CardRequestStatusWhereInput | boolean
    connect?: CardRequestStatusWhereUniqueInput
    update?: XOR<XOR<CardRequestStatusUpdateToOneWithWhereWithoutCardRequestInput, CardRequestStatusUpdateWithoutCardRequestInput>, CardRequestStatusUncheckedUpdateWithoutCardRequestInput>
  }

  export type CardRequestCreateNestedOneWithoutCardrequeststatusInput = {
    create?: XOR<CardRequestCreateWithoutCardrequeststatusInput, CardRequestUncheckedCreateWithoutCardrequeststatusInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutCardrequeststatusInput
    connect?: CardRequestWhereUniqueInput
  }

  export type CardRequestUpdateOneRequiredWithoutCardrequeststatusNestedInput = {
    create?: XOR<CardRequestCreateWithoutCardrequeststatusInput, CardRequestUncheckedCreateWithoutCardrequeststatusInput>
    connectOrCreate?: CardRequestCreateOrConnectWithoutCardrequeststatusInput
    upsert?: CardRequestUpsertWithoutCardrequeststatusInput
    connect?: CardRequestWhereUniqueInput
    update?: XOR<XOR<CardRequestUpdateToOneWithWhereWithoutCardrequeststatusInput, CardRequestUpdateWithoutCardrequeststatusInput>, CardRequestUncheckedUpdateWithoutCardrequeststatusInput>
  }

  export type CardCreateNestedOneWithoutCardAllocationDetailInput = {
    create?: XOR<CardCreateWithoutCardAllocationDetailInput, CardUncheckedCreateWithoutCardAllocationDetailInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardAllocationDetailInput
    connect?: CardWhereUniqueInput
  }

  export type CardAllocationCreateNestedOneWithoutCardAllocationDetailInput = {
    create?: XOR<CardAllocationCreateWithoutCardAllocationDetailInput, CardAllocationUncheckedCreateWithoutCardAllocationDetailInput>
    connectOrCreate?: CardAllocationCreateOrConnectWithoutCardAllocationDetailInput
    connect?: CardAllocationWhereUniqueInput
  }

  export type CardUpdateOneRequiredWithoutCardAllocationDetailNestedInput = {
    create?: XOR<CardCreateWithoutCardAllocationDetailInput, CardUncheckedCreateWithoutCardAllocationDetailInput>
    connectOrCreate?: CardCreateOrConnectWithoutCardAllocationDetailInput
    upsert?: CardUpsertWithoutCardAllocationDetailInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutCardAllocationDetailInput, CardUpdateWithoutCardAllocationDetailInput>, CardUncheckedUpdateWithoutCardAllocationDetailInput>
  }

  export type CardAllocationUpdateOneRequiredWithoutCardAllocationDetailNestedInput = {
    create?: XOR<CardAllocationCreateWithoutCardAllocationDetailInput, CardAllocationUncheckedCreateWithoutCardAllocationDetailInput>
    connectOrCreate?: CardAllocationCreateOrConnectWithoutCardAllocationDetailInput
    upsert?: CardAllocationUpsertWithoutCardAllocationDetailInput
    connect?: CardAllocationWhereUniqueInput
    update?: XOR<XOR<CardAllocationUpdateToOneWithWhereWithoutCardAllocationDetailInput, CardAllocationUpdateWithoutCardAllocationDetailInput>, CardAllocationUncheckedUpdateWithoutCardAllocationDetailInput>
  }

  export type CustomerCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<CustomerCreateWithoutAssignmentInput, CustomerUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignmentInput
    connect?: CustomerWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<CardCreateWithoutAssignmentInput, CardUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CardCreateOrConnectWithoutAssignmentInput
    connect?: CardWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutAssignmentNestedInput = {
    create?: XOR<CustomerCreateWithoutAssignmentInput, CustomerUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignmentInput
    upsert?: CustomerUpsertWithoutAssignmentInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAssignmentInput, CustomerUpdateWithoutAssignmentInput>, CustomerUncheckedUpdateWithoutAssignmentInput>
  }

  export type CardUpdateOneRequiredWithoutAssignmentNestedInput = {
    create?: XOR<CardCreateWithoutAssignmentInput, CardUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CardCreateOrConnectWithoutAssignmentInput
    upsert?: CardUpsertWithoutAssignmentInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutAssignmentInput, CardUpdateWithoutAssignmentInput>, CardUncheckedUpdateWithoutAssignmentInput>
  }

  export type PermissionCreateNestedManyWithoutModuleInput = {
    create?: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput> | PermissionCreateWithoutModuleInput[] | PermissionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutModuleInput | PermissionCreateOrConnectWithoutModuleInput[]
    createMany?: PermissionCreateManyModuleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput> | PermissionCreateWithoutModuleInput[] | PermissionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutModuleInput | PermissionCreateOrConnectWithoutModuleInput[]
    createMany?: PermissionCreateManyModuleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type PermissionUpdateManyWithoutModuleNestedInput = {
    create?: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput> | PermissionCreateWithoutModuleInput[] | PermissionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutModuleInput | PermissionCreateOrConnectWithoutModuleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutModuleInput | PermissionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: PermissionCreateManyModuleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutModuleInput | PermissionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutModuleInput | PermissionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput> | PermissionCreateWithoutModuleInput[] | PermissionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutModuleInput | PermissionCreateOrConnectWithoutModuleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutModuleInput | PermissionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: PermissionCreateManyModuleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutModuleInput | PermissionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutModuleInput | PermissionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type LoginCreateNestedManyWithoutRoleInput = {
    create?: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput> | LoginCreateWithoutRoleInput[] | LoginUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: LoginCreateOrConnectWithoutRoleInput | LoginCreateOrConnectWithoutRoleInput[]
    createMany?: LoginCreateManyRoleInputEnvelope
    connect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type LoginUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput> | LoginCreateWithoutRoleInput[] | LoginUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: LoginCreateOrConnectWithoutRoleInput | LoginCreateOrConnectWithoutRoleInput[]
    createMany?: LoginCreateManyRoleInputEnvelope
    connect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type LoginUpdateManyWithoutRoleNestedInput = {
    create?: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput> | LoginCreateWithoutRoleInput[] | LoginUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: LoginCreateOrConnectWithoutRoleInput | LoginCreateOrConnectWithoutRoleInput[]
    upsert?: LoginUpsertWithWhereUniqueWithoutRoleInput | LoginUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: LoginCreateManyRoleInputEnvelope
    set?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    disconnect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    delete?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    connect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    update?: LoginUpdateWithWhereUniqueWithoutRoleInput | LoginUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: LoginUpdateManyWithWhereWithoutRoleInput | LoginUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: LoginScalarWhereInput | LoginScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type LoginUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput> | LoginCreateWithoutRoleInput[] | LoginUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: LoginCreateOrConnectWithoutRoleInput | LoginCreateOrConnectWithoutRoleInput[]
    upsert?: LoginUpsertWithWhereUniqueWithoutRoleInput | LoginUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: LoginCreateManyRoleInputEnvelope
    set?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    disconnect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    delete?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    connect?: LoginWhereUniqueInput | LoginWhereUniqueInput[]
    update?: LoginUpdateWithWhereUniqueWithoutRoleInput | LoginUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: LoginUpdateManyWithWhereWithoutRoleInput | LoginUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: LoginScalarWhereInput | LoginScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionInput, PermissionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    upsert?: RoleUpsertWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionInput, RoleUpdateWithoutRolePermissionInput>, RoleUncheckedUpdateWithoutRolePermissionInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionInput, PermissionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionInput
    upsert?: PermissionUpsertWithoutRolePermissionInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionInput, PermissionUpdateWithoutRolePermissionInput>, PermissionUncheckedUpdateWithoutRolePermissionInput>
  }

  export type ModuleCreateNestedOneWithoutPermissionInput = {
    create?: XOR<ModuleCreateWithoutPermissionInput, ModuleUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPermissionInput
    connect?: ModuleWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type EnumPermissionActionEnumFieldUpdateOperationsInput = {
    set?: $Enums.PermissionActionEnum
  }

  export type ModuleUpdateOneRequiredWithoutPermissionNestedInput = {
    create?: XOR<ModuleCreateWithoutPermissionInput, ModuleUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPermissionInput
    upsert?: ModuleUpsertWithoutPermissionInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutPermissionInput, ModuleUpdateWithoutPermissionInput>, ModuleUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PaymentCreateNestedManyWithoutOfferInput = {
    create?: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput> | PaymentCreateWithoutOfferInput[] | PaymentUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOfferInput | PaymentCreateOrConnectWithoutOfferInput[]
    createMany?: PaymentCreateManyOfferInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput> | PaymentCreateWithoutOfferInput[] | PaymentUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOfferInput | PaymentCreateOrConnectWithoutOfferInput[]
    createMany?: PaymentCreateManyOfferInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutOfferNestedInput = {
    create?: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput> | PaymentCreateWithoutOfferInput[] | PaymentUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOfferInput | PaymentCreateOrConnectWithoutOfferInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOfferInput | PaymentUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: PaymentCreateManyOfferInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOfferInput | PaymentUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOfferInput | PaymentUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput> | PaymentCreateWithoutOfferInput[] | PaymentUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOfferInput | PaymentCreateOrConnectWithoutOfferInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOfferInput | PaymentUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: PaymentCreateManyOfferInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOfferInput | PaymentUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOfferInput | PaymentUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ShopCreateWithoutPaymentInput, ShopUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPaymentInput
    connect?: ShopWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OfferCreateWithoutPaymentInput, OfferUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPaymentInput
    connect?: OfferWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ShopUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<ShopCreateWithoutPaymentInput, ShopUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ShopCreateOrConnectWithoutPaymentInput
    upsert?: ShopUpsertWithoutPaymentInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutPaymentInput, ShopUpdateWithoutPaymentInput>, ShopUncheckedUpdateWithoutPaymentInput>
  }

  export type OfferUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<OfferCreateWithoutPaymentInput, OfferUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OfferCreateOrConnectWithoutPaymentInput
    upsert?: OfferUpsertWithoutPaymentInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutPaymentInput, OfferUpdateWithoutPaymentInput>, OfferUncheckedUpdateWithoutPaymentInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumLoginEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginEnum | EnumLoginEnumFieldRefInput<$PrismaModel>
    in?: $Enums.LoginEnum[]
    notIn?: $Enums.LoginEnum[]
    not?: NestedEnumLoginEnumFilter<$PrismaModel> | $Enums.LoginEnum
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLoginEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginEnum | EnumLoginEnumFieldRefInput<$PrismaModel>
    in?: $Enums.LoginEnum[]
    notIn?: $Enums.LoginEnum[]
    not?: NestedEnumLoginEnumWithAggregatesFilter<$PrismaModel> | $Enums.LoginEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginEnumFilter<$PrismaModel>
    _max?: NestedEnumLoginEnumFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumOptDurationEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OptDurationEnum | EnumOptDurationEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptDurationEnum[]
    notIn?: $Enums.OptDurationEnum[]
    not?: NestedEnumOptDurationEnumFilter<$PrismaModel> | $Enums.OptDurationEnum
  }

  export type NestedEnumOptViaEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.OptViaEnum | EnumOptViaEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptViaEnum[]
    notIn?: $Enums.OptViaEnum[]
    not?: NestedEnumOptViaEnumFilter<$PrismaModel> | $Enums.OptViaEnum
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumOptDurationEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptDurationEnum | EnumOptDurationEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptDurationEnum[]
    notIn?: $Enums.OptDurationEnum[]
    not?: NestedEnumOptDurationEnumWithAggregatesFilter<$PrismaModel> | $Enums.OptDurationEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptDurationEnumFilter<$PrismaModel>
    _max?: NestedEnumOptDurationEnumFilter<$PrismaModel>
  }

  export type NestedEnumOptViaEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptViaEnum | EnumOptViaEnumFieldRefInput<$PrismaModel>
    in?: $Enums.OptViaEnum[]
    notIn?: $Enums.OptViaEnum[]
    not?: NestedEnumOptViaEnumWithAggregatesFilter<$PrismaModel> | $Enums.OptViaEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptViaEnumFilter<$PrismaModel>
    _max?: NestedEnumOptViaEnumFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[]
    notIn?: $Enums.TransactionTypeEnum[]
    not?: NestedEnumTransactionTypeEnumFilter<$PrismaModel> | $Enums.TransactionTypeEnum
  }

  export type NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionTypeEnum | EnumTransactionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionTypeEnum[]
    notIn?: $Enums.TransactionTypeEnum[]
    not?: NestedEnumTransactionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.TransactionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumUserShopRoleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserShopRoleEnum | EnumUserShopRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserShopRoleEnum[]
    notIn?: $Enums.UserShopRoleEnum[]
    not?: NestedEnumUserShopRoleEnumFilter<$PrismaModel> | $Enums.UserShopRoleEnum
  }

  export type NestedEnumUserShopRoleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserShopRoleEnum | EnumUserShopRoleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserShopRoleEnum[]
    notIn?: $Enums.UserShopRoleEnum[]
    not?: NestedEnumUserShopRoleEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserShopRoleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserShopRoleEnumFilter<$PrismaModel>
    _max?: NestedEnumUserShopRoleEnumFilter<$PrismaModel>
  }

  export type NestedEnumEntityEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityEnum | EnumEntityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EntityEnum[]
    notIn?: $Enums.EntityEnum[]
    not?: NestedEnumEntityEnumFilter<$PrismaModel> | $Enums.EntityEnum
  }

  export type NestedEnumEntityEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityEnum | EnumEntityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.EntityEnum[]
    notIn?: $Enums.EntityEnum[]
    not?: NestedEnumEntityEnumWithAggregatesFilter<$PrismaModel> | $Enums.EntityEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityEnumFilter<$PrismaModel>
    _max?: NestedEnumEntityEnumFilter<$PrismaModel>
  }

  export type NestedEnumCardRequestEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRequestEnum | EnumCardRequestEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CardRequestEnum[]
    notIn?: $Enums.CardRequestEnum[]
    not?: NestedEnumCardRequestEnumFilter<$PrismaModel> | $Enums.CardRequestEnum
  }

  export type NestedEnumCardRequestEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardRequestEnum | EnumCardRequestEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CardRequestEnum[]
    notIn?: $Enums.CardRequestEnum[]
    not?: NestedEnumCardRequestEnumWithAggregatesFilter<$PrismaModel> | $Enums.CardRequestEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardRequestEnumFilter<$PrismaModel>
    _max?: NestedEnumCardRequestEnumFilter<$PrismaModel>
  }

  export type NestedEnumPermissionActionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionActionEnum | EnumPermissionActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionActionEnum[]
    notIn?: $Enums.PermissionActionEnum[]
    not?: NestedEnumPermissionActionEnumFilter<$PrismaModel> | $Enums.PermissionActionEnum
  }

  export type NestedEnumPermissionActionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionActionEnum | EnumPermissionActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionActionEnum[]
    notIn?: $Enums.PermissionActionEnum[]
    not?: NestedEnumPermissionActionEnumWithAggregatesFilter<$PrismaModel> | $Enums.PermissionActionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionActionEnumFilter<$PrismaModel>
    _max?: NestedEnumPermissionActionEnumFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerCreateWithoutLoginInput = {
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    customerAlias?: CustomerAliasCreateNestedManyWithoutCustomerInput
    WalletBase: WalletBaseCreateNestedOneWithoutCustomerInput
    assignment?: AssignmentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLoginInput = {
    id?: number
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    entityBaseId: number
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutCustomerInput
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLoginInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
  }

  export type RoleCreateWithoutLoginInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    rolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutLoginInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutLoginInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutLoginInput, RoleUncheckedCreateWithoutLoginInput>
  }

  export type UserCreateWithoutLoginInput = {
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginInput = {
    id?: number
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
  }

  export type OtpCreateWithoutLoginInput = {
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OtpUncheckedCreateWithoutLoginInput = {
    id?: number
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OtpCreateOrConnectWithoutLoginInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput>
  }

  export type OtpCreateManyLoginInputEnvelope = {
    data: OtpCreateManyLoginInput | OtpCreateManyLoginInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutLoginInput = {
    update: XOR<CustomerUpdateWithoutLoginInput, CustomerUncheckedUpdateWithoutLoginInput>
    create: XOR<CustomerCreateWithoutLoginInput, CustomerUncheckedCreateWithoutLoginInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLoginInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLoginInput, CustomerUncheckedUpdateWithoutLoginInput>
  }

  export type CustomerUpdateWithoutLoginInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAlias?: CustomerAliasUpdateManyWithoutCustomerNestedInput
    WalletBase?: WalletBaseUpdateOneRequiredWithoutCustomerNestedInput
    assignment?: AssignmentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityBaseId?: IntFieldUpdateOperationsInput | number
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutCustomerNestedInput
    assignment?: AssignmentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type RoleUpsertWithoutLoginInput = {
    update: XOR<RoleUpdateWithoutLoginInput, RoleUncheckedUpdateWithoutLoginInput>
    create: XOR<RoleCreateWithoutLoginInput, RoleUncheckedCreateWithoutLoginInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutLoginInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutLoginInput, RoleUncheckedUpdateWithoutLoginInput>
  }

  export type RoleUpdateWithoutLoginInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutLoginInput = {
    update: XOR<UserUpdateWithoutLoginInput, UserUncheckedUpdateWithoutLoginInput>
    create: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginInput, UserUncheckedUpdateWithoutLoginInput>
  }

  export type UserUpdateWithoutLoginInput = {
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userShop?: UserShopUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OtpUpsertWithWhereUniqueWithoutLoginInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutLoginInput, OtpUncheckedUpdateWithoutLoginInput>
    create: XOR<OtpCreateWithoutLoginInput, OtpUncheckedCreateWithoutLoginInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutLoginInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutLoginInput, OtpUncheckedUpdateWithoutLoginInput>
  }

  export type OtpUpdateManyWithWhereWithoutLoginInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutLoginInput>
  }

  export type OtpScalarWhereInput = {
    AND?: OtpScalarWhereInput | OtpScalarWhereInput[]
    OR?: OtpScalarWhereInput[]
    NOT?: OtpScalarWhereInput | OtpScalarWhereInput[]
    id?: IntFilter<"Otp"> | number
    to?: StringNullableFilter<"Otp"> | string | null
    code?: StringFilter<"Otp"> | string
    duration?: EnumOptDurationEnumFilter<"Otp"> | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFilter<"Otp"> | $Enums.OptViaEnum
    createdAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Otp"> | Date | string | null
    loginId?: IntNullableFilter<"Otp"> | number | null
  }

  export type LoginCreateWithoutOtpInput = {
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutLoginInput
    role?: RoleCreateNestedOneWithoutLoginInput
    user?: UserCreateNestedOneWithoutLoginInput
  }

  export type LoginUncheckedCreateWithoutOtpInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    roleId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerUncheckedCreateNestedOneWithoutLoginInput
    user?: UserUncheckedCreateNestedOneWithoutLoginInput
  }

  export type LoginCreateOrConnectWithoutOtpInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutOtpInput, LoginUncheckedCreateWithoutOtpInput>
  }

  export type LoginUpsertWithoutOtpInput = {
    update: XOR<LoginUpdateWithoutOtpInput, LoginUncheckedUpdateWithoutOtpInput>
    create: XOR<LoginCreateWithoutOtpInput, LoginUncheckedCreateWithoutOtpInput>
    where?: LoginWhereInput
  }

  export type LoginUpdateToOneWithWhereWithoutOtpInput = {
    where?: LoginWhereInput
    data: XOR<LoginUpdateWithoutOtpInput, LoginUncheckedUpdateWithoutOtpInput>
  }

  export type LoginUpdateWithoutOtpInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutLoginNestedInput
    role?: RoleUpdateOneWithoutLoginNestedInput
    user?: UserUpdateOneWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateWithoutOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUncheckedUpdateOneWithoutLoginNestedInput
    user?: UserUncheckedUpdateOneWithoutLoginNestedInput
  }

  export type LoginCreateWithoutUserInput = {
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutLoginInput
    role?: RoleCreateNestedOneWithoutLoginInput
    Otp?: OtpCreateNestedManyWithoutLoginInput
  }

  export type LoginUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    roleId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerUncheckedCreateNestedOneWithoutLoginInput
    Otp?: OtpUncheckedCreateNestedManyWithoutLoginInput
  }

  export type LoginCreateOrConnectWithoutUserInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
  }

  export type UserShopCreateWithoutUserInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
    shop: ShopCreateNestedOneWithoutUserShopInput
  }

  export type UserShopUncheckedCreateWithoutUserInput = {
    shopId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type UserShopCreateOrConnectWithoutUserInput = {
    where: UserShopWhereUniqueInput
    create: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput>
  }

  export type UserShopCreateManyUserInputEnvelope = {
    data: UserShopCreateManyUserInput | UserShopCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LoginUpsertWithoutUserInput = {
    update: XOR<LoginUpdateWithoutUserInput, LoginUncheckedUpdateWithoutUserInput>
    create: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
    where?: LoginWhereInput
  }

  export type LoginUpdateToOneWithWhereWithoutUserInput = {
    where?: LoginWhereInput
    data: XOR<LoginUpdateWithoutUserInput, LoginUncheckedUpdateWithoutUserInput>
  }

  export type LoginUpdateWithoutUserInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutLoginNestedInput
    role?: RoleUpdateOneWithoutLoginNestedInput
    Otp?: OtpUpdateManyWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUncheckedUpdateOneWithoutLoginNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutLoginNestedInput
  }

  export type UserShopUpsertWithWhereUniqueWithoutUserInput = {
    where: UserShopWhereUniqueInput
    update: XOR<UserShopUpdateWithoutUserInput, UserShopUncheckedUpdateWithoutUserInput>
    create: XOR<UserShopCreateWithoutUserInput, UserShopUncheckedCreateWithoutUserInput>
  }

  export type UserShopUpdateWithWhereUniqueWithoutUserInput = {
    where: UserShopWhereUniqueInput
    data: XOR<UserShopUpdateWithoutUserInput, UserShopUncheckedUpdateWithoutUserInput>
  }

  export type UserShopUpdateManyWithWhereWithoutUserInput = {
    where: UserShopScalarWhereInput
    data: XOR<UserShopUpdateManyMutationInput, UserShopUncheckedUpdateManyWithoutUserInput>
  }

  export type UserShopScalarWhereInput = {
    AND?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
    OR?: UserShopScalarWhereInput[]
    NOT?: UserShopScalarWhereInput | UserShopScalarWhereInput[]
    shopId?: IntFilter<"UserShop"> | number
    userId?: IntFilter<"UserShop"> | number
    isActive?: BoolFilter<"UserShop"> | boolean
    createdAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UserShop"> | Date | string | null
    role?: EnumUserShopRoleEnumFilter<"UserShop"> | $Enums.UserShopRoleEnum
  }

  export type LoginCreateWithoutCustomerInput = {
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role?: RoleCreateNestedOneWithoutLoginInput
    user?: UserCreateNestedOneWithoutLoginInput
    Otp?: OtpCreateNestedManyWithoutLoginInput
  }

  export type LoginUncheckedCreateWithoutCustomerInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    roleId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutLoginInput
    Otp?: OtpUncheckedCreateNestedManyWithoutLoginInput
  }

  export type LoginCreateOrConnectWithoutCustomerInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutCustomerInput, LoginUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAliasCreateWithoutCustomerInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    shop: ShopCreateNestedOneWithoutCustomerAliasInput
    dept?: DeptCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUncheckedCreateWithoutCustomerInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
    dept?: DeptUncheckedCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusUncheckedCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasCreateOrConnectWithoutCustomerInput = {
    where: CustomerAliasWhereUniqueInput
    create: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAliasCreateManyCustomerInputEnvelope = {
    data: CustomerAliasCreateManyCustomerInput | CustomerAliasCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type WalletBaseCreateWithoutCustomerInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionCreateNestedManyWithoutFromInput
    toTransaction?: TransactionCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusCreateNestedManyWithoutWalletBaseInput
    shop?: ShopCreateNestedOneWithoutEntityBaseInput
  }

  export type WalletBaseUncheckedCreateWithoutCustomerInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionUncheckedCreateNestedManyWithoutFromInput
    toTransaction?: TransactionUncheckedCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput
    shop?: ShopUncheckedCreateNestedOneWithoutEntityBaseInput
  }

  export type WalletBaseCreateOrConnectWithoutCustomerInput = {
    where: WalletBaseWhereUniqueInput
    create: XOR<WalletBaseCreateWithoutCustomerInput, WalletBaseUncheckedCreateWithoutCustomerInput>
  }

  export type AssignmentCreateWithoutCustomerInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    card: CardCreateNestedOneWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutCustomerInput = {
    cardId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type AssignmentCreateOrConnectWithoutCustomerInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput>
  }

  export type AssignmentCreateManyCustomerInputEnvelope = {
    data: AssignmentCreateManyCustomerInput | AssignmentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LoginUpsertWithoutCustomerInput = {
    update: XOR<LoginUpdateWithoutCustomerInput, LoginUncheckedUpdateWithoutCustomerInput>
    create: XOR<LoginCreateWithoutCustomerInput, LoginUncheckedCreateWithoutCustomerInput>
    where?: LoginWhereInput
  }

  export type LoginUpdateToOneWithWhereWithoutCustomerInput = {
    where?: LoginWhereInput
    data: XOR<LoginUpdateWithoutCustomerInput, LoginUncheckedUpdateWithoutCustomerInput>
  }

  export type LoginUpdateWithoutCustomerInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneWithoutLoginNestedInput
    user?: UserUpdateOneWithoutLoginNestedInput
    Otp?: OtpUpdateManyWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutLoginNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutLoginNestedInput
  }

  export type CustomerAliasUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAliasWhereUniqueInput
    update: XOR<CustomerAliasUpdateWithoutCustomerInput, CustomerAliasUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAliasCreateWithoutCustomerInput, CustomerAliasUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAliasUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAliasWhereUniqueInput
    data: XOR<CustomerAliasUpdateWithoutCustomerInput, CustomerAliasUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAliasUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAliasScalarWhereInput
    data: XOR<CustomerAliasUpdateManyMutationInput, CustomerAliasUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAliasScalarWhereInput = {
    AND?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
    OR?: CustomerAliasScalarWhereInput[]
    NOT?: CustomerAliasScalarWhereInput | CustomerAliasScalarWhereInput[]
    id?: IntFilter<"CustomerAlias"> | number
    customerId?: IntFilter<"CustomerAlias"> | number
    createdAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CustomerAlias"> | Date | string | null
    byId?: IntNullableFilter<"CustomerAlias"> | number | null
    shopId?: IntFilter<"CustomerAlias"> | number
    isActive?: BoolFilter<"CustomerAlias"> | boolean
  }

  export type WalletBaseUpsertWithoutCustomerInput = {
    update: XOR<WalletBaseUpdateWithoutCustomerInput, WalletBaseUncheckedUpdateWithoutCustomerInput>
    create: XOR<WalletBaseCreateWithoutCustomerInput, WalletBaseUncheckedCreateWithoutCustomerInput>
    where?: WalletBaseWhereInput
  }

  export type WalletBaseUpdateToOneWithWhereWithoutCustomerInput = {
    where?: WalletBaseWhereInput
    data: XOR<WalletBaseUpdateWithoutCustomerInput, WalletBaseUncheckedUpdateWithoutCustomerInput>
  }

  export type WalletBaseUpdateWithoutCustomerInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUpdateOneWithoutEntityBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUncheckedUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUncheckedUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUncheckedUpdateOneWithoutEntityBaseNestedInput
  }

  export type AssignmentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutCustomerInput, AssignmentUncheckedUpdateWithoutCustomerInput>
    create: XOR<AssignmentCreateWithoutCustomerInput, AssignmentUncheckedCreateWithoutCustomerInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutCustomerInput, AssignmentUncheckedUpdateWithoutCustomerInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutCustomerInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    customerId?: IntFilter<"Assignment"> | number
    cardId?: IntFilter<"Assignment"> | number
    isActive?: BoolFilter<"Assignment"> | boolean
    createdAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    byId?: IntNullableFilter<"Assignment"> | number | null
  }

  export type ShopCreateWithoutCustomerAliasInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutCustomerAliasInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutCustomerAliasInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutCustomerAliasInput, ShopUncheckedCreateWithoutCustomerAliasInput>
  }

  export type CustomerCreateWithoutCustomerAliasInput = {
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    Login?: LoginCreateNestedOneWithoutCustomerInput
    WalletBase: WalletBaseCreateNestedOneWithoutCustomerInput
    assignment?: AssignmentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerAliasInput = {
    id?: number
    loginId?: number | null
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    entityBaseId: number
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerAliasInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerAliasInput, CustomerUncheckedCreateWithoutCustomerAliasInput>
  }

  export type DeptCreateWithoutCustomerAliasInput = {
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DeptUncheckedCreateWithoutCustomerAliasInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DeptCreateOrConnectWithoutCustomerAliasInput = {
    where: DeptWhereUniqueInput
    create: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput>
  }

  export type DeptCreateManyCustomerAliasInputEnvelope = {
    data: DeptCreateManyCustomerAliasInput | DeptCreateManyCustomerAliasInput[]
    skipDuplicates?: boolean
  }

  export type DebtStatusCreateWithoutCustomerAliasInput = {
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DebtStatusUncheckedCreateWithoutCustomerAliasInput = {
    id?: number
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DebtStatusCreateOrConnectWithoutCustomerAliasInput = {
    where: DebtStatusWhereUniqueInput
    create: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput>
  }

  export type DebtStatusCreateManyCustomerAliasInputEnvelope = {
    data: DebtStatusCreateManyCustomerAliasInput | DebtStatusCreateManyCustomerAliasInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutCustomerAliasInput = {
    update: XOR<ShopUpdateWithoutCustomerAliasInput, ShopUncheckedUpdateWithoutCustomerAliasInput>
    create: XOR<ShopCreateWithoutCustomerAliasInput, ShopUncheckedCreateWithoutCustomerAliasInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutCustomerAliasInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutCustomerAliasInput, ShopUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type ShopUpdateWithoutCustomerAliasInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type CustomerUpsertWithoutCustomerAliasInput = {
    update: XOR<CustomerUpdateWithoutCustomerAliasInput, CustomerUncheckedUpdateWithoutCustomerAliasInput>
    create: XOR<CustomerCreateWithoutCustomerAliasInput, CustomerUncheckedCreateWithoutCustomerAliasInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerAliasInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerAliasInput, CustomerUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type CustomerUpdateWithoutCustomerAliasInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Login?: LoginUpdateOneWithoutCustomerNestedInput
    WalletBase?: WalletBaseUpdateOneRequiredWithoutCustomerNestedInput
    assignment?: AssignmentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityBaseId?: IntFieldUpdateOperationsInput | number
    assignment?: AssignmentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type DeptUpsertWithWhereUniqueWithoutCustomerAliasInput = {
    where: DeptWhereUniqueInput
    update: XOR<DeptUpdateWithoutCustomerAliasInput, DeptUncheckedUpdateWithoutCustomerAliasInput>
    create: XOR<DeptCreateWithoutCustomerAliasInput, DeptUncheckedCreateWithoutCustomerAliasInput>
  }

  export type DeptUpdateWithWhereUniqueWithoutCustomerAliasInput = {
    where: DeptWhereUniqueInput
    data: XOR<DeptUpdateWithoutCustomerAliasInput, DeptUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type DeptUpdateManyWithWhereWithoutCustomerAliasInput = {
    where: DeptScalarWhereInput
    data: XOR<DeptUpdateManyMutationInput, DeptUncheckedUpdateManyWithoutCustomerAliasInput>
  }

  export type DeptScalarWhereInput = {
    AND?: DeptScalarWhereInput | DeptScalarWhereInput[]
    OR?: DeptScalarWhereInput[]
    NOT?: DeptScalarWhereInput | DeptScalarWhereInput[]
    id?: IntFilter<"Dept"> | number
    amount?: DecimalFilter<"Dept"> | Decimal | DecimalJsLike | number | string
    comment?: StringNullableFilter<"Dept"> | string | null
    type?: EnumTransactionTypeEnumFilter<"Dept"> | $Enums.TransactionTypeEnum
    customerAliasId?: IntFilter<"Dept"> | number
    createdAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Dept"> | Date | string | null
  }

  export type DebtStatusUpsertWithWhereUniqueWithoutCustomerAliasInput = {
    where: DebtStatusWhereUniqueInput
    update: XOR<DebtStatusUpdateWithoutCustomerAliasInput, DebtStatusUncheckedUpdateWithoutCustomerAliasInput>
    create: XOR<DebtStatusCreateWithoutCustomerAliasInput, DebtStatusUncheckedCreateWithoutCustomerAliasInput>
  }

  export type DebtStatusUpdateWithWhereUniqueWithoutCustomerAliasInput = {
    where: DebtStatusWhereUniqueInput
    data: XOR<DebtStatusUpdateWithoutCustomerAliasInput, DebtStatusUncheckedUpdateWithoutCustomerAliasInput>
  }

  export type DebtStatusUpdateManyWithWhereWithoutCustomerAliasInput = {
    where: DebtStatusScalarWhereInput
    data: XOR<DebtStatusUpdateManyMutationInput, DebtStatusUncheckedUpdateManyWithoutCustomerAliasInput>
  }

  export type DebtStatusScalarWhereInput = {
    AND?: DebtStatusScalarWhereInput | DebtStatusScalarWhereInput[]
    OR?: DebtStatusScalarWhereInput[]
    NOT?: DebtStatusScalarWhereInput | DebtStatusScalarWhereInput[]
    id?: IntFilter<"DebtStatus"> | number
    totalCredit?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFilter<"DebtStatus"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"DebtStatus"> | Date | string | null
    customerAliasId?: IntFilter<"DebtStatus"> | number
  }

  export type CustomerAliasCreateWithoutDebtStatusInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    shop: ShopCreateNestedOneWithoutCustomerAliasInput
    customer: CustomerCreateNestedOneWithoutCustomerAliasInput
    dept?: DeptCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUncheckedCreateWithoutDebtStatusInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
    dept?: DeptUncheckedCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasCreateOrConnectWithoutDebtStatusInput = {
    where: CustomerAliasWhereUniqueInput
    create: XOR<CustomerAliasCreateWithoutDebtStatusInput, CustomerAliasUncheckedCreateWithoutDebtStatusInput>
  }

  export type CustomerAliasUpsertWithoutDebtStatusInput = {
    update: XOR<CustomerAliasUpdateWithoutDebtStatusInput, CustomerAliasUncheckedUpdateWithoutDebtStatusInput>
    create: XOR<CustomerAliasCreateWithoutDebtStatusInput, CustomerAliasUncheckedCreateWithoutDebtStatusInput>
    where?: CustomerAliasWhereInput
  }

  export type CustomerAliasUpdateToOneWithWhereWithoutDebtStatusInput = {
    where?: CustomerAliasWhereInput
    data: XOR<CustomerAliasUpdateWithoutDebtStatusInput, CustomerAliasUncheckedUpdateWithoutDebtStatusInput>
  }

  export type CustomerAliasUpdateWithoutDebtStatusInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shop?: ShopUpdateOneRequiredWithoutCustomerAliasNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCustomerAliasNestedInput
    dept?: DeptUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateWithoutDebtStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dept?: DeptUncheckedUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasCreateWithoutDeptInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    shop: ShopCreateNestedOneWithoutCustomerAliasInput
    customer: CustomerCreateNestedOneWithoutCustomerAliasInput
    debtStatus?: DebtStatusCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUncheckedCreateWithoutDeptInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
    debtStatus?: DebtStatusUncheckedCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasCreateOrConnectWithoutDeptInput = {
    where: CustomerAliasWhereUniqueInput
    create: XOR<CustomerAliasCreateWithoutDeptInput, CustomerAliasUncheckedCreateWithoutDeptInput>
  }

  export type CustomerAliasUpsertWithoutDeptInput = {
    update: XOR<CustomerAliasUpdateWithoutDeptInput, CustomerAliasUncheckedUpdateWithoutDeptInput>
    create: XOR<CustomerAliasCreateWithoutDeptInput, CustomerAliasUncheckedCreateWithoutDeptInput>
    where?: CustomerAliasWhereInput
  }

  export type CustomerAliasUpdateToOneWithWhereWithoutDeptInput = {
    where?: CustomerAliasWhereInput
    data: XOR<CustomerAliasUpdateWithoutDeptInput, CustomerAliasUncheckedUpdateWithoutDeptInput>
  }

  export type CustomerAliasUpdateWithoutDeptInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shop?: ShopUpdateOneRequiredWithoutCustomerAliasNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateWithoutDeptInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    debtStatus?: DebtStatusUncheckedUpdateManyWithoutCustomerAliasNestedInput
  }

  export type WalletBaseCreateWithoutShopInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionCreateNestedManyWithoutFromInput
    toTransaction?: TransactionCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusCreateNestedManyWithoutWalletBaseInput
    customer?: CustomerCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUncheckedCreateWithoutShopInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionUncheckedCreateNestedManyWithoutFromInput
    toTransaction?: TransactionUncheckedCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput
    customer?: CustomerUncheckedCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseCreateOrConnectWithoutShopInput = {
    where: WalletBaseWhereUniqueInput
    create: XOR<WalletBaseCreateWithoutShopInput, WalletBaseUncheckedCreateWithoutShopInput>
  }

  export type CardAllocationCreateWithoutShopInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocationDetail?: CardAllocationDetailCreateNestedManyWithoutCardAllocationInput
  }

  export type CardAllocationUncheckedCreateWithoutShopInput = {
    id?: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedCreateNestedManyWithoutCardAllocationInput
  }

  export type CardAllocationCreateOrConnectWithoutShopInput = {
    where: CardAllocationWhereUniqueInput
    create: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput>
  }

  export type CardAllocationCreateManyShopInputEnvelope = {
    data: CardAllocationCreateManyShopInput | CardAllocationCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UserShopCreateWithoutShopInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
    user: UserCreateNestedOneWithoutUserShopInput
  }

  export type UserShopUncheckedCreateWithoutShopInput = {
    userId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type UserShopCreateOrConnectWithoutShopInput = {
    where: UserShopWhereUniqueInput
    create: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput>
  }

  export type UserShopCreateManyShopInputEnvelope = {
    data: UserShopCreateManyShopInput | UserShopCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type CustomerAliasCreateWithoutShopInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    customer: CustomerCreateNestedOneWithoutCustomerAliasInput
    dept?: DeptCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasUncheckedCreateWithoutShopInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
    dept?: DeptUncheckedCreateNestedManyWithoutCustomerAliasInput
    debtStatus?: DebtStatusUncheckedCreateNestedManyWithoutCustomerAliasInput
  }

  export type CustomerAliasCreateOrConnectWithoutShopInput = {
    where: CustomerAliasWhereUniqueInput
    create: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput>
  }

  export type CustomerAliasCreateManyShopInputEnvelope = {
    data: CustomerAliasCreateManyShopInput | CustomerAliasCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutShopInput = {
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    offer?: OfferCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutShopInput = {
    id?: number
    offerId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutShopInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput>
  }

  export type PaymentCreateManyShopInputEnvelope = {
    data: PaymentCreateManyShopInput | PaymentCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type CardRequestCreateWithoutShopInput = {
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    cardrequeststatus?: CardRequestStatusCreateNestedOneWithoutCardRequestInput
  }

  export type CardRequestUncheckedCreateWithoutShopInput = {
    id?: number
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    cardrequeststatus?: CardRequestStatusUncheckedCreateNestedOneWithoutCardRequestInput
  }

  export type CardRequestCreateOrConnectWithoutShopInput = {
    where: CardRequestWhereUniqueInput
    create: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
  }

  export type WalletBaseUpsertWithoutShopInput = {
    update: XOR<WalletBaseUpdateWithoutShopInput, WalletBaseUncheckedUpdateWithoutShopInput>
    create: XOR<WalletBaseCreateWithoutShopInput, WalletBaseUncheckedCreateWithoutShopInput>
    where?: WalletBaseWhereInput
  }

  export type WalletBaseUpdateToOneWithWhereWithoutShopInput = {
    where?: WalletBaseWhereInput
    data: XOR<WalletBaseUpdateWithoutShopInput, WalletBaseUncheckedUpdateWithoutShopInput>
  }

  export type WalletBaseUpdateWithoutShopInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUpdateManyWithoutWalletBaseNestedInput
    customer?: CustomerUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUncheckedUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUncheckedUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput
  }

  export type CardAllocationUpsertWithWhereUniqueWithoutShopInput = {
    where: CardAllocationWhereUniqueInput
    update: XOR<CardAllocationUpdateWithoutShopInput, CardAllocationUncheckedUpdateWithoutShopInput>
    create: XOR<CardAllocationCreateWithoutShopInput, CardAllocationUncheckedCreateWithoutShopInput>
  }

  export type CardAllocationUpdateWithWhereUniqueWithoutShopInput = {
    where: CardAllocationWhereUniqueInput
    data: XOR<CardAllocationUpdateWithoutShopInput, CardAllocationUncheckedUpdateWithoutShopInput>
  }

  export type CardAllocationUpdateManyWithWhereWithoutShopInput = {
    where: CardAllocationScalarWhereInput
    data: XOR<CardAllocationUpdateManyMutationInput, CardAllocationUncheckedUpdateManyWithoutShopInput>
  }

  export type CardAllocationScalarWhereInput = {
    AND?: CardAllocationScalarWhereInput | CardAllocationScalarWhereInput[]
    OR?: CardAllocationScalarWhereInput[]
    NOT?: CardAllocationScalarWhereInput | CardAllocationScalarWhereInput[]
    id?: IntFilter<"CardAllocation"> | number
    isActive?: BoolFilter<"CardAllocation"> | boolean
    createdAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CardAllocation"> | Date | string | null
    shopId?: IntFilter<"CardAllocation"> | number
    byId?: IntNullableFilter<"CardAllocation"> | number | null
  }

  export type UserShopUpsertWithWhereUniqueWithoutShopInput = {
    where: UserShopWhereUniqueInput
    update: XOR<UserShopUpdateWithoutShopInput, UserShopUncheckedUpdateWithoutShopInput>
    create: XOR<UserShopCreateWithoutShopInput, UserShopUncheckedCreateWithoutShopInput>
  }

  export type UserShopUpdateWithWhereUniqueWithoutShopInput = {
    where: UserShopWhereUniqueInput
    data: XOR<UserShopUpdateWithoutShopInput, UserShopUncheckedUpdateWithoutShopInput>
  }

  export type UserShopUpdateManyWithWhereWithoutShopInput = {
    where: UserShopScalarWhereInput
    data: XOR<UserShopUpdateManyMutationInput, UserShopUncheckedUpdateManyWithoutShopInput>
  }

  export type CustomerAliasUpsertWithWhereUniqueWithoutShopInput = {
    where: CustomerAliasWhereUniqueInput
    update: XOR<CustomerAliasUpdateWithoutShopInput, CustomerAliasUncheckedUpdateWithoutShopInput>
    create: XOR<CustomerAliasCreateWithoutShopInput, CustomerAliasUncheckedCreateWithoutShopInput>
  }

  export type CustomerAliasUpdateWithWhereUniqueWithoutShopInput = {
    where: CustomerAliasWhereUniqueInput
    data: XOR<CustomerAliasUpdateWithoutShopInput, CustomerAliasUncheckedUpdateWithoutShopInput>
  }

  export type CustomerAliasUpdateManyWithWhereWithoutShopInput = {
    where: CustomerAliasScalarWhereInput
    data: XOR<CustomerAliasUpdateManyMutationInput, CustomerAliasUncheckedUpdateManyWithoutShopInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutShopInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutShopInput, PaymentUncheckedUpdateWithoutShopInput>
    create: XOR<PaymentCreateWithoutShopInput, PaymentUncheckedCreateWithoutShopInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutShopInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutShopInput, PaymentUncheckedUpdateWithoutShopInput>
  }

  export type PaymentUpdateManyWithWhereWithoutShopInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutShopInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    shopId?: IntFilter<"Payment"> | number
    offerId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    byId?: IntFilter<"Payment"> | number
    expirationDate?: DateTimeFilter<"Payment"> | Date | string
    isActive?: BoolFilter<"Payment"> | boolean
    createdAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type CardRequestUpsertWithoutShopInput = {
    update: XOR<CardRequestUpdateWithoutShopInput, CardRequestUncheckedUpdateWithoutShopInput>
    create: XOR<CardRequestCreateWithoutShopInput, CardRequestUncheckedCreateWithoutShopInput>
    where?: CardRequestWhereInput
  }

  export type CardRequestUpdateToOneWithWhereWithoutShopInput = {
    where?: CardRequestWhereInput
    data: XOR<CardRequestUpdateWithoutShopInput, CardRequestUncheckedUpdateWithoutShopInput>
  }

  export type CardRequestUpdateWithoutShopInput = {
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardrequeststatus?: CardRequestStatusUpdateOneWithoutCardRequestNestedInput
  }

  export type CardRequestUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardrequeststatus?: CardRequestStatusUncheckedUpdateOneWithoutCardRequestNestedInput
  }

  export type ShopCreateWithoutUserShopInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutUserShopInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutUserShopInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutUserShopInput, ShopUncheckedCreateWithoutUserShopInput>
  }

  export type UserCreateWithoutUserShopInput = {
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    login?: LoginCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserShopInput = {
    id?: number
    loginId?: number | null
    displayname: string
    email?: string | null
    address: string
    phone: string
    dateOfBirth?: Date | string | null
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
  }

  export type UserCreateOrConnectWithoutUserShopInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserShopInput, UserUncheckedCreateWithoutUserShopInput>
  }

  export type ShopUpsertWithoutUserShopInput = {
    update: XOR<ShopUpdateWithoutUserShopInput, ShopUncheckedUpdateWithoutUserShopInput>
    create: XOR<ShopCreateWithoutUserShopInput, ShopUncheckedCreateWithoutUserShopInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutUserShopInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutUserShopInput, ShopUncheckedUpdateWithoutUserShopInput>
  }

  export type ShopUpdateWithoutUserShopInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutUserShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type UserUpsertWithoutUserShopInput = {
    update: XOR<UserUpdateWithoutUserShopInput, UserUncheckedUpdateWithoutUserShopInput>
    create: XOR<UserCreateWithoutUserShopInput, UserUncheckedCreateWithoutUserShopInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserShopInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserShopInput, UserUncheckedUpdateWithoutUserShopInput>
  }

  export type UserUpdateWithoutUserShopInput = {
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    login?: LoginUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    displayname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransactionCreateWithoutFromInput = {
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
    to: WalletBaseCreateNestedOneWithoutToTransactionInput
  }

  export type TransactionUncheckedCreateWithoutFromInput = {
    id?: number
    toId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type TransactionCreateOrConnectWithoutFromInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput>
  }

  export type TransactionCreateManyFromInputEnvelope = {
    data: TransactionCreateManyFromInput | TransactionCreateManyFromInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutToInput = {
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
    from: WalletBaseCreateNestedOneWithoutFromTransactionInput
  }

  export type TransactionUncheckedCreateWithoutToInput = {
    id?: number
    fromId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type TransactionCreateOrConnectWithoutToInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput>
  }

  export type TransactionCreateManyToInputEnvelope = {
    data: TransactionCreateManyToInput | TransactionCreateManyToInput[]
    skipDuplicates?: boolean
  }

  export type WalletStatusCreateWithoutWalletBaseInput = {
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
  }

  export type WalletStatusUncheckedCreateWithoutWalletBaseInput = {
    id?: number
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
  }

  export type WalletStatusCreateOrConnectWithoutWalletBaseInput = {
    where: WalletStatusWhereUniqueInput
    create: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput>
  }

  export type WalletStatusCreateManyWalletBaseInputEnvelope = {
    data: WalletStatusCreateManyWalletBaseInput | WalletStatusCreateManyWalletBaseInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutEntityBaseInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutEntityBaseInput = {
    id?: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutEntityBaseInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
  }

  export type CustomerCreateWithoutWalletBaseInput = {
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    Login?: LoginCreateNestedOneWithoutCustomerInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutCustomerInput
    assignment?: AssignmentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutWalletBaseInput = {
    id?: number
    loginId?: number | null
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutCustomerInput
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutWalletBaseInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutFromInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFromInput, TransactionUncheckedUpdateWithoutFromInput>
    create: XOR<TransactionCreateWithoutFromInput, TransactionUncheckedCreateWithoutFromInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFromInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFromInput, TransactionUncheckedUpdateWithoutFromInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFromInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFromInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    fromId?: IntFilter<"Transaction"> | number
    toId?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    walletBaseId?: IntNullableFilter<"Transaction"> | number | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutToInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutToInput, TransactionUncheckedUpdateWithoutToInput>
    create: XOR<TransactionCreateWithoutToInput, TransactionUncheckedCreateWithoutToInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutToInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutToInput, TransactionUncheckedUpdateWithoutToInput>
  }

  export type TransactionUpdateManyWithWhereWithoutToInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutToInput>
  }

  export type WalletStatusUpsertWithWhereUniqueWithoutWalletBaseInput = {
    where: WalletStatusWhereUniqueInput
    update: XOR<WalletStatusUpdateWithoutWalletBaseInput, WalletStatusUncheckedUpdateWithoutWalletBaseInput>
    create: XOR<WalletStatusCreateWithoutWalletBaseInput, WalletStatusUncheckedCreateWithoutWalletBaseInput>
  }

  export type WalletStatusUpdateWithWhereUniqueWithoutWalletBaseInput = {
    where: WalletStatusWhereUniqueInput
    data: XOR<WalletStatusUpdateWithoutWalletBaseInput, WalletStatusUncheckedUpdateWithoutWalletBaseInput>
  }

  export type WalletStatusUpdateManyWithWhereWithoutWalletBaseInput = {
    where: WalletStatusScalarWhereInput
    data: XOR<WalletStatusUpdateManyMutationInput, WalletStatusUncheckedUpdateManyWithoutWalletBaseInput>
  }

  export type WalletStatusScalarWhereInput = {
    AND?: WalletStatusScalarWhereInput | WalletStatusScalarWhereInput[]
    OR?: WalletStatusScalarWhereInput[]
    NOT?: WalletStatusScalarWhereInput | WalletStatusScalarWhereInput[]
    id?: IntFilter<"WalletStatus"> | number
    totalDebit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFilter<"WalletStatus"> | Decimal | DecimalJsLike | number | string
    walletBaseId?: IntFilter<"WalletStatus"> | number
    createdAt?: DateTimeNullableFilter<"WalletStatus"> | Date | string | null
  }

  export type ShopUpsertWithoutEntityBaseInput = {
    update: XOR<ShopUpdateWithoutEntityBaseInput, ShopUncheckedUpdateWithoutEntityBaseInput>
    create: XOR<ShopCreateWithoutEntityBaseInput, ShopUncheckedCreateWithoutEntityBaseInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutEntityBaseInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutEntityBaseInput, ShopUncheckedUpdateWithoutEntityBaseInput>
  }

  export type ShopUpdateWithoutEntityBaseInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutEntityBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type CustomerUpsertWithoutWalletBaseInput = {
    update: XOR<CustomerUpdateWithoutWalletBaseInput, CustomerUncheckedUpdateWithoutWalletBaseInput>
    create: XOR<CustomerCreateWithoutWalletBaseInput, CustomerUncheckedCreateWithoutWalletBaseInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutWalletBaseInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutWalletBaseInput, CustomerUncheckedUpdateWithoutWalletBaseInput>
  }

  export type CustomerUpdateWithoutWalletBaseInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Login?: LoginUpdateOneWithoutCustomerNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutCustomerNestedInput
    assignment?: AssignmentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutWalletBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutCustomerNestedInput
    assignment?: AssignmentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type WalletBaseCreateWithoutWalletStatusInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionCreateNestedManyWithoutFromInput
    toTransaction?: TransactionCreateNestedManyWithoutToInput
    shop?: ShopCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUncheckedCreateWithoutWalletStatusInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionUncheckedCreateNestedManyWithoutFromInput
    toTransaction?: TransactionUncheckedCreateNestedManyWithoutToInput
    shop?: ShopUncheckedCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerUncheckedCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseCreateOrConnectWithoutWalletStatusInput = {
    where: WalletBaseWhereUniqueInput
    create: XOR<WalletBaseCreateWithoutWalletStatusInput, WalletBaseUncheckedCreateWithoutWalletStatusInput>
  }

  export type WalletBaseUpsertWithoutWalletStatusInput = {
    update: XOR<WalletBaseUpdateWithoutWalletStatusInput, WalletBaseUncheckedUpdateWithoutWalletStatusInput>
    create: XOR<WalletBaseCreateWithoutWalletStatusInput, WalletBaseUncheckedCreateWithoutWalletStatusInput>
    where?: WalletBaseWhereInput
  }

  export type WalletBaseUpdateToOneWithWhereWithoutWalletStatusInput = {
    where?: WalletBaseWhereInput
    data: XOR<WalletBaseUpdateWithoutWalletStatusInput, WalletBaseUncheckedUpdateWithoutWalletStatusInput>
  }

  export type WalletBaseUpdateWithoutWalletStatusInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUpdateManyWithoutToNestedInput
    shop?: ShopUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateWithoutWalletStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUncheckedUpdateManyWithoutFromNestedInput
    toTransaction?: TransactionUncheckedUpdateManyWithoutToNestedInput
    shop?: ShopUncheckedUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseCreateWithoutFromTransactionInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    toTransaction?: TransactionCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusCreateNestedManyWithoutWalletBaseInput
    shop?: ShopCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUncheckedCreateWithoutFromTransactionInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    toTransaction?: TransactionUncheckedCreateNestedManyWithoutToInput
    walletStatus?: WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput
    shop?: ShopUncheckedCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerUncheckedCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseCreateOrConnectWithoutFromTransactionInput = {
    where: WalletBaseWhereUniqueInput
    create: XOR<WalletBaseCreateWithoutFromTransactionInput, WalletBaseUncheckedCreateWithoutFromTransactionInput>
  }

  export type WalletBaseCreateWithoutToTransactionInput = {
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionCreateNestedManyWithoutFromInput
    walletStatus?: WalletStatusCreateNestedManyWithoutWalletBaseInput
    shop?: ShopCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseUncheckedCreateWithoutToTransactionInput = {
    id?: number
    type: $Enums.EntityEnum
    isActive?: boolean
    fromTransaction?: TransactionUncheckedCreateNestedManyWithoutFromInput
    walletStatus?: WalletStatusUncheckedCreateNestedManyWithoutWalletBaseInput
    shop?: ShopUncheckedCreateNestedOneWithoutEntityBaseInput
    customer?: CustomerUncheckedCreateNestedOneWithoutWalletBaseInput
  }

  export type WalletBaseCreateOrConnectWithoutToTransactionInput = {
    where: WalletBaseWhereUniqueInput
    create: XOR<WalletBaseCreateWithoutToTransactionInput, WalletBaseUncheckedCreateWithoutToTransactionInput>
  }

  export type WalletBaseUpsertWithoutFromTransactionInput = {
    update: XOR<WalletBaseUpdateWithoutFromTransactionInput, WalletBaseUncheckedUpdateWithoutFromTransactionInput>
    create: XOR<WalletBaseCreateWithoutFromTransactionInput, WalletBaseUncheckedCreateWithoutFromTransactionInput>
    where?: WalletBaseWhereInput
  }

  export type WalletBaseUpdateToOneWithWhereWithoutFromTransactionInput = {
    where?: WalletBaseWhereInput
    data: XOR<WalletBaseUpdateWithoutFromTransactionInput, WalletBaseUncheckedUpdateWithoutFromTransactionInput>
  }

  export type WalletBaseUpdateWithoutFromTransactionInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    toTransaction?: TransactionUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateWithoutFromTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    toTransaction?: TransactionUncheckedUpdateManyWithoutToNestedInput
    walletStatus?: WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUncheckedUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUpsertWithoutToTransactionInput = {
    update: XOR<WalletBaseUpdateWithoutToTransactionInput, WalletBaseUncheckedUpdateWithoutToTransactionInput>
    create: XOR<WalletBaseCreateWithoutToTransactionInput, WalletBaseUncheckedCreateWithoutToTransactionInput>
    where?: WalletBaseWhereInput
  }

  export type WalletBaseUpdateToOneWithWhereWithoutToTransactionInput = {
    where?: WalletBaseWhereInput
    data: XOR<WalletBaseUpdateWithoutToTransactionInput, WalletBaseUncheckedUpdateWithoutToTransactionInput>
  }

  export type WalletBaseUpdateWithoutToTransactionInput = {
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUpdateManyWithoutFromNestedInput
    walletStatus?: WalletStatusUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUpdateOneWithoutWalletBaseNestedInput
  }

  export type WalletBaseUncheckedUpdateWithoutToTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEntityEnumFieldUpdateOperationsInput | $Enums.EntityEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fromTransaction?: TransactionUncheckedUpdateManyWithoutFromNestedInput
    walletStatus?: WalletStatusUncheckedUpdateManyWithoutWalletBaseNestedInput
    shop?: ShopUncheckedUpdateOneWithoutEntityBaseNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutWalletBaseNestedInput
  }

  export type AssignmentCreateWithoutCardInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    customer: CustomerCreateNestedOneWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutCardInput = {
    customerId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type AssignmentCreateOrConnectWithoutCardInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput>
  }

  export type AssignmentCreateManyCardInputEnvelope = {
    data: AssignmentCreateManyCardInput | AssignmentCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type CardAllocationDetailCreateWithoutCardInput = {
    cardAllocation: CardAllocationCreateNestedOneWithoutCardAllocationDetailInput
  }

  export type CardAllocationDetailUncheckedCreateWithoutCardInput = {
    cardAllocationId: number
  }

  export type CardAllocationDetailCreateOrConnectWithoutCardInput = {
    where: CardAllocationDetailWhereUniqueInput
    create: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput>
  }

  export type CardAllocationDetailCreateManyCardInputEnvelope = {
    data: CardAllocationDetailCreateManyCardInput | CardAllocationDetailCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutCardInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutCardInput, AssignmentUncheckedUpdateWithoutCardInput>
    create: XOR<AssignmentCreateWithoutCardInput, AssignmentUncheckedCreateWithoutCardInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutCardInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutCardInput, AssignmentUncheckedUpdateWithoutCardInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutCardInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutCardInput>
  }

  export type CardAllocationDetailUpsertWithWhereUniqueWithoutCardInput = {
    where: CardAllocationDetailWhereUniqueInput
    update: XOR<CardAllocationDetailUpdateWithoutCardInput, CardAllocationDetailUncheckedUpdateWithoutCardInput>
    create: XOR<CardAllocationDetailCreateWithoutCardInput, CardAllocationDetailUncheckedCreateWithoutCardInput>
  }

  export type CardAllocationDetailUpdateWithWhereUniqueWithoutCardInput = {
    where: CardAllocationDetailWhereUniqueInput
    data: XOR<CardAllocationDetailUpdateWithoutCardInput, CardAllocationDetailUncheckedUpdateWithoutCardInput>
  }

  export type CardAllocationDetailUpdateManyWithWhereWithoutCardInput = {
    where: CardAllocationDetailScalarWhereInput
    data: XOR<CardAllocationDetailUpdateManyMutationInput, CardAllocationDetailUncheckedUpdateManyWithoutCardInput>
  }

  export type CardAllocationDetailScalarWhereInput = {
    AND?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
    OR?: CardAllocationDetailScalarWhereInput[]
    NOT?: CardAllocationDetailScalarWhereInput | CardAllocationDetailScalarWhereInput[]
    cardId?: IntFilter<"CardAllocationDetail"> | number
    cardAllocationId?: IntFilter<"CardAllocationDetail"> | number
  }

  export type ShopCreateWithoutCardAllocationInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutCardAllocationInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutCardAllocationInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutCardAllocationInput, ShopUncheckedCreateWithoutCardAllocationInput>
  }

  export type CardAllocationDetailCreateWithoutCardAllocationInput = {
    card: CardCreateNestedOneWithoutCardAllocationDetailInput
  }

  export type CardAllocationDetailUncheckedCreateWithoutCardAllocationInput = {
    cardId: number
  }

  export type CardAllocationDetailCreateOrConnectWithoutCardAllocationInput = {
    where: CardAllocationDetailWhereUniqueInput
    create: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput>
  }

  export type CardAllocationDetailCreateManyCardAllocationInputEnvelope = {
    data: CardAllocationDetailCreateManyCardAllocationInput | CardAllocationDetailCreateManyCardAllocationInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutCardAllocationInput = {
    update: XOR<ShopUpdateWithoutCardAllocationInput, ShopUncheckedUpdateWithoutCardAllocationInput>
    create: XOR<ShopCreateWithoutCardAllocationInput, ShopUncheckedCreateWithoutCardAllocationInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutCardAllocationInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutCardAllocationInput, ShopUncheckedUpdateWithoutCardAllocationInput>
  }

  export type ShopUpdateWithoutCardAllocationInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutCardAllocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type CardAllocationDetailUpsertWithWhereUniqueWithoutCardAllocationInput = {
    where: CardAllocationDetailWhereUniqueInput
    update: XOR<CardAllocationDetailUpdateWithoutCardAllocationInput, CardAllocationDetailUncheckedUpdateWithoutCardAllocationInput>
    create: XOR<CardAllocationDetailCreateWithoutCardAllocationInput, CardAllocationDetailUncheckedCreateWithoutCardAllocationInput>
  }

  export type CardAllocationDetailUpdateWithWhereUniqueWithoutCardAllocationInput = {
    where: CardAllocationDetailWhereUniqueInput
    data: XOR<CardAllocationDetailUpdateWithoutCardAllocationInput, CardAllocationDetailUncheckedUpdateWithoutCardAllocationInput>
  }

  export type CardAllocationDetailUpdateManyWithWhereWithoutCardAllocationInput = {
    where: CardAllocationDetailScalarWhereInput
    data: XOR<CardAllocationDetailUpdateManyMutationInput, CardAllocationDetailUncheckedUpdateManyWithoutCardAllocationInput>
  }

  export type ShopCreateWithoutCardRequestInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    payment?: PaymentCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutCardRequestInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    payment?: PaymentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutCardRequestInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutCardRequestInput, ShopUncheckedCreateWithoutCardRequestInput>
  }

  export type CardRequestStatusCreateWithoutCardRequestInput = {
    status: $Enums.CardRequestEnum
    byId?: number | null
    comment?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CardRequestStatusUncheckedCreateWithoutCardRequestInput = {
    id?: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    comment?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CardRequestStatusCreateOrConnectWithoutCardRequestInput = {
    where: CardRequestStatusWhereUniqueInput
    create: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
  }

  export type ShopUpsertWithoutCardRequestInput = {
    update: XOR<ShopUpdateWithoutCardRequestInput, ShopUncheckedUpdateWithoutCardRequestInput>
    create: XOR<ShopCreateWithoutCardRequestInput, ShopUncheckedCreateWithoutCardRequestInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutCardRequestInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutCardRequestInput, ShopUncheckedUpdateWithoutCardRequestInput>
  }

  export type ShopUpdateWithoutCardRequestInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    payment?: PaymentUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutCardRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutShopNestedInput
  }

  export type CardRequestStatusUpsertWithoutCardRequestInput = {
    update: XOR<CardRequestStatusUpdateWithoutCardRequestInput, CardRequestStatusUncheckedUpdateWithoutCardRequestInput>
    create: XOR<CardRequestStatusCreateWithoutCardRequestInput, CardRequestStatusUncheckedCreateWithoutCardRequestInput>
    where?: CardRequestStatusWhereInput
  }

  export type CardRequestStatusUpdateToOneWithWhereWithoutCardRequestInput = {
    where?: CardRequestStatusWhereInput
    data: XOR<CardRequestStatusUpdateWithoutCardRequestInput, CardRequestStatusUncheckedUpdateWithoutCardRequestInput>
  }

  export type CardRequestStatusUpdateWithoutCardRequestInput = {
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardRequestStatusUncheckedUpdateWithoutCardRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardRequestCreateWithoutCardrequeststatusInput = {
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    byId?: number | null
    shop?: ShopCreateNestedOneWithoutCardRequestInput
  }

  export type CardRequestUncheckedCreateWithoutCardrequeststatusInput = {
    id?: number
    label: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    quantity: number
    status: $Enums.CardRequestEnum
    shopId1?: number | null
    byId?: number | null
  }

  export type CardRequestCreateOrConnectWithoutCardrequeststatusInput = {
    where: CardRequestWhereUniqueInput
    create: XOR<CardRequestCreateWithoutCardrequeststatusInput, CardRequestUncheckedCreateWithoutCardrequeststatusInput>
  }

  export type CardRequestUpsertWithoutCardrequeststatusInput = {
    update: XOR<CardRequestUpdateWithoutCardrequeststatusInput, CardRequestUncheckedUpdateWithoutCardrequeststatusInput>
    create: XOR<CardRequestCreateWithoutCardrequeststatusInput, CardRequestUncheckedCreateWithoutCardrequeststatusInput>
    where?: CardRequestWhereInput
  }

  export type CardRequestUpdateToOneWithWhereWithoutCardrequeststatusInput = {
    where?: CardRequestWhereInput
    data: XOR<CardRequestUpdateWithoutCardrequeststatusInput, CardRequestUncheckedUpdateWithoutCardrequeststatusInput>
  }

  export type CardRequestUpdateWithoutCardrequeststatusInput = {
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shop?: ShopUpdateOneWithoutCardRequestNestedInput
  }

  export type CardRequestUncheckedUpdateWithoutCardrequeststatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumCardRequestEnumFieldUpdateOperationsInput | $Enums.CardRequestEnum
    shopId1?: NullableIntFieldUpdateOperationsInput | number | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardCreateWithoutCardAllocationDetailInput = {
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    assignment?: AssignmentCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutCardAllocationDetailInput = {
    id?: number
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    assignment?: AssignmentUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutCardAllocationDetailInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutCardAllocationDetailInput, CardUncheckedCreateWithoutCardAllocationDetailInput>
  }

  export type CardAllocationCreateWithoutCardAllocationDetailInput = {
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shop: ShopCreateNestedOneWithoutCardAllocationInput
  }

  export type CardAllocationUncheckedCreateWithoutCardAllocationDetailInput = {
    id?: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shopId: number
    byId?: number | null
  }

  export type CardAllocationCreateOrConnectWithoutCardAllocationDetailInput = {
    where: CardAllocationWhereUniqueInput
    create: XOR<CardAllocationCreateWithoutCardAllocationDetailInput, CardAllocationUncheckedCreateWithoutCardAllocationDetailInput>
  }

  export type CardUpsertWithoutCardAllocationDetailInput = {
    update: XOR<CardUpdateWithoutCardAllocationDetailInput, CardUncheckedUpdateWithoutCardAllocationDetailInput>
    create: XOR<CardCreateWithoutCardAllocationDetailInput, CardUncheckedCreateWithoutCardAllocationDetailInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutCardAllocationDetailInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutCardAllocationDetailInput, CardUncheckedUpdateWithoutCardAllocationDetailInput>
  }

  export type CardUpdateWithoutCardAllocationDetailInput = {
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    assignment?: AssignmentUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutCardAllocationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    assignment?: AssignmentUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardAllocationUpsertWithoutCardAllocationDetailInput = {
    update: XOR<CardAllocationUpdateWithoutCardAllocationDetailInput, CardAllocationUncheckedUpdateWithoutCardAllocationDetailInput>
    create: XOR<CardAllocationCreateWithoutCardAllocationDetailInput, CardAllocationUncheckedCreateWithoutCardAllocationDetailInput>
    where?: CardAllocationWhereInput
  }

  export type CardAllocationUpdateToOneWithWhereWithoutCardAllocationDetailInput = {
    where?: CardAllocationWhereInput
    data: XOR<CardAllocationUpdateWithoutCardAllocationDetailInput, CardAllocationUncheckedUpdateWithoutCardAllocationDetailInput>
  }

  export type CardAllocationUpdateWithoutCardAllocationDetailInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shop?: ShopUpdateOneRequiredWithoutCardAllocationNestedInput
  }

  export type CardAllocationUncheckedUpdateWithoutCardAllocationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shopId?: IntFieldUpdateOperationsInput | number
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerCreateWithoutAssignmentInput = {
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    Login?: LoginCreateNestedOneWithoutCustomerInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutCustomerInput
    WalletBase: WalletBaseCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAssignmentInput = {
    id?: number
    loginId?: number | null
    address?: string | null
    phone: string
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: Date | string | null
    entityBaseId: number
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAssignmentInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAssignmentInput, CustomerUncheckedCreateWithoutAssignmentInput>
  }

  export type CardCreateWithoutAssignmentInput = {
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocationDetail?: CardAllocationDetailCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutAssignmentInput = {
    id?: number
    serial: string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutAssignmentInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutAssignmentInput, CardUncheckedCreateWithoutAssignmentInput>
  }

  export type CustomerUpsertWithoutAssignmentInput = {
    update: XOR<CustomerUpdateWithoutAssignmentInput, CustomerUncheckedUpdateWithoutAssignmentInput>
    create: XOR<CustomerCreateWithoutAssignmentInput, CustomerUncheckedCreateWithoutAssignmentInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAssignmentInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAssignmentInput, CustomerUncheckedUpdateWithoutAssignmentInput>
  }

  export type CustomerUpdateWithoutAssignmentInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Login?: LoginUpdateOneWithoutCustomerNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutCustomerNestedInput
    WalletBase?: WalletBaseUpdateOneRequiredWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityBaseId?: IntFieldUpdateOperationsInput | number
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CardUpsertWithoutAssignmentInput = {
    update: XOR<CardUpdateWithoutAssignmentInput, CardUncheckedUpdateWithoutAssignmentInput>
    create: XOR<CardCreateWithoutAssignmentInput, CardUncheckedCreateWithoutAssignmentInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutAssignmentInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutAssignmentInput, CardUncheckedUpdateWithoutAssignmentInput>
  }

  export type CardUpdateWithoutAssignmentInput = {
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocationDetail?: CardAllocationDetailUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedUpdateManyWithoutCardNestedInput
  }

  export type PermissionCreateWithoutModuleInput = {
    code: string
    comment?: string | null
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    rolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutModuleInput = {
    id?: number
    code: string
    comment?: string | null
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    rolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutModuleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput>
  }

  export type PermissionCreateManyModuleInputEnvelope = {
    data: PermissionCreateManyModuleInput | PermissionCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionUpsertWithWhereUniqueWithoutModuleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutModuleInput, PermissionUncheckedUpdateWithoutModuleInput>
    create: XOR<PermissionCreateWithoutModuleInput, PermissionUncheckedCreateWithoutModuleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutModuleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutModuleInput, PermissionUncheckedUpdateWithoutModuleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutModuleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutModuleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: IntFilter<"Permission"> | number
    code?: StringFilter<"Permission"> | string
    comment?: StringNullableFilter<"Permission"> | string | null
    moduleId?: IntFilter<"Permission"> | number
    action?: EnumPermissionActionEnumFilter<"Permission"> | $Enums.PermissionActionEnum
    createdAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    byId?: IntNullableFilter<"Permission"> | number | null
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermissionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: number
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type LoginCreateWithoutRoleInput = {
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutLoginInput
    user?: UserCreateNestedOneWithoutLoginInput
    Otp?: OtpCreateNestedManyWithoutLoginInput
  }

  export type LoginUncheckedCreateWithoutRoleInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    customer?: CustomerUncheckedCreateNestedOneWithoutLoginInput
    user?: UserUncheckedCreateNestedOneWithoutLoginInput
    Otp?: OtpUncheckedCreateNestedManyWithoutLoginInput
  }

  export type LoginCreateOrConnectWithoutRoleInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput>
  }

  export type LoginCreateManyRoleInputEnvelope = {
    data: LoginCreateManyRoleInput | LoginCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
  }

  export type LoginUpsertWithWhereUniqueWithoutRoleInput = {
    where: LoginWhereUniqueInput
    update: XOR<LoginUpdateWithoutRoleInput, LoginUncheckedUpdateWithoutRoleInput>
    create: XOR<LoginCreateWithoutRoleInput, LoginUncheckedCreateWithoutRoleInput>
  }

  export type LoginUpdateWithWhereUniqueWithoutRoleInput = {
    where: LoginWhereUniqueInput
    data: XOR<LoginUpdateWithoutRoleInput, LoginUncheckedUpdateWithoutRoleInput>
  }

  export type LoginUpdateManyWithWhereWithoutRoleInput = {
    where: LoginScalarWhereInput
    data: XOR<LoginUpdateManyMutationInput, LoginUncheckedUpdateManyWithoutRoleInput>
  }

  export type LoginScalarWhereInput = {
    AND?: LoginScalarWhereInput | LoginScalarWhereInput[]
    OR?: LoginScalarWhereInput[]
    NOT?: LoginScalarWhereInput | LoginScalarWhereInput[]
    id?: IntFilter<"Login"> | number
    type?: EnumLoginEnumFilter<"Login"> | $Enums.LoginEnum
    username?: StringFilter<"Login"> | string
    password?: StringFilter<"Login"> | string
    isActive?: BoolFilter<"Login"> | boolean
    isBlocked?: BoolFilter<"Login"> | boolean
    roleId?: IntNullableFilter<"Login"> | number | null
    createdAt?: DateTimeNullableFilter<"Login"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Login"> | Date | string | null
  }

  export type RoleCreateWithoutRolePermissionInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    login?: LoginCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    comment?: string | null
    byId?: number | null
    isActive?: boolean
    login?: LoginUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermissionCreateWithoutRolePermissionInput = {
    code: string
    comment?: string | null
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    module: ModuleCreateNestedOneWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutRolePermissionInput = {
    id?: number
    code: string
    comment?: string | null
    moduleId: number
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type PermissionCreateOrConnectWithoutRolePermissionInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionInput, PermissionUncheckedCreateWithoutRolePermissionInput>
  }

  export type RoleUpsertWithoutRolePermissionInput = {
    update: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
  }

  export type RoleUpdateWithoutRolePermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    login?: LoginUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    login?: LoginUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionInput, PermissionUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<PermissionCreateWithoutRolePermissionInput, PermissionUncheckedCreateWithoutRolePermissionInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionInput, PermissionUncheckedUpdateWithoutRolePermissionInput>
  }

  export type PermissionUpdateWithoutRolePermissionInput = {
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    module?: ModuleUpdateOneRequiredWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: IntFieldUpdateOperationsInput | number
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ModuleCreateWithoutPermissionInput = {
    name: string
    isActive?: boolean
  }

  export type ModuleUncheckedCreateWithoutPermissionInput = {
    id?: number
    name: string
    isActive?: boolean
  }

  export type ModuleCreateOrConnectWithoutPermissionInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPermissionInput, ModuleUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: number
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutPermissionInput = {
    update: XOR<ModuleUpdateWithoutPermissionInput, ModuleUncheckedUpdateWithoutPermissionInput>
    create: XOR<ModuleCreateWithoutPermissionInput, ModuleUncheckedCreateWithoutPermissionInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutPermissionInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutPermissionInput, ModuleUncheckedUpdateWithoutPermissionInput>
  }

  export type ModuleUpdateWithoutPermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PaymentCreateWithoutOfferInput = {
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shop: ShopCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOfferInput = {
    id?: number
    shopId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutOfferInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput>
  }

  export type PaymentCreateManyOfferInputEnvelope = {
    data: PaymentCreateManyOfferInput | PaymentCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutOfferInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOfferInput, PaymentUncheckedUpdateWithoutOfferInput>
    create: XOR<PaymentCreateWithoutOfferInput, PaymentUncheckedCreateWithoutOfferInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOfferInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOfferInput, PaymentUncheckedUpdateWithoutOfferInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOfferInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOfferInput>
  }

  export type ShopCreateWithoutPaymentInput = {
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    entityBase: WalletBaseCreateNestedOneWithoutShopInput
    cardAllocation?: CardAllocationCreateNestedManyWithoutShopInput
    userShop?: UserShopCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestCreateNestedOneWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutPaymentInput = {
    id?: number
    entityBaseId: number
    laltitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    cardAllocation?: CardAllocationUncheckedCreateNestedManyWithoutShopInput
    userShop?: UserShopUncheckedCreateNestedManyWithoutShopInput
    customerAlias?: CustomerAliasUncheckedCreateNestedManyWithoutShopInput
    cardRequest?: CardRequestUncheckedCreateNestedOneWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutPaymentInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutPaymentInput, ShopUncheckedCreateWithoutPaymentInput>
  }

  export type OfferCreateWithoutPaymentInput = {
    name: string
    comment?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    duration: number
  }

  export type OfferUncheckedCreateWithoutPaymentInput = {
    id?: number
    name: string
    comment?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    duration: number
  }

  export type OfferCreateOrConnectWithoutPaymentInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutPaymentInput, OfferUncheckedCreateWithoutPaymentInput>
  }

  export type ShopUpsertWithoutPaymentInput = {
    update: XOR<ShopUpdateWithoutPaymentInput, ShopUncheckedUpdateWithoutPaymentInput>
    create: XOR<ShopCreateWithoutPaymentInput, ShopUncheckedCreateWithoutPaymentInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutPaymentInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutPaymentInput, ShopUncheckedUpdateWithoutPaymentInput>
  }

  export type ShopUpdateWithoutPaymentInput = {
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    entityBase?: WalletBaseUpdateOneRequiredWithoutShopNestedInput
    cardAllocation?: CardAllocationUpdateManyWithoutShopNestedInput
    userShop?: UserShopUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUpdateOneWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityBaseId?: IntFieldUpdateOperationsInput | number
    laltitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocation?: CardAllocationUncheckedUpdateManyWithoutShopNestedInput
    userShop?: UserShopUncheckedUpdateManyWithoutShopNestedInput
    customerAlias?: CustomerAliasUncheckedUpdateManyWithoutShopNestedInput
    cardRequest?: CardRequestUncheckedUpdateOneWithoutShopNestedInput
  }

  export type OfferUpsertWithoutPaymentInput = {
    update: XOR<OfferUpdateWithoutPaymentInput, OfferUncheckedUpdateWithoutPaymentInput>
    create: XOR<OfferCreateWithoutPaymentInput, OfferUncheckedCreateWithoutPaymentInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutPaymentInput, OfferUncheckedUpdateWithoutPaymentInput>
  }

  export type OfferUpdateWithoutPaymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type OfferUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCreateManyLoginInput = {
    id?: number
    to?: string | null
    code: string
    duration?: $Enums.OptDurationEnum
    via?: $Enums.OptViaEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OtpUpdateWithoutLoginInput = {
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateWithoutLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyWithoutLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    to?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    duration?: EnumOptDurationEnumFieldUpdateOperationsInput | $Enums.OptDurationEnum
    via?: EnumOptViaEnumFieldUpdateOperationsInput | $Enums.OptViaEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserShopCreateManyUserInput = {
    shopId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type UserShopUpdateWithoutUserInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
    shop?: ShopUpdateOneRequiredWithoutUserShopNestedInput
  }

  export type UserShopUncheckedUpdateWithoutUserInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type UserShopUncheckedUpdateManyWithoutUserInput = {
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type CustomerAliasCreateManyCustomerInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    shopId: number
    isActive?: boolean
  }

  export type AssignmentCreateManyCustomerInput = {
    cardId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type CustomerAliasUpdateWithoutCustomerInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shop?: ShopUpdateOneRequiredWithoutCustomerAliasNestedInput
    dept?: DeptUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dept?: DeptUncheckedUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUncheckedUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    shopId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AssignmentUpdateWithoutCustomerInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    card?: CardUpdateOneRequiredWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutCustomerInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignmentUncheckedUpdateManyWithoutCustomerInput = {
    cardId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeptCreateManyCustomerAliasInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    type: $Enums.TransactionTypeEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DebtStatusCreateManyCustomerAliasInput = {
    id?: number
    totalCredit: Decimal | DecimalJsLike | number | string
    totalDebut: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DeptUpdateWithoutCustomerAliasInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeptUncheckedUpdateWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeptUncheckedUpdateManyWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeEnumFieldUpdateOperationsInput | $Enums.TransactionTypeEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DebtStatusUpdateWithoutCustomerAliasInput = {
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DebtStatusUncheckedUpdateWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DebtStatusUncheckedUpdateManyWithoutCustomerAliasInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDebut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CardAllocationCreateManyShopInput = {
    id?: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type UserShopCreateManyShopInput = {
    userId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    role: $Enums.UserShopRoleEnum
  }

  export type CustomerAliasCreateManyShopInput = {
    id?: number
    customerId: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
    isActive?: boolean
  }

  export type PaymentCreateManyShopInput = {
    id?: number
    offerId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CardAllocationUpdateWithoutShopInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocationDetail?: CardAllocationDetailUpdateManyWithoutCardAllocationNestedInput
  }

  export type CardAllocationUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    cardAllocationDetail?: CardAllocationDetailUncheckedUpdateManyWithoutCardAllocationNestedInput
  }

  export type CardAllocationUncheckedUpdateManyWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserShopUpdateWithoutShopInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
    user?: UserUpdateOneRequiredWithoutUserShopNestedInput
  }

  export type UserShopUncheckedUpdateWithoutShopInput = {
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type UserShopUncheckedUpdateManyWithoutShopInput = {
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserShopRoleEnumFieldUpdateOperationsInput | $Enums.UserShopRoleEnum
  }

  export type CustomerAliasUpdateWithoutShopInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutCustomerAliasNestedInput
    dept?: DeptUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dept?: DeptUncheckedUpdateManyWithoutCustomerAliasNestedInput
    debtStatus?: DebtStatusUncheckedUpdateManyWithoutCustomerAliasNestedInput
  }

  export type CustomerAliasUncheckedUpdateManyWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUpdateWithoutShopInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer?: OfferUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    offerId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    offerId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyFromInput = {
    id?: number
    toId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type TransactionCreateManyToInput = {
    id?: number
    fromId: number
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    walletBaseId?: number | null
  }

  export type WalletStatusCreateManyWalletBaseInput = {
    id?: number
    totalDebit: Decimal | DecimalJsLike | number | string
    totalCredit: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
  }

  export type TransactionUpdateWithoutFromInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
    to?: WalletBaseUpdateOneRequiredWithoutToTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUpdateWithoutToInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
    from?: WalletBaseUpdateOneRequiredWithoutFromTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WalletStatusUpdateWithoutWalletBaseInput = {
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletStatusUncheckedUpdateWithoutWalletBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletStatusUncheckedUpdateManyWithoutWalletBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDebit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentCreateManyCardInput = {
    customerId: number
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type CardAllocationDetailCreateManyCardInput = {
    cardAllocationId: number
  }

  export type AssignmentUpdateWithoutCardInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: CustomerUpdateOneRequiredWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutCardInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignmentUncheckedUpdateManyWithoutCardInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardAllocationDetailUpdateWithoutCardInput = {
    cardAllocation?: CardAllocationUpdateOneRequiredWithoutCardAllocationDetailNestedInput
  }

  export type CardAllocationDetailUncheckedUpdateWithoutCardInput = {
    cardAllocationId?: IntFieldUpdateOperationsInput | number
  }

  export type CardAllocationDetailUncheckedUpdateManyWithoutCardInput = {
    cardAllocationId?: IntFieldUpdateOperationsInput | number
  }

  export type CardAllocationDetailCreateManyCardAllocationInput = {
    cardId: number
  }

  export type CardAllocationDetailUpdateWithoutCardAllocationInput = {
    card?: CardUpdateOneRequiredWithoutCardAllocationDetailNestedInput
  }

  export type CardAllocationDetailUncheckedUpdateWithoutCardAllocationInput = {
    cardId?: IntFieldUpdateOperationsInput | number
  }

  export type CardAllocationDetailUncheckedUpdateManyWithoutCardAllocationInput = {
    cardId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionCreateManyModuleInput = {
    id?: number
    code: string
    comment?: string | null
    action: $Enums.PermissionActionEnum
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    byId?: number | null
  }

  export type PermissionUpdateWithoutModuleInput = {
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermission?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumPermissionActionEnumFieldUpdateOperationsInput | $Enums.PermissionActionEnum
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    byId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: number
  }

  export type LoginCreateManyRoleInput = {
    id?: number
    type: $Enums.LoginEnum
    username: string
    password: string
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type LoginUpdateWithoutRoleInput = {
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutLoginNestedInput
    user?: UserUpdateOneWithoutLoginNestedInput
    Otp?: OtpUpdateManyWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUncheckedUpdateOneWithoutLoginNestedInput
    user?: UserUncheckedUpdateOneWithoutLoginNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumLoginEnumFieldUpdateOperationsInput | $Enums.LoginEnum
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: number
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateManyOfferInput = {
    id?: number
    shopId: number
    amount: Decimal | DecimalJsLike | number | string
    byId: number
    expirationDate: Date | string
    isActive?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PaymentUpdateWithoutOfferInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shop?: ShopUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    byId?: IntFieldUpdateOperationsInput | number
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}